contract main {




// =====================  Runtime code  =====================


#
#  - checkAavePosition(address arg1, address arg2, address arg3, uint256[] arg4, address arg5, address arg6, uint256[] arg7, uint256 arg8, bool arg9)
#  - sub_eaf44ae2(?)
#
const nativeToken = 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee


address sub_238f9b7aAddress;
address sub_5f9d4d2eAddress;
address instaIndexAddress;
address sub_b729cbebAddress;

function sub_238f9b7a(?) payable {
    return sub_238f9b7aAddress
}

function sub_5f9d4d2e(?) payable {
    return sub_5f9d4d2eAddress
}

function instaIndex() payable {
    return instaIndexAddress
}

function sub_b729cbeb(?) payable {
    return sub_b729cbebAddress
}

function _fallback() payable {
    revert
}

function sub_222641c0(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require ext_code.size(sub_238f9b7aAddress)
    staticcall sub_238f9b7aAddress.getLendingPool() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getUserAccountData(address rg1) with:
            gas gas_remaining wei
           args address(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 192
    if 1000000000000000000 * 10^18 > !(arg2 / 2):
        revert with 0, 17
    if not arg2:
        revert with 0, 18
    return ext_call.return_data[160] > (arg2 / 2) + 1000000000000000000 * 10^18 / arg2, 
           ext_call.return_data[96],
           ext_call.return_data[128]
}

function sub_899149ef(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(sub_238f9b7aAddress)
    staticcall sub_238f9b7aAddress.getPriceOracle() with:
            gas gas_remaining wei
    mem[ceil32(32 * ('cd', 4).length) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 97] = 0x9d23d9f200000000000000000000000000000000000000000000000000000000
    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 101] = 32
    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 133] = ('cd', 4).length
    idx = 0
    s = 128
    t = ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 165
    while idx < ('cd', 4).length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getAssetsPrices(address[] rg1) with:
            gas gas_remaining wei
           args Array(len=('cd', 4).length, data=mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 165 len 32 * ('cd', 4).length])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 97 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 97
    require return_data.size >= 32
    _39 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 97 len 4], 0
    require mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 97 len 4], 0 <= test266151307()
    require ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + return_data.size + 97 > ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 97 len 4], 0 + 128
    _40 = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 97 len 4], 0 + 97]
    if mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 97 len 4], 0 + 97] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 97 len 4], 0 + 97]) + 1 < 0 or ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 97 len 4], 0 + 97]) + 98 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + 97 len 4], 0 + 97]) + 98
    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 97] = _40
    require _39 + (32 * _40) + 32 <= return_data.size
    mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 129 len 32 * _40] = mem[ceil32(32 * ('cd', 4).length) + ceil32(return_data.size) + _39 + 129 len 32 * _40]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = _40
    mem[mem[64] + 64 len 32 * _40] = mem[ceil32(32 * ('cd', 4).length) + (2 * ceil32(return_data.size)) + 129 len 32 * _40]
    return Array(len=_40, data=mem[mem[64] + 64 len 32 * _40])
}

function sub_bb17e444(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 4).length
    mem[64] = ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 129
    if not ('cd', 4).length:
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _270 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _276 = mem[_270]
            _277 = mem[_270 + 32]
            _278 = mem[_270 + 64]
            _281 = mem[_270 + 160]
            require mem[_270 + 160] == bool(mem[_270 + 160])
            _295 = mem[_270 + 192]
            require mem[_270 + 192] == bool(mem[_270 + 192])
            require mem[_270 + 224] == bool(mem[_270 + 224])
            _305 = mem[_270 + 256]
            require mem[_270 + 256] == bool(mem[_270 + 256])
            require mem[_270 + 288] == bool(mem[_270 + 288])
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _311 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _313 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _315 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _317 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _320 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _324 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 192] = bool(mem[_270 + 288])
            mem[_324 + 160] = bool(_305)
            mem[_320 + 128] = bool(_295)
            mem[_317 + 96] = bool(_281)
            mem[_315 + 64] = _278
            mem[_313 + 32] = _277
            mem[_311] = _276
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _341 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _347 = mem[_341 + 32]
            _348 = mem[_341 + 64]
            require mem[_341 + 288] == mem[_341 + 315 len 5]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 224] = mem[_341]
            if _347 > !_348:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 256] = _347 + _348
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _254 = mem[64]
        mem[mem[64]] = 32
        _258 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 129
        t = mem[64] + 64
        while idx < _258:
            _376 = mem[s]
            mem[t] = mem[mem[s]]
            mem[t + 32] = mem[_376 + 32]
            mem[t + 64] = mem[_376 + 64]
            mem[t + 96] = bool(mem[_376 + 96])
            mem[t + 128] = bool(mem[_376 + 128])
            mem[t + 160] = bool(mem[_376 + 160])
            mem[t + 192] = bool(mem[_376 + 192])
            mem[t + 224] = mem[_376 + 224]
            mem[t + 256] = mem[_376 + 256]
            idx = idx + 1
            s = s + 32
            t = t + 288
            continue 
        return memory
          from mem[64]
           len _254 + (288 * _258) + -mem[64] + 64
    mem[64] = ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 417
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 129] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 161] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 193] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 225] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 257] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 289] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 321] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 353] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 385] = 0
    mem[var26002] = var26001
    if not var26003 - 1:
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _529 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _536 = mem[_529]
            _537 = mem[_529 + 32]
            _538 = mem[_529 + 64]
            _541 = mem[_529 + 160]
            require mem[_529 + 160] == bool(mem[_529 + 160])
            _554 = mem[_529 + 192]
            require mem[_529 + 192] == bool(mem[_529 + 192])
            require mem[_529 + 224] == bool(mem[_529 + 224])
            _563 = mem[_529 + 256]
            require mem[_529 + 256] == bool(mem[_529 + 256])
            require mem[_529 + 288] == bool(mem[_529 + 288])
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _569 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _571 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _573 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _576 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _580 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _584 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 192] = bool(mem[_529 + 288])
            mem[_584 + 160] = bool(_563)
            mem[_580 + 128] = bool(_554)
            mem[_576 + 96] = bool(_541)
            mem[_573 + 64] = _538
            mem[_571 + 32] = _537
            mem[_569] = _536
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _601 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _606 = mem[_601 + 32]
            _607 = mem[_601 + 64]
            require mem[_601 + 288] == mem[_601 + 315 len 5]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 224] = mem[_601]
            if _606 > !_607:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 256] = _606 + _607
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _513 = mem[64]
        mem[mem[64]] = 32
        _516 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 129
        t = mem[64] + 64
        while idx < _516:
            _635 = mem[s]
            mem[t] = mem[mem[s]]
            mem[t + 32] = mem[_635 + 32]
            mem[t + 64] = mem[_635 + 64]
            mem[t + 96] = bool(mem[_635 + 96])
            mem[t + 128] = bool(mem[_635 + 128])
            mem[t + 160] = bool(mem[_635 + 160])
            mem[t + 192] = bool(mem[_635 + 192])
            mem[t + 224] = mem[_635 + 224]
            mem[t + 256] = mem[_635 + 256]
            idx = idx + 1
            s = s + 32
            t = t + 288
            continue 
        return memory
          from mem[64]
           len _513 + (288 * _516) + -mem[64] + 64
    mem[64] = ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 705
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 417] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 449] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 481] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 513] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 545] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 577] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 609] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 641] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 673] = 0
    mem[var30002] = var30001
    if not var30003 - 1:
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _787 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _794 = mem[_787]
            _795 = mem[_787 + 32]
            _796 = mem[_787 + 64]
            _799 = mem[_787 + 160]
            require mem[_787 + 160] == bool(mem[_787 + 160])
            _812 = mem[_787 + 192]
            require mem[_787 + 192] == bool(mem[_787 + 192])
            require mem[_787 + 224] == bool(mem[_787 + 224])
            _821 = mem[_787 + 256]
            require mem[_787 + 256] == bool(mem[_787 + 256])
            require mem[_787 + 288] == bool(mem[_787 + 288])
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _827 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _829 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _831 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _834 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _838 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _842 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 192] = bool(mem[_787 + 288])
            mem[_842 + 160] = bool(_821)
            mem[_838 + 128] = bool(_812)
            mem[_834 + 96] = bool(_799)
            mem[_831 + 64] = _796
            mem[_829 + 32] = _795
            mem[_827] = _794
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _859 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _864 = mem[_859 + 32]
            _865 = mem[_859 + 64]
            require mem[_859 + 288] == mem[_859 + 315 len 5]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 224] = mem[_859]
            if _864 > !_865:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 256] = _864 + _865
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _771 = mem[64]
        mem[mem[64]] = 32
        _774 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 129
        t = mem[64] + 64
        while idx < _774:
            _893 = mem[s]
            mem[t] = mem[mem[s]]
            mem[t + 32] = mem[_893 + 32]
            mem[t + 64] = mem[_893 + 64]
            mem[t + 96] = bool(mem[_893 + 96])
            mem[t + 128] = bool(mem[_893 + 128])
            mem[t + 160] = bool(mem[_893 + 160])
            mem[t + 192] = bool(mem[_893 + 192])
            mem[t + 224] = mem[_893 + 224]
            mem[t + 256] = mem[_893 + 256]
            idx = idx + 1
            s = s + 32
            t = t + 288
            continue 
        return memory
          from mem[64]
           len _771 + (288 * _774) + -mem[64] + 64
    mem[64] = ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 993
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 705] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 737] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 769] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 801] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 833] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 865] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 897] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 929] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 961] = 0
    mem[var34002] = var34001
    if not var34003 - 1:
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1045 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1052 = mem[_1045]
            _1053 = mem[_1045 + 32]
            _1054 = mem[_1045 + 64]
            _1057 = mem[_1045 + 160]
            require mem[_1045 + 160] == bool(mem[_1045 + 160])
            _1070 = mem[_1045 + 192]
            require mem[_1045 + 192] == bool(mem[_1045 + 192])
            require mem[_1045 + 224] == bool(mem[_1045 + 224])
            _1079 = mem[_1045 + 256]
            require mem[_1045 + 256] == bool(mem[_1045 + 256])
            require mem[_1045 + 288] == bool(mem[_1045 + 288])
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1085 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1087 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1089 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1092 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1096 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1100 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 192] = bool(mem[_1045 + 288])
            mem[_1100 + 160] = bool(_1079)
            mem[_1096 + 128] = bool(_1070)
            mem[_1092 + 96] = bool(_1057)
            mem[_1089 + 64] = _1054
            mem[_1087 + 32] = _1053
            mem[_1085] = _1052
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1117 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1122 = mem[_1117 + 32]
            _1123 = mem[_1117 + 64]
            require mem[_1117 + 288] == mem[_1117 + 315 len 5]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 224] = mem[_1117]
            if _1122 > !_1123:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 256] = _1122 + _1123
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _1029 = mem[64]
        mem[mem[64]] = 32
        _1032 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 129
        t = mem[64] + 64
        while idx < _1032:
            _1151 = mem[s]
            mem[t] = mem[mem[s]]
            mem[t + 32] = mem[_1151 + 32]
            mem[t + 64] = mem[_1151 + 64]
            mem[t + 96] = bool(mem[_1151 + 96])
            mem[t + 128] = bool(mem[_1151 + 128])
            mem[t + 160] = bool(mem[_1151 + 160])
            mem[t + 192] = bool(mem[_1151 + 192])
            mem[t + 224] = mem[_1151 + 224]
            mem[t + 256] = mem[_1151 + 256]
            idx = idx + 1
            s = s + 32
            t = t + 288
            continue 
        return memory
          from mem[64]
           len _1029 + (288 * _1032) + -mem[64] + 64
    mem[64] = ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1281
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 993] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1025] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1057] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1089] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1121] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1153] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1185] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1217] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1249] = 0
    mem[var38002] = var38001
    if not var38003 - 1:
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1303 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1310 = mem[_1303]
            _1311 = mem[_1303 + 32]
            _1312 = mem[_1303 + 64]
            _1315 = mem[_1303 + 160]
            require mem[_1303 + 160] == bool(mem[_1303 + 160])
            _1328 = mem[_1303 + 192]
            require mem[_1303 + 192] == bool(mem[_1303 + 192])
            require mem[_1303 + 224] == bool(mem[_1303 + 224])
            _1337 = mem[_1303 + 256]
            require mem[_1303 + 256] == bool(mem[_1303 + 256])
            require mem[_1303 + 288] == bool(mem[_1303 + 288])
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1343 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1345 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1347 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1350 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1354 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1358 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 192] = bool(mem[_1303 + 288])
            mem[_1358 + 160] = bool(_1337)
            mem[_1354 + 128] = bool(_1328)
            mem[_1350 + 96] = bool(_1315)
            mem[_1347 + 64] = _1312
            mem[_1345 + 32] = _1311
            mem[_1343] = _1310
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1375 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1380 = mem[_1375 + 32]
            _1381 = mem[_1375 + 64]
            require mem[_1375 + 288] == mem[_1375 + 315 len 5]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 224] = mem[_1375]
            if _1380 > !_1381:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 256] = _1380 + _1381
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _1287 = mem[64]
        mem[mem[64]] = 32
        _1290 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 129
        t = mem[64] + 64
        while idx < _1290:
            _1409 = mem[s]
            mem[t] = mem[mem[s]]
            mem[t + 32] = mem[_1409 + 32]
            mem[t + 64] = mem[_1409 + 64]
            mem[t + 96] = bool(mem[_1409 + 96])
            mem[t + 128] = bool(mem[_1409 + 128])
            mem[t + 160] = bool(mem[_1409 + 160])
            mem[t + 192] = bool(mem[_1409 + 192])
            mem[t + 224] = mem[_1409 + 224]
            mem[t + 256] = mem[_1409 + 256]
            idx = idx + 1
            s = s + 32
            t = t + 288
            continue 
        return memory
          from mem[64]
           len _1287 + (288 * _1290) + -mem[64] + 64
    mem[64] = ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1569
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1281] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1313] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1345] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1377] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1409] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1441] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1473] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1505] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1537] = 0
    mem[var42002] = var42001
    if not var42003 - 1:
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1561 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1568 = mem[_1561]
            _1569 = mem[_1561 + 32]
            _1570 = mem[_1561 + 64]
            _1573 = mem[_1561 + 160]
            require mem[_1561 + 160] == bool(mem[_1561 + 160])
            _1586 = mem[_1561 + 192]
            require mem[_1561 + 192] == bool(mem[_1561 + 192])
            require mem[_1561 + 224] == bool(mem[_1561 + 224])
            _1595 = mem[_1561 + 256]
            require mem[_1561 + 256] == bool(mem[_1561 + 256])
            require mem[_1561 + 288] == bool(mem[_1561 + 288])
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1601 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1603 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1605 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1608 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1612 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1616 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 192] = bool(mem[_1561 + 288])
            mem[_1616 + 160] = bool(_1595)
            mem[_1612 + 128] = bool(_1586)
            mem[_1608 + 96] = bool(_1573)
            mem[_1605 + 64] = _1570
            mem[_1603 + 32] = _1569
            mem[_1601] = _1568
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1633 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1638 = mem[_1633 + 32]
            _1639 = mem[_1633 + 64]
            require mem[_1633 + 288] == mem[_1633 + 315 len 5]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 224] = mem[_1633]
            if _1638 > !_1639:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 256] = _1638 + _1639
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _1545 = mem[64]
        mem[mem[64]] = 32
        _1548 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 129
        t = mem[64] + 64
        while idx < _1548:
            _1667 = mem[s]
            mem[t] = mem[mem[s]]
            mem[t + 32] = mem[_1667 + 32]
            mem[t + 64] = mem[_1667 + 64]
            mem[t + 96] = bool(mem[_1667 + 96])
            mem[t + 128] = bool(mem[_1667 + 128])
            mem[t + 160] = bool(mem[_1667 + 160])
            mem[t + 192] = bool(mem[_1667 + 192])
            mem[t + 224] = mem[_1667 + 224]
            mem[t + 256] = mem[_1667 + 256]
            idx = idx + 1
            s = s + 32
            t = t + 288
            continue 
        return memory
          from mem[64]
           len _1545 + (288 * _1548) + -mem[64] + 64
    mem[64] = ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1857
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1569] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1601] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1633] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1665] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1697] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1729] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1761] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1793] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1825] = 0
    mem[var46002] = var46001
    if not var46003 - 1:
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1819 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1826 = mem[_1819]
            _1827 = mem[_1819 + 32]
            _1828 = mem[_1819 + 64]
            _1831 = mem[_1819 + 160]
            require mem[_1819 + 160] == bool(mem[_1819 + 160])
            _1844 = mem[_1819 + 192]
            require mem[_1819 + 192] == bool(mem[_1819 + 192])
            require mem[_1819 + 224] == bool(mem[_1819 + 224])
            _1853 = mem[_1819 + 256]
            require mem[_1819 + 256] == bool(mem[_1819 + 256])
            require mem[_1819 + 288] == bool(mem[_1819 + 288])
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1859 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1861 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1863 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1866 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1870 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1874 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 192] = bool(mem[_1819 + 288])
            mem[_1874 + 160] = bool(_1853)
            mem[_1870 + 128] = bool(_1844)
            mem[_1866 + 96] = bool(_1831)
            mem[_1863 + 64] = _1828
            mem[_1861 + 32] = _1827
            mem[_1859] = _1826
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1891 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1896 = mem[_1891 + 32]
            _1897 = mem[_1891 + 64]
            require mem[_1891 + 288] == mem[_1891 + 315 len 5]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 224] = mem[_1891]
            if _1896 > !_1897:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 256] = _1896 + _1897
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _1803 = mem[64]
        mem[mem[64]] = 32
        _1806 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 129
        t = mem[64] + 64
        while idx < _1806:
            _1925 = mem[s]
            mem[t] = mem[mem[s]]
            mem[t + 32] = mem[_1925 + 32]
            mem[t + 64] = mem[_1925 + 64]
            mem[t + 96] = bool(mem[_1925 + 96])
            mem[t + 128] = bool(mem[_1925 + 128])
            mem[t + 160] = bool(mem[_1925 + 160])
            mem[t + 192] = bool(mem[_1925 + 192])
            mem[t + 224] = mem[_1925 + 224]
            mem[t + 256] = mem[_1925 + 256]
            idx = idx + 1
            s = s + 32
            t = t + 288
            continue 
        return memory
          from mem[64]
           len _1803 + (288 * _1806) + -mem[64] + 64
    mem[64] = ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2145
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1857] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1889] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1921] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1953] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 1985] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2017] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2049] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2081] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2113] = 0
    mem[var50002] = var50001
    if not var50003 - 1:
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2077 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2084 = mem[_2077]
            _2085 = mem[_2077 + 32]
            _2086 = mem[_2077 + 64]
            _2089 = mem[_2077 + 160]
            require mem[_2077 + 160] == bool(mem[_2077 + 160])
            _2102 = mem[_2077 + 192]
            require mem[_2077 + 192] == bool(mem[_2077 + 192])
            require mem[_2077 + 224] == bool(mem[_2077 + 224])
            _2111 = mem[_2077 + 256]
            require mem[_2077 + 256] == bool(mem[_2077 + 256])
            require mem[_2077 + 288] == bool(mem[_2077 + 288])
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _2117 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _2119 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _2121 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _2124 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _2128 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _2132 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 192] = bool(mem[_2077 + 288])
            mem[_2132 + 160] = bool(_2111)
            mem[_2128 + 128] = bool(_2102)
            mem[_2124 + 96] = bool(_2089)
            mem[_2121 + 64] = _2086
            mem[_2119 + 32] = _2085
            mem[_2117] = _2084
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2149 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2154 = mem[_2149 + 32]
            _2155 = mem[_2149 + 64]
            require mem[_2149 + 288] == mem[_2149 + 315 len 5]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 224] = mem[_2149]
            if _2154 > !_2155:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 256] = _2154 + _2155
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _2061 = mem[64]
        mem[mem[64]] = 32
        _2064 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 129
        t = mem[64] + 64
        while idx < _2064:
            _2183 = mem[s]
            mem[t] = mem[mem[s]]
            mem[t + 32] = mem[_2183 + 32]
            mem[t + 64] = mem[_2183 + 64]
            mem[t + 96] = bool(mem[_2183 + 96])
            mem[t + 128] = bool(mem[_2183 + 128])
            mem[t + 160] = bool(mem[_2183 + 160])
            mem[t + 192] = bool(mem[_2183 + 192])
            mem[t + 224] = mem[_2183 + 224]
            mem[t + 256] = mem[_2183 + 256]
            idx = idx + 1
            s = s + 32
            t = t + 288
            continue 
        return memory
          from mem[64]
           len _2061 + (288 * _2064) + -mem[64] + 64
    mem[64] = ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2433
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2145] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2177] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2209] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2241] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2273] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2305] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2337] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2369] = 0
    mem[ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 2401] = 0
    mem[var54002] = var54001
    if var54003 - 1:
        # nil
    else:
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2335 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2342 = mem[_2335]
            _2343 = mem[_2335 + 32]
            _2344 = mem[_2335 + 64]
            _2347 = mem[_2335 + 160]
            require mem[_2335 + 160] == bool(mem[_2335 + 160])
            _2360 = mem[_2335 + 192]
            require mem[_2335 + 192] == bool(mem[_2335 + 192])
            require mem[_2335 + 224] == bool(mem[_2335 + 224])
            _2369 = mem[_2335 + 256]
            require mem[_2335 + 256] == bool(mem[_2335 + 256])
            require mem[_2335 + 288] == bool(mem[_2335 + 288])
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _2375 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _2377 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _2379 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _2382 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _2386 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _2390 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 192] = bool(mem[_2335 + 288])
            mem[_2390 + 160] = bool(_2369)
            mem[_2386 + 128] = bool(_2360)
            mem[_2382 + 96] = bool(_2347)
            mem[_2379 + 64] = _2344
            mem[_2377 + 32] = _2343
            mem[_2375] = _2342
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2407 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2412 = mem[_2407 + 32]
            _2413 = mem[_2407 + 64]
            require mem[_2407 + 288] == mem[_2407 + 315 len 5]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 224] = mem[_2407]
            if _2412 > !_2413:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] + 256] = _2412 + _2413
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _2319 = mem[64]
        mem[mem[64]] = 32
        _2322 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 129
        t = mem[64] + 64
        while idx < _2322:
            _2441 = mem[s]
            mem[t] = mem[mem[s]]
            mem[t + 32] = mem[_2441 + 32]
            mem[t + 64] = mem[_2441 + 64]
            mem[t + 96] = bool(mem[_2441 + 96])
            mem[t + 128] = bool(mem[_2441 + 128])
            mem[t + 160] = bool(mem[_2441 + 160])
            mem[t + 192] = bool(mem[_2441 + 192])
            mem[t + 224] = mem[_2441 + 224]
            mem[t + 256] = mem[_2441 + 256]
            idx = idx + 1
            s = s + 32
            t = t + 288
            continue 
        return memory
          from mem[64]
           len _2319 + (288 * _2322) + -mem[64] + 64
}

function sub_493ebfec(?) payable {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require calldata.size + -cd[4] - 4 >= 64
    require ('cd', 4).length <= test266151307()
    require cd[4] + ('cd', 4).length + 35 < calldata.size
    if cd[(cd[4] + ('cd', 4).length + 4)] > test266151307():
        revert with 0, 65
    if ceil32(32 * cd[(cd[4] + ('cd', 4).length + 4)]) + 161 < 160 or ceil32(32 * cd[(cd[4] + ('cd', 4).length + 4)]) + 161 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * cd[(cd[4] + ('cd', 4).length + 4)]) + 161
    mem[160] = cd[(cd[4] + ('cd', 4).length + 4)]
    require calldata.size >= cd[4] + ('cd', 4).length + (96 * cd[(cd[4] + ('cd', 4).length + 4)]) + 36
    idx = 0
    s = cd[4] + ('cd', 4).length + 36
    t = 192
    while idx < cd[(cd[4] + ('cd', 4).length + 4)]:
        require calldata.size - s >= 96
        _1162 = mem[64]
        if mem[64] + 96 < mem[64] or mem[64] + 96 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + 96
        require cd[s] == address(cd[s])
        mem[_1162] = cd[s]
        require cd[(s + 32)] == address(cd[(s + 32)])
        mem[_1162 + 32] = cd[(s + 32)]
        mem[_1162 + 64] = cd[(s + 64)]
        mem[t] = _1162
        idx = idx + 1
        s = s + 96
        t = t + 32
        continue 
    mem[96] = 160
    require ('cd', 4)[0] <= test266151307()
    require cd[4] + ('cd', 4)[0] + 35 < calldata.size
    if cd[(cd[4] + ('cd', 4)[0] + 4)] > test266151307():
        revert with 0, 65
    _1163 = mem[64]
    if mem[64] + ceil32(32 * cd[(cd[4] + ('cd', 4)[0] + 4)]) + 1 < mem[64] or mem[64] + ceil32(32 * cd[(cd[4] + ('cd', 4)[0] + 4)]) + 1 > test266151307():
        revert with 0, 65
    mem[64] = mem[64] + ceil32(32 * cd[(cd[4] + ('cd', 4)[0] + 4)]) + 1
    mem[_1163] = cd[(cd[4] + ('cd', 4)[0] + 4)]
    require calldata.size >= cd[4] + ('cd', 4)[0] + (96 * cd[(cd[4] + ('cd', 4)[0] + 4)]) + 36
    idx = 0
    s = cd[4] + ('cd', 4)[0] + 36
    t = _1163 + 32
    while idx < cd[(cd[4] + ('cd', 4)[0] + 4)]:
        require calldata.size - s >= 96
        _2321 = mem[64]
        if mem[64] + 96 < mem[64] or mem[64] + 96 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + 96
        require cd[s] == address(cd[s])
        mem[_2321] = cd[s]
        require cd[(s + 32)] == address(cd[(s + 32)])
        mem[_2321 + 32] = cd[(s + 32)]
        mem[_2321 + 64] = cd[(s + 64)]
        mem[t] = _2321
        idx = idx + 1
        s = s + 96
        t = t + 32
        continue 
    mem[128] = _1163
    require cd[36] == bool(cd[36])
    _2322 = mem[64]
    mem[64] = mem[64] + 160
    mem[_2322] = 0
    mem[_2322 + 32] = 96
    mem[_2322 + 64] = 96
    mem[_2322 + 96] = 96
    mem[_2322 + 128] = 96
    _2324 = mem[mem[96]]
    _2326 = mem[_1163]
    if mem[mem[96]] > test266151307():
        revert with 0, 65
    _2327 = mem[64]
    mem[mem[64]] = mem[mem[96]]
    if not _2324:
        mem[_2322 + 32] = mem[64]
        if _2326 > test266151307():
            revert with 0, 65
        mem[_2327 + (32 * _2324) + 32] = _2326
        mem[64] = _2327 + (32 * _2324) + (32 * _2326) + 64
        if not _2326:
            mem[_2322 + 64] = _2327 + (32 * _2324) + 32
            if _2324 > test266151307():
                revert with 0, 65
            mem[_2327 + (32 * _2324) + (32 * _2326) + 64] = _2324
            if not _2324:
                mem[_2322 + 96] = _2327 + (32 * _2324) + (32 * _2326) + 64
                if _2326 > test266151307():
                    revert with 0, 65
                mem[_2327 + (64 * _2324) + (32 * _2326) + 96] = _2326
                mem[64] = _2327 + (64 * _2324) + (64 * _2326) + 128
                if not _2326:
                    mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
                    idx = 0
                    while idx < _2324:
                        if idx >= mem[mem[96]]:
                            revert with 0, 50
                        _3511 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
                        if idx >= mem[mem[96]]:
                            revert with 0, 50
                        if idx >= mem[mem[_2322 + 96]]:
                            revert with 0, 50
                        if not cd[36]:
                            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                                mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                            else:
                                mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
                        else:
                            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                                mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                            else:
                                mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
                        if idx >= mem[mem[_2322 + 32]]:
                            revert with 0, 50
                        mem[(32 * idx) + mem[_2322 + 32] + 32] = _3511
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    idx = 0
                    while idx < _2326:
                        if idx >= mem[mem[128]]:
                            revert with 0, 50
                        _4648 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
                        if idx >= mem[mem[128]]:
                            revert with 0, 50
                        if idx >= mem[mem[_2322 + 128]]:
                            revert with 0, 50
                        if not cd[36]:
                            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                                mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                            else:
                                mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
                        else:
                            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                                mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                            else:
                                mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
                        if idx >= mem[mem[_2322 + 64]]:
                            revert with 0, 50
                        mem[(32 * idx) + mem[_2322 + 64] + 32] = _4648
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _4646 = mem[64]
                    mem[mem[64]] = 32
                    mem[mem[64] + 32] = mem[_2322 + 12 len 20]
                    _4695 = mem[_2322 + 32]
                    mem[mem[64] + 64] = 160
                    _4790 = mem[_4695]
                    mem[mem[64] + 192] = mem[_4695]
                    mem[mem[64] + 224 len 32 * _4790] = mem[_4695 + 32 len 32 * _4790]
                    _5318 = mem[_2322 + 64]
                    mem[mem[64] + 96] = (32 * _4790) + 192
                    _5334 = mem[_5318]
                    mem[mem[64] + (32 * _4790) + 224] = mem[_5318]
                    mem[mem[64] + (32 * _4790) + 256 len 32 * _5334] = mem[_5318 + 32 len 32 * _5334]
                    idx = _5334
                    _5494 = mem[_2322 + 96]
                    mem[mem[64] + 128] = (32 * _4790) + (32 * _5334) + 224
                    _5510 = mem[_5494]
                    mem[mem[64] + (32 * _4790) + (32 * _5334) + 256] = mem[_5494]
                    idx = 0
                    s = _5494 + 32
                    t = mem[64] + (32 * _4790) + (32 * _5334) + 288
                    while idx < _5510:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    _5622 = mem[_2322 + 128]
                    mem[_4646 + 160] = (32 * _4790) + (32 * _5334) + (32 * _5510) + 256
                    _5638 = mem[_5622]
                    mem[_4646 + (32 * _4790) + (32 * _5334) + (32 * _5510) + 288] = mem[_5622]
                    idx = 0
                    s = _5622 + 32
                    t = _4646 + (32 * _4790) + (32 * _5334) + (32 * _5510) + 320
                    while idx < _5638:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    return memory
                      from mem[64]
                       len _4646 + (32 * _4790) + (32 * _5334) + (32 * _5510) + (32 * _5638) + -mem[64] + 320
                mem[_2327 + (64 * _2324) + (32 * _2326) + 128 len 32 * _2326] = call.data[calldata.size len 32 * _2326]
                mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
                idx = 0
                while idx < _2324:
                    if idx >= mem[mem[96]]:
                        revert with 0, 50
                    _3513 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
                    if idx >= mem[mem[96]]:
                        revert with 0, 50
                    if idx >= mem[mem[_2322 + 96]]:
                        revert with 0, 50
                    if not cd[36]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
                    else:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
                    if idx >= mem[mem[_2322 + 32]]:
                        revert with 0, 50
                    mem[(32 * idx) + mem[_2322 + 32] + 32] = _3513
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                idx = 0
                while idx < _2326:
                    if idx >= mem[mem[128]]:
                        revert with 0, 50
                    _4651 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
                    if idx >= mem[mem[128]]:
                        revert with 0, 50
                    if idx >= mem[mem[_2322 + 128]]:
                        revert with 0, 50
                    if not cd[36]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
                    else:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
                    if idx >= mem[mem[_2322 + 64]]:
                        revert with 0, 50
                    mem[(32 * idx) + mem[_2322 + 64] + 32] = _4651
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _4649 = mem[64]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = mem[_2322 + 12 len 20]
                _4701 = mem[_2322 + 32]
                mem[mem[64] + 64] = 160
                _4795 = mem[_4701]
                mem[mem[64] + 192] = mem[_4701]
                mem[mem[64] + 224 len 32 * _4795] = mem[_4701 + 32 len 32 * _4795]
                _5319 = mem[_2322 + 64]
                mem[mem[64] + 96] = (32 * _4795) + 192
                _5335 = mem[_5319]
                mem[mem[64] + (32 * _4795) + 224] = mem[_5319]
                mem[mem[64] + (32 * _4795) + 256 len 32 * _5335] = mem[_5319 + 32 len 32 * _5335]
                idx = _5335
                _5495 = mem[_2322 + 96]
                mem[mem[64] + 128] = (32 * _4795) + (32 * _5335) + 224
                _5511 = mem[_5495]
                mem[mem[64] + (32 * _4795) + (32 * _5335) + 256] = mem[_5495]
                idx = 0
                s = _5495 + 32
                t = mem[64] + (32 * _4795) + (32 * _5335) + 288
                while idx < _5511:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                _5623 = mem[_2322 + 128]
                mem[mem[64] + 160] = (32 * _4795) + (32 * _5335) + (32 * _5511) + 256
                _5639 = mem[_5623]
                mem[mem[64] + (32 * _4795) + (32 * _5335) + (32 * _5511) + 288] = mem[_5623]
                idx = 0
                s = _5623 + 32
                t = mem[64] + (32 * _4795) + (32 * _5335) + (32 * _5511) + 320
                while idx < _5639:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                return memory
                  from mem[64]
                   len _4649 + (32 * _4795) + (32 * _5335) + (32 * _5511) + (32 * _5639) + -mem[64] + 320
            mem[_2327 + (32 * _2324) + (32 * _2326) + 96 len 32 * _2324] = call.data[calldata.size len 32 * _2324]
            mem[_2322 + 96] = _2327 + (32 * _2324) + (32 * _2326) + 64
            if _2326 > test266151307():
                revert with 0, 65
            mem[_2327 + (64 * _2324) + (32 * _2326) + 96] = _2326
            mem[64] = _2327 + (64 * _2324) + (64 * _2326) + 128
            if not _2326:
                mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
                idx = 0
                while idx < _2324:
                    if idx >= mem[mem[96]]:
                        revert with 0, 50
                    _3515 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
                    if idx >= mem[mem[96]]:
                        revert with 0, 50
                    if idx >= mem[mem[_2322 + 96]]:
                        revert with 0, 50
                    if not cd[36]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
                    else:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
                    if idx >= mem[mem[_2322 + 32]]:
                        revert with 0, 50
                    mem[(32 * idx) + mem[_2322 + 32] + 32] = _3515
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                idx = 0
                while idx < _2326:
                    if idx >= mem[mem[128]]:
                        revert with 0, 50
                    _4654 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
                    if idx >= mem[mem[128]]:
                        revert with 0, 50
                    if idx >= mem[mem[_2322 + 128]]:
                        revert with 0, 50
                    if not cd[36]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
                    else:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
                    if idx >= mem[mem[_2322 + 64]]:
                        revert with 0, 50
                    mem[(32 * idx) + mem[_2322 + 64] + 32] = _4654
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _4652 = mem[64]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = mem[_2322 + 12 len 20]
                _4707 = mem[_2322 + 32]
                mem[mem[64] + 64] = 160
                _4800 = mem[_4707]
                mem[mem[64] + 192] = mem[_4707]
                mem[mem[64] + 224 len 32 * _4800] = mem[_4707 + 32 len 32 * _4800]
                _5320 = mem[_2322 + 64]
                mem[mem[64] + 96] = (32 * _4800) + 192
                _5336 = mem[_5320]
                mem[mem[64] + (32 * _4800) + 224] = mem[_5320]
                mem[mem[64] + (32 * _4800) + 256 len 32 * _5336] = mem[_5320 + 32 len 32 * _5336]
                idx = _5336
                _5496 = mem[_2322 + 96]
                mem[mem[64] + 128] = (32 * _4800) + (32 * _5336) + 224
                _5512 = mem[_5496]
                mem[mem[64] + (32 * _4800) + (32 * _5336) + 256] = mem[_5496]
                idx = 0
                s = _5496 + 32
                t = mem[64] + (32 * _4800) + (32 * _5336) + 288
                while idx < _5512:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                _5624 = mem[_2322 + 128]
                mem[_4652 + 160] = (32 * _4800) + (32 * _5336) + (32 * _5512) + 256
                _5640 = mem[_5624]
                mem[_4652 + (32 * _4800) + (32 * _5336) + (32 * _5512) + 288] = mem[_5624]
                idx = 0
                s = _5624 + 32
                t = _4652 + (32 * _4800) + (32 * _5336) + (32 * _5512) + 320
                while idx < _5640:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                return memory
                  from mem[64]
                   len _4652 + (32 * _4800) + (32 * _5336) + (32 * _5512) + (32 * _5640) + -mem[64] + 320
            mem[_2327 + (64 * _2324) + (32 * _2326) + 128 len 32 * _2326] = call.data[calldata.size len 32 * _2326]
            mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
            idx = 0
            while idx < _2324:
                if idx >= mem[mem[96]]:
                    revert with 0, 50
                _3517 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
                if idx >= mem[mem[96]]:
                    revert with 0, 50
                if idx >= mem[mem[_2322 + 96]]:
                    revert with 0, 50
                if not cd[36]:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
                else:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
                if idx >= mem[mem[_2322 + 32]]:
                    revert with 0, 50
                mem[(32 * idx) + mem[_2322 + 32] + 32] = _3517
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            idx = 0
            while idx < _2326:
                if idx >= mem[mem[128]]:
                    revert with 0, 50
                _4657 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
                if idx >= mem[mem[128]]:
                    revert with 0, 50
                if idx >= mem[mem[_2322 + 128]]:
                    revert with 0, 50
                if not cd[36]:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
                else:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
                if idx >= mem[mem[_2322 + 64]]:
                    revert with 0, 50
                mem[(32 * idx) + mem[_2322 + 64] + 32] = _4657
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _4655 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[_2322 + 12 len 20]
            _4713 = mem[_2322 + 32]
            mem[mem[64] + 64] = 160
            _4805 = mem[_4713]
            mem[mem[64] + 192] = mem[_4713]
            mem[mem[64] + 224 len 32 * _4805] = mem[_4713 + 32 len 32 * _4805]
            var64001 = _4805
            _5321 = mem[_2322 + 64]
            mem[mem[64] + 96] = (32 * _4805) + 192
            _5337 = mem[_5321]
            mem[mem[64] + (32 * _4805) + 224] = mem[_5321]
            mem[mem[64] + (32 * _4805) + 256 len 32 * _5337] = mem[_5321 + 32 len 32 * _5337]
            idx = _5337
            _5497 = mem[_2322 + 96]
            mem[mem[64] + 128] = (32 * _4805) + (32 * _5337) + 224
            _5513 = mem[_5497]
            mem[mem[64] + (32 * _4805) + (32 * _5337) + 256] = mem[_5497]
            idx = 0
            s = _5497 + 32
            t = mem[64] + (32 * _4805) + (32 * _5337) + 288
            while idx < _5513:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            _5625 = mem[_2322 + 128]
            mem[_4655 + 160] = (32 * _4805) + (32 * _5337) + (32 * _5513) + 256
            _5641 = mem[_5625]
            mem[_4655 + (32 * _4805) + (32 * _5337) + (32 * _5513) + 288] = mem[_5625]
            idx = 0
            s = _5625 + 32
            t = _4655 + (32 * _4805) + (32 * _5337) + (32 * _5513) + 320
            while idx < _5641:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            return memory
              from mem[64]
               len _4655 + (32 * _4805) + (32 * _5337) + (32 * _5513) + (32 * _5641) + -mem[64] + 320
        mem[_2327 + (32 * _2324) + 64 len 32 * _2326] = call.data[calldata.size len 32 * _2326]
        mem[_2322 + 64] = _2327 + (32 * _2324) + 32
        if _2324 > test266151307():
            revert with 0, 65
        mem[_2327 + (32 * _2324) + (32 * _2326) + 64] = _2324
        if not _2324:
            mem[_2322 + 96] = _2327 + (32 * _2324) + (32 * _2326) + 64
            if _2326 > test266151307():
                revert with 0, 65
            mem[_2327 + (64 * _2324) + (32 * _2326) + 96] = _2326
            mem[64] = _2327 + (64 * _2324) + (64 * _2326) + 128
            if not _2326:
                mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
                idx = 0
                while idx < _2324:
                    if idx >= mem[mem[96]]:
                        revert with 0, 50
                    _3519 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
                    if idx >= mem[mem[96]]:
                        revert with 0, 50
                    if idx >= mem[mem[_2322 + 96]]:
                        revert with 0, 50
                    if not cd[36]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
                    else:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
                    if idx >= mem[mem[_2322 + 32]]:
                        revert with 0, 50
                    mem[(32 * idx) + mem[_2322 + 32] + 32] = _3519
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                idx = 0
                while idx < _2326:
                    if idx >= mem[mem[128]]:
                        revert with 0, 50
                    _4660 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
                    if idx >= mem[mem[128]]:
                        revert with 0, 50
                    if idx >= mem[mem[_2322 + 128]]:
                        revert with 0, 50
                    if not cd[36]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
                    else:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
                    if idx >= mem[mem[_2322 + 64]]:
                        revert with 0, 50
                    mem[(32 * idx) + mem[_2322 + 64] + 32] = _4660
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _4658 = mem[64]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = mem[_2322 + 12 len 20]
                _4719 = mem[_2322 + 32]
                mem[mem[64] + 64] = 160
                _4810 = mem[_4719]
                mem[mem[64] + 192] = mem[_4719]
                mem[mem[64] + 224 len 32 * _4810] = mem[_4719 + 32 len 32 * _4810]
                _5322 = mem[_2322 + 64]
                mem[mem[64] + 96] = (32 * _4810) + 192
                _5338 = mem[_5322]
                mem[mem[64] + (32 * _4810) + 224] = mem[_5322]
                mem[mem[64] + (32 * _4810) + 256 len 32 * _5338] = mem[_5322 + 32 len 32 * _5338]
                idx = _5338
                _5498 = mem[_2322 + 96]
                mem[mem[64] + 128] = (32 * _4810) + (32 * _5338) + 224
                _5514 = mem[_5498]
                mem[mem[64] + (32 * _4810) + (32 * _5338) + 256] = mem[_5498]
                idx = 0
                s = _5498 + 32
                t = mem[64] + (32 * _4810) + (32 * _5338) + 288
                while idx < _5514:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                _5626 = mem[_2322 + 128]
                mem[_4658 + 160] = (32 * _4810) + (32 * _5338) + (32 * _5514) + 256
                _5642 = mem[_5626]
                mem[_4658 + (32 * _4810) + (32 * _5338) + (32 * _5514) + 288] = mem[_5626]
                idx = 0
                s = _5626 + 32
                t = _4658 + (32 * _4810) + (32 * _5338) + (32 * _5514) + 320
                while idx < _5642:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                return memory
                  from mem[64]
                   len _4658 + (32 * _4810) + (32 * _5338) + (32 * _5514) + (32 * _5642) + -mem[64] + 320
            mem[_2327 + (64 * _2324) + (32 * _2326) + 128 len 32 * _2326] = call.data[calldata.size len 32 * _2326]
            mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
            idx = 0
            while idx < _2324:
                if idx >= mem[mem[96]]:
                    revert with 0, 50
                _3521 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
                if idx >= mem[mem[96]]:
                    revert with 0, 50
                if idx >= mem[mem[_2322 + 96]]:
                    revert with 0, 50
                if not cd[36]:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
                else:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
                if idx >= mem[mem[_2322 + 32]]:
                    revert with 0, 50
                mem[(32 * idx) + mem[_2322 + 32] + 32] = _3521
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            idx = 0
            while idx < _2326:
                if idx >= mem[mem[128]]:
                    revert with 0, 50
                _4663 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
                if idx >= mem[mem[128]]:
                    revert with 0, 50
                if idx >= mem[mem[_2322 + 128]]:
                    revert with 0, 50
                if not cd[36]:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
                else:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
                if idx >= mem[mem[_2322 + 64]]:
                    revert with 0, 50
                mem[(32 * idx) + mem[_2322 + 64] + 32] = _4663
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _4661 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[_2322 + 12 len 20]
            _4725 = mem[_2322 + 32]
            mem[mem[64] + 64] = 160
            _4815 = mem[_4725]
            mem[mem[64] + 192] = mem[_4725]
            mem[mem[64] + 224 len 32 * _4815] = mem[_4725 + 32 len 32 * _4815]
            var64001 = _4815
            _5323 = mem[_2322 + 64]
            mem[mem[64] + 96] = (32 * _4815) + 192
            _5339 = mem[_5323]
            mem[mem[64] + (32 * _4815) + 224] = mem[_5323]
            mem[mem[64] + (32 * _4815) + 256 len 32 * _5339] = mem[_5323 + 32 len 32 * _5339]
            idx = _5339
            _5499 = mem[_2322 + 96]
            mem[mem[64] + 128] = (32 * _4815) + (32 * _5339) + 224
            _5515 = mem[_5499]
            mem[mem[64] + (32 * _4815) + (32 * _5339) + 256] = mem[_5499]
            idx = 0
            s = _5499 + 32
            t = mem[64] + (32 * _4815) + (32 * _5339) + 288
            while idx < _5515:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            _5627 = mem[_2322 + 128]
            mem[_4661 + 160] = (32 * _4815) + (32 * _5339) + (32 * _5515) + 256
            _5643 = mem[_5627]
            mem[_4661 + (32 * _4815) + (32 * _5339) + (32 * _5515) + 288] = mem[_5627]
            idx = 0
            s = _5627 + 32
            t = _4661 + (32 * _4815) + (32 * _5339) + (32 * _5515) + 320
            while idx < _5643:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            return memory
              from mem[64]
               len _4661 + (32 * _4815) + (32 * _5339) + (32 * _5515) + (32 * _5643) + -mem[64] + 320
        mem[_2327 + (32 * _2324) + (32 * _2326) + 96 len 32 * _2324] = call.data[calldata.size len 32 * _2324]
        mem[_2322 + 96] = _2327 + (32 * _2324) + (32 * _2326) + 64
        if _2326 > test266151307():
            revert with 0, 65
        mem[_2327 + (64 * _2324) + (32 * _2326) + 96] = _2326
        mem[64] = _2327 + (64 * _2324) + (64 * _2326) + 128
        if not _2326:
            mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
            idx = 0
            while idx < _2324:
                if idx >= mem[mem[96]]:
                    revert with 0, 50
                _3523 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
                if idx >= mem[mem[96]]:
                    revert with 0, 50
                if idx >= mem[mem[_2322 + 96]]:
                    revert with 0, 50
                if not cd[36]:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
                else:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
                if idx >= mem[mem[_2322 + 32]]:
                    revert with 0, 50
                mem[(32 * idx) + mem[_2322 + 32] + 32] = _3523
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            idx = 0
            while idx < _2326:
                if idx >= mem[mem[128]]:
                    revert with 0, 50
                _4666 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
                if idx >= mem[mem[128]]:
                    revert with 0, 50
                if idx >= mem[mem[_2322 + 128]]:
                    revert with 0, 50
                if not cd[36]:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
                else:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
                if idx >= mem[mem[_2322 + 64]]:
                    revert with 0, 50
                mem[(32 * idx) + mem[_2322 + 64] + 32] = _4666
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _4664 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[_2322 + 12 len 20]
            _4731 = mem[_2322 + 32]
            mem[mem[64] + 64] = 160
            _4820 = mem[_4731]
            mem[mem[64] + 192] = mem[_4731]
            mem[mem[64] + 224 len 32 * _4820] = mem[_4731 + 32 len 32 * _4820]
            var64001 = _4820
            _5324 = mem[_2322 + 64]
            mem[mem[64] + 96] = (32 * _4820) + 192
            _5340 = mem[_5324]
            mem[mem[64] + (32 * _4820) + 224] = mem[_5324]
            mem[mem[64] + (32 * _4820) + 256 len 32 * _5340] = mem[_5324 + 32 len 32 * _5340]
            idx = _5340
            _5500 = mem[_2322 + 96]
            mem[mem[64] + 128] = (32 * _4820) + (32 * _5340) + 224
            _5516 = mem[_5500]
            mem[mem[64] + (32 * _4820) + (32 * _5340) + 256] = mem[_5500]
            idx = 0
            s = _5500 + 32
            t = mem[64] + (32 * _4820) + (32 * _5340) + 288
            while idx < _5516:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            _5628 = mem[_2322 + 128]
            mem[_4664 + 160] = (32 * _4820) + (32 * _5340) + (32 * _5516) + 256
            _5644 = mem[_5628]
            mem[_4664 + (32 * _4820) + (32 * _5340) + (32 * _5516) + 288] = mem[_5628]
            idx = 0
            s = _5628 + 32
            t = _4664 + (32 * _4820) + (32 * _5340) + (32 * _5516) + 320
            while idx < _5644:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            return memory
              from mem[64]
               len _4664 + (32 * _4820) + (32 * _5340) + (32 * _5516) + (32 * _5644) + -mem[64] + 320
        mem[_2327 + (64 * _2324) + (32 * _2326) + 128 len 32 * _2326] = call.data[calldata.size len 32 * _2326]
        mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
        idx = 0
        while idx < _2324:
            if idx >= mem[mem[96]]:
                revert with 0, 50
            _3525 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
            if idx >= mem[mem[96]]:
                revert with 0, 50
            if idx >= mem[mem[_2322 + 96]]:
                revert with 0, 50
            if not cd[36]:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
            else:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
            if idx >= mem[mem[_2322 + 32]]:
                revert with 0, 50
            mem[(32 * idx) + mem[_2322 + 32] + 32] = _3525
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        idx = 0
        while idx < _2326:
            if idx >= mem[mem[128]]:
                revert with 0, 50
            _4669 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[mem[_2322 + 128]]:
                revert with 0, 50
            if not cd[36]:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
            else:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
            if idx >= mem[mem[_2322 + 64]]:
                revert with 0, 50
            mem[(32 * idx) + mem[_2322 + 64] + 32] = _4669
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _4667 = mem[64]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[_2322 + 12 len 20]
        _4737 = mem[_2322 + 32]
        mem[mem[64] + 64] = 160
        _4825 = mem[_4737]
        mem[mem[64] + 192] = mem[_4737]
        mem[mem[64] + 224 len 32 * _4825] = mem[_4737 + 32 len 32 * _4825]
        var65001 = _4825
        _5325 = mem[_2322 + 64]
        mem[mem[64] + 96] = (32 * _4825) + 192
        _5341 = mem[_5325]
        mem[mem[64] + (32 * _4825) + 224] = mem[_5325]
        mem[mem[64] + (32 * _4825) + 256 len 32 * _5341] = mem[_5325 + 32 len 32 * _5341]
        idx = _5341
        _5501 = mem[_2322 + 96]
        mem[mem[64] + 128] = (32 * _4825) + (32 * _5341) + 224
        _5517 = mem[_5501]
        mem[mem[64] + (32 * _4825) + (32 * _5341) + 256] = mem[_5501]
        idx = 0
        s = _5501 + 32
        t = mem[64] + (32 * _4825) + (32 * _5341) + 288
        while idx < _5517:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        _5629 = mem[_2322 + 128]
        mem[mem[64] + 160] = (32 * _4825) + (32 * _5341) + (32 * _5517) + 256
        _5645 = mem[_5629]
        mem[mem[64] + (32 * _4825) + (32 * _5341) + (32 * _5517) + 288] = mem[_5629]
        idx = 0
        s = _5629 + 32
        t = mem[64] + (32 * _4825) + (32 * _5341) + (32 * _5517) + 320
        while idx < _5645:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from mem[64]
           len _4667 + (32 * _4825) + (32 * _5341) + (32 * _5517) + (32 * _5645) + -mem[64] + 320
    mem[mem[64] + 32 len 32 * _2324] = call.data[calldata.size len 32 * _2324]
    mem[_2322 + 32] = mem[64]
    if _2326 > test266151307():
        revert with 0, 65
    mem[_2327 + (32 * _2324) + 32] = _2326
    mem[64] = _2327 + (32 * _2324) + (32 * _2326) + 64
    if not _2326:
        mem[_2322 + 64] = _2327 + (32 * _2324) + 32
        if _2324 > test266151307():
            revert with 0, 65
        mem[_2327 + (32 * _2324) + (32 * _2326) + 64] = _2324
        if not _2324:
            mem[_2322 + 96] = _2327 + (32 * _2324) + (32 * _2326) + 64
            if _2326 > test266151307():
                revert with 0, 65
            mem[_2327 + (64 * _2324) + (32 * _2326) + 96] = _2326
            mem[64] = _2327 + (64 * _2324) + (64 * _2326) + 128
            if not _2326:
                mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
                idx = 0
                while idx < _2324:
                    if idx >= mem[mem[96]]:
                        revert with 0, 50
                    _3527 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
                    if idx >= mem[mem[96]]:
                        revert with 0, 50
                    if idx >= mem[mem[_2322 + 96]]:
                        revert with 0, 50
                    if not cd[36]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
                    else:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
                    if idx >= mem[mem[_2322 + 32]]:
                        revert with 0, 50
                    mem[(32 * idx) + mem[_2322 + 32] + 32] = _3527
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                idx = 0
                while idx < _2326:
                    if idx >= mem[mem[128]]:
                        revert with 0, 50
                    _4672 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
                    if idx >= mem[mem[128]]:
                        revert with 0, 50
                    if idx >= mem[mem[_2322 + 128]]:
                        revert with 0, 50
                    if not cd[36]:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
                    else:
                        if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                        else:
                            mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
                    if idx >= mem[mem[_2322 + 64]]:
                        revert with 0, 50
                    mem[(32 * idx) + mem[_2322 + 64] + 32] = _4672
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _4670 = mem[64]
                mem[mem[64]] = 32
                mem[mem[64] + 32] = mem[_2322 + 12 len 20]
                _4743 = mem[_2322 + 32]
                mem[mem[64] + 64] = 160
                _4830 = mem[_4743]
                mem[mem[64] + 192] = mem[_4743]
                mem[mem[64] + 224 len 32 * _4830] = mem[_4743 + 32 len 32 * _4830]
                _5326 = mem[_2322 + 64]
                mem[mem[64] + 96] = (32 * _4830) + 192
                _5342 = mem[_5326]
                mem[mem[64] + (32 * _4830) + 224] = mem[_5326]
                mem[mem[64] + (32 * _4830) + 256 len 32 * _5342] = mem[_5326 + 32 len 32 * _5342]
                idx = _5342
                _5502 = mem[_2322 + 96]
                mem[mem[64] + 128] = (32 * _4830) + (32 * _5342) + 224
                _5518 = mem[_5502]
                mem[mem[64] + (32 * _4830) + (32 * _5342) + 256] = mem[_5502]
                idx = 0
                s = _5502 + 32
                t = mem[64] + (32 * _4830) + (32 * _5342) + 288
                while idx < _5518:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                _5630 = mem[_2322 + 128]
                mem[mem[64] + 160] = (32 * _4830) + (32 * _5342) + (32 * _5518) + 256
                _5646 = mem[_5630]
                mem[mem[64] + (32 * _4830) + (32 * _5342) + (32 * _5518) + 288] = mem[_5630]
                idx = 0
                s = _5630 + 32
                t = mem[64] + (32 * _4830) + (32 * _5342) + (32 * _5518) + 320
                while idx < _5646:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                return memory
                  from mem[64]
                   len _4670 + (32 * _4830) + (32 * _5342) + (32 * _5518) + (32 * _5646) + -mem[64] + 320
            mem[_2327 + (64 * _2324) + (32 * _2326) + 128 len 32 * _2326] = call.data[calldata.size len 32 * _2326]
            mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
            idx = 0
            while idx < _2324:
                if idx >= mem[mem[96]]:
                    revert with 0, 50
                _3529 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
                if idx >= mem[mem[96]]:
                    revert with 0, 50
                if idx >= mem[mem[_2322 + 96]]:
                    revert with 0, 50
                if not cd[36]:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
                else:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
                if idx >= mem[mem[_2322 + 32]]:
                    revert with 0, 50
                mem[(32 * idx) + mem[_2322 + 32] + 32] = _3529
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            idx = 0
            while idx < _2326:
                if idx >= mem[mem[128]]:
                    revert with 0, 50
                _4675 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
                if idx >= mem[mem[128]]:
                    revert with 0, 50
                if idx >= mem[mem[_2322 + 128]]:
                    revert with 0, 50
                if not cd[36]:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
                else:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
                if idx >= mem[mem[_2322 + 64]]:
                    revert with 0, 50
                mem[(32 * idx) + mem[_2322 + 64] + 32] = _4675
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _4673 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[_2322 + 12 len 20]
            _4749 = mem[_2322 + 32]
            mem[mem[64] + 64] = 160
            _4835 = mem[_4749]
            mem[mem[64] + 192] = mem[_4749]
            mem[mem[64] + 224 len 32 * _4835] = mem[_4749 + 32 len 32 * _4835]
            var64001 = _4835
            _5327 = mem[_2322 + 64]
            mem[mem[64] + 96] = (32 * _4835) + 192
            _5343 = mem[_5327]
            mem[mem[64] + (32 * _4835) + 224] = mem[_5327]
            mem[mem[64] + (32 * _4835) + 256 len 32 * _5343] = mem[_5327 + 32 len 32 * _5343]
            idx = _5343
            _5503 = mem[_2322 + 96]
            mem[mem[64] + 128] = (32 * _4835) + (32 * _5343) + 224
            _5519 = mem[_5503]
            mem[mem[64] + (32 * _4835) + (32 * _5343) + 256] = mem[_5503]
            idx = 0
            s = _5503 + 32
            t = mem[64] + (32 * _4835) + (32 * _5343) + 288
            while idx < _5519:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            _5631 = mem[_2322 + 128]
            mem[_4673 + 160] = (32 * _4835) + (32 * _5343) + (32 * _5519) + 256
            _5647 = mem[_5631]
            mem[_4673 + (32 * _4835) + (32 * _5343) + (32 * _5519) + 288] = mem[_5631]
            idx = 0
            s = _5631 + 32
            t = _4673 + (32 * _4835) + (32 * _5343) + (32 * _5519) + 320
            while idx < _5647:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            return memory
              from mem[64]
               len _4673 + (32 * _4835) + (32 * _5343) + (32 * _5519) + (32 * _5647) + -mem[64] + 320
        mem[_2327 + (32 * _2324) + (32 * _2326) + 96 len 32 * _2324] = call.data[calldata.size len 32 * _2324]
        mem[_2322 + 96] = _2327 + (32 * _2324) + (32 * _2326) + 64
        if _2326 > test266151307():
            revert with 0, 65
        mem[_2327 + (64 * _2324) + (32 * _2326) + 96] = _2326
        mem[64] = _2327 + (64 * _2324) + (64 * _2326) + 128
        if not _2326:
            mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
            idx = 0
            while idx < _2324:
                if idx >= mem[mem[96]]:
                    revert with 0, 50
                _3531 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
                if idx >= mem[mem[96]]:
                    revert with 0, 50
                if idx >= mem[mem[_2322 + 96]]:
                    revert with 0, 50
                if not cd[36]:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
                else:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
                if idx >= mem[mem[_2322 + 32]]:
                    revert with 0, 50
                mem[(32 * idx) + mem[_2322 + 32] + 32] = _3531
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            idx = 0
            while idx < _2326:
                if idx >= mem[mem[128]]:
                    revert with 0, 50
                _4678 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
                if idx >= mem[mem[128]]:
                    revert with 0, 50
                if idx >= mem[mem[_2322 + 128]]:
                    revert with 0, 50
                if not cd[36]:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
                else:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
                if idx >= mem[mem[_2322 + 64]]:
                    revert with 0, 50
                mem[(32 * idx) + mem[_2322 + 64] + 32] = _4678
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _4676 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[_2322 + 12 len 20]
            _4755 = mem[_2322 + 32]
            mem[mem[64] + 64] = 160
            _4840 = mem[_4755]
            mem[mem[64] + 192] = mem[_4755]
            mem[mem[64] + 224 len 32 * _4840] = mem[_4755 + 32 len 32 * _4840]
            var64001 = _4840
            _5328 = mem[_2322 + 64]
            mem[mem[64] + 96] = (32 * _4840) + 192
            _5344 = mem[_5328]
            mem[mem[64] + (32 * _4840) + 224] = mem[_5328]
            mem[mem[64] + (32 * _4840) + 256 len 32 * _5344] = mem[_5328 + 32 len 32 * _5344]
            idx = _5344
            _5504 = mem[_2322 + 96]
            mem[mem[64] + 128] = (32 * _4840) + (32 * _5344) + 224
            _5520 = mem[_5504]
            mem[mem[64] + (32 * _4840) + (32 * _5344) + 256] = mem[_5504]
            idx = 0
            s = _5504 + 32
            t = mem[64] + (32 * _4840) + (32 * _5344) + 288
            while idx < _5520:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            _5632 = mem[_2322 + 128]
            mem[mem[64] + 160] = (32 * _4840) + (32 * _5344) + (32 * _5520) + 256
            _5648 = mem[_5632]
            mem[mem[64] + (32 * _4840) + (32 * _5344) + (32 * _5520) + 288] = mem[_5632]
            idx = 0
            s = _5632 + 32
            t = mem[64] + (32 * _4840) + (32 * _5344) + (32 * _5520) + 320
            while idx < _5648:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            return memory
              from mem[64]
               len _4676 + (32 * _4840) + (32 * _5344) + (32 * _5520) + (32 * _5648) + -mem[64] + 320
        mem[_2327 + (64 * _2324) + (32 * _2326) + 128 len 32 * _2326] = call.data[calldata.size len 32 * _2326]
        mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
        idx = 0
        while idx < _2324:
            if idx >= mem[mem[96]]:
                revert with 0, 50
            _3533 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
            if idx >= mem[mem[96]]:
                revert with 0, 50
            if idx >= mem[mem[_2322 + 96]]:
                revert with 0, 50
            if not cd[36]:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
            else:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
            if idx >= mem[mem[_2322 + 32]]:
                revert with 0, 50
            mem[(32 * idx) + mem[_2322 + 32] + 32] = _3533
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        idx = 0
        while idx < _2326:
            if idx >= mem[mem[128]]:
                revert with 0, 50
            _4681 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[mem[_2322 + 128]]:
                revert with 0, 50
            if not cd[36]:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
            else:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
            if idx >= mem[mem[_2322 + 64]]:
                revert with 0, 50
            mem[(32 * idx) + mem[_2322 + 64] + 32] = _4681
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _4679 = mem[64]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[_2322 + 12 len 20]
        _4761 = mem[_2322 + 32]
        mem[mem[64] + 64] = 160
        _4845 = mem[_4761]
        mem[mem[64] + 192] = mem[_4761]
        mem[mem[64] + 224 len 32 * _4845] = mem[_4761 + 32 len 32 * _4845]
        var65001 = _4845
        _5329 = mem[_2322 + 64]
        mem[mem[64] + 96] = (32 * _4845) + 192
        _5345 = mem[_5329]
        mem[mem[64] + (32 * _4845) + 224] = mem[_5329]
        mem[mem[64] + (32 * _4845) + 256 len 32 * _5345] = mem[_5329 + 32 len 32 * _5345]
        idx = _5345
        _5505 = mem[_2322 + 96]
        mem[mem[64] + 128] = (32 * _4845) + (32 * _5345) + 224
        _5521 = mem[_5505]
        mem[mem[64] + (32 * _4845) + (32 * _5345) + 256] = mem[_5505]
        idx = 0
        s = _5505 + 32
        t = mem[64] + (32 * _4845) + (32 * _5345) + 288
        while idx < _5521:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        _5633 = mem[_2322 + 128]
        mem[mem[64] + 160] = (32 * _4845) + (32 * _5345) + (32 * _5521) + 256
        _5649 = mem[_5633]
        mem[mem[64] + (32 * _4845) + (32 * _5345) + (32 * _5521) + 288] = mem[_5633]
        idx = 0
        s = _5633 + 32
        t = mem[64] + (32 * _4845) + (32 * _5345) + (32 * _5521) + 320
        while idx < _5649:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from mem[64]
           len _4679 + (32 * _4845) + (32 * _5345) + (32 * _5521) + (32 * _5649) + -mem[64] + 320
    mem[_2327 + (32 * _2324) + 64 len 32 * _2326] = call.data[calldata.size len 32 * _2326]
    mem[_2322 + 64] = _2327 + (32 * _2324) + 32
    if _2324 > test266151307():
        revert with 0, 65
    mem[_2327 + (32 * _2324) + (32 * _2326) + 64] = _2324
    if not _2324:
        mem[_2322 + 96] = _2327 + (32 * _2324) + (32 * _2326) + 64
        if _2326 > test266151307():
            revert with 0, 65
        mem[_2327 + (64 * _2324) + (32 * _2326) + 96] = _2326
        mem[64] = _2327 + (64 * _2324) + (64 * _2326) + 128
        if not _2326:
            mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
            idx = 0
            while idx < _2324:
                if idx >= mem[mem[96]]:
                    revert with 0, 50
                _3535 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
                if idx >= mem[mem[96]]:
                    revert with 0, 50
                if idx >= mem[mem[_2322 + 96]]:
                    revert with 0, 50
                if not cd[36]:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
                else:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
                if idx >= mem[mem[_2322 + 32]]:
                    revert with 0, 50
                mem[(32 * idx) + mem[_2322 + 32] + 32] = _3535
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            idx = 0
            while idx < _2326:
                if idx >= mem[mem[128]]:
                    revert with 0, 50
                _4684 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
                if idx >= mem[mem[128]]:
                    revert with 0, 50
                if idx >= mem[mem[_2322 + 128]]:
                    revert with 0, 50
                if not cd[36]:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
                else:
                    if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                    else:
                        mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
                if idx >= mem[mem[_2322 + 64]]:
                    revert with 0, 50
                mem[(32 * idx) + mem[_2322 + 64] + 32] = _4684
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _4682 = mem[64]
            mem[mem[64]] = 32
            mem[mem[64] + 32] = mem[_2322 + 12 len 20]
            _4767 = mem[_2322 + 32]
            mem[mem[64] + 64] = 160
            _4850 = mem[_4767]
            mem[mem[64] + 192] = mem[_4767]
            mem[mem[64] + 224 len 32 * _4850] = mem[_4767 + 32 len 32 * _4850]
            var64001 = _4850
            _5330 = mem[_2322 + 64]
            mem[mem[64] + 96] = (32 * _4850) + 192
            _5346 = mem[_5330]
            mem[mem[64] + (32 * _4850) + 224] = mem[_5330]
            mem[mem[64] + (32 * _4850) + 256 len 32 * _5346] = mem[_5330 + 32 len 32 * _5346]
            idx = _5346
            _5506 = mem[_2322 + 96]
            mem[mem[64] + 128] = (32 * _4850) + (32 * _5346) + 224
            _5522 = mem[_5506]
            mem[mem[64] + (32 * _4850) + (32 * _5346) + 256] = mem[_5506]
            idx = 0
            s = _5506 + 32
            t = mem[64] + (32 * _4850) + (32 * _5346) + 288
            while idx < _5522:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            _5634 = mem[_2322 + 128]
            mem[_4682 + 160] = (32 * _4850) + (32 * _5346) + (32 * _5522) + 256
            _5650 = mem[_5634]
            mem[_4682 + (32 * _4850) + (32 * _5346) + (32 * _5522) + 288] = mem[_5634]
            idx = 0
            s = _5634 + 32
            t = _4682 + (32 * _4850) + (32 * _5346) + (32 * _5522) + 320
            while idx < _5650:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            return memory
              from mem[64]
               len _4682 + (32 * _4850) + (32 * _5346) + (32 * _5522) + (32 * _5650) + -mem[64] + 320
        mem[_2327 + (64 * _2324) + (32 * _2326) + 128 len 32 * _2326] = call.data[calldata.size len 32 * _2326]
        mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
        idx = 0
        while idx < _2324:
            if idx >= mem[mem[96]]:
                revert with 0, 50
            _3537 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
            if idx >= mem[mem[96]]:
                revert with 0, 50
            if idx >= mem[mem[_2322 + 96]]:
                revert with 0, 50
            if not cd[36]:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
            else:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
            if idx >= mem[mem[_2322 + 32]]:
                revert with 0, 50
            mem[(32 * idx) + mem[_2322 + 32] + 32] = _3537
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        idx = 0
        while idx < _2326:
            if idx >= mem[mem[128]]:
                revert with 0, 50
            _4687 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[mem[_2322 + 128]]:
                revert with 0, 50
            if not cd[36]:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
            else:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
            if idx >= mem[mem[_2322 + 64]]:
                revert with 0, 50
            mem[(32 * idx) + mem[_2322 + 64] + 32] = _4687
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _4685 = mem[64]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[_2322 + 12 len 20]
        _4773 = mem[_2322 + 32]
        mem[mem[64] + 64] = 160
        _4855 = mem[_4773]
        mem[mem[64] + 192] = mem[_4773]
        mem[mem[64] + 224 len 32 * _4855] = mem[_4773 + 32 len 32 * _4855]
        var65001 = _4855
        _5331 = mem[_2322 + 64]
        mem[mem[64] + 96] = (32 * _4855) + 192
        _5347 = mem[_5331]
        mem[mem[64] + (32 * _4855) + 224] = mem[_5331]
        mem[mem[64] + (32 * _4855) + 256 len 32 * _5347] = mem[_5331 + 32 len 32 * _5347]
        idx = _5347
        _5507 = mem[_2322 + 96]
        mem[mem[64] + 128] = (32 * _4855) + (32 * _5347) + 224
        _5523 = mem[_5507]
        mem[mem[64] + (32 * _4855) + (32 * _5347) + 256] = mem[_5507]
        idx = 0
        s = _5507 + 32
        t = mem[64] + (32 * _4855) + (32 * _5347) + 288
        while idx < _5523:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        _5635 = mem[_2322 + 128]
        mem[_4685 + 160] = (32 * _4855) + (32 * _5347) + (32 * _5523) + 256
        _5651 = mem[_5635]
        mem[_4685 + (32 * _4855) + (32 * _5347) + (32 * _5523) + 288] = mem[_5635]
        idx = 0
        s = _5635 + 32
        t = _4685 + (32 * _4855) + (32 * _5347) + (32 * _5523) + 320
        while idx < _5651:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from mem[64]
           len _4685 + (32 * _4855) + (32 * _5347) + (32 * _5523) + (32 * _5651) + -mem[64] + 320
    mem[_2327 + (32 * _2324) + (32 * _2326) + 96 len 32 * _2324] = call.data[calldata.size len 32 * _2324]
    mem[_2322 + 96] = _2327 + (32 * _2324) + (32 * _2326) + 64
    if _2326 > test266151307():
        revert with 0, 65
    mem[_2327 + (64 * _2324) + (32 * _2326) + 96] = _2326
    mem[64] = _2327 + (64 * _2324) + (64 * _2326) + 128
    if not _2326:
        mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
        idx = 0
        while idx < _2324:
            if idx >= mem[mem[96]]:
                revert with 0, 50
            _3539 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
            if idx >= mem[mem[96]]:
                revert with 0, 50
            if idx >= mem[mem[_2322 + 96]]:
                revert with 0, 50
            if not cd[36]:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
            else:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
            if idx >= mem[mem[_2322 + 32]]:
                revert with 0, 50
            mem[(32 * idx) + mem[_2322 + 32] + 32] = _3539
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        idx = 0
        while idx < _2326:
            if idx >= mem[mem[128]]:
                revert with 0, 50
            _4690 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[mem[_2322 + 128]]:
                revert with 0, 50
            if not cd[36]:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
            else:
                if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
                else:
                    mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
            if idx >= mem[mem[_2322 + 64]]:
                revert with 0, 50
            mem[(32 * idx) + mem[_2322 + 64] + 32] = _4690
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _4688 = mem[64]
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[_2322 + 12 len 20]
        _4779 = mem[_2322 + 32]
        mem[mem[64] + 64] = 160
        _4860 = mem[_4779]
        mem[mem[64] + 192] = mem[_4779]
        mem[mem[64] + 224 len 32 * _4860] = mem[_4779 + 32 len 32 * _4860]
        var65001 = _4860
        _5332 = mem[_2322 + 64]
        mem[mem[64] + 96] = (32 * _4860) + 192
        _5348 = mem[_5332]
        mem[mem[64] + (32 * _4860) + 224] = mem[_5332]
        mem[mem[64] + (32 * _4860) + 256 len 32 * _5348] = mem[_5332 + 32 len 32 * _5348]
        idx = _5348
        _5508 = mem[_2322 + 96]
        mem[mem[64] + 128] = (32 * _4860) + (32 * _5348) + 224
        _5524 = mem[_5508]
        mem[mem[64] + (32 * _4860) + (32 * _5348) + 256] = mem[_5508]
        idx = 0
        s = _5508 + 32
        t = mem[64] + (32 * _4860) + (32 * _5348) + 288
        while idx < _5524:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        _5636 = mem[_2322 + 128]
        mem[_4688 + 160] = (32 * _4860) + (32 * _5348) + (32 * _5524) + 256
        _5652 = mem[_5636]
        mem[_4688 + (32 * _4860) + (32 * _5348) + (32 * _5524) + 288] = mem[_5636]
        idx = 0
        s = _5636 + 32
        t = _4688 + (32 * _4860) + (32 * _5348) + (32 * _5524) + 320
        while idx < _5652:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from mem[64]
           len _4688 + (32 * _4860) + (32 * _5348) + (32 * _5524) + (32 * _5652) + -mem[64] + 320
    mem[_2327 + (64 * _2324) + (32 * _2326) + 128 len 32 * _2326] = call.data[calldata.size len 32 * _2326]
    mem[_2322 + 128] = _2327 + (64 * _2324) + (32 * _2326) + 96
    idx = 0
    while idx < _2324:
        if idx >= mem[mem[96]]:
            revert with 0, 50
        _3541 = mem[mem[(32 * idx) + mem[96] + 32] + 64]
        if idx >= mem[mem[96]]:
            revert with 0, 50
        if idx >= mem[mem[_2322 + 96]]:
            revert with 0, 50
        if not cd[36]:
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]:
                mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
            else:
                mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 12 len 20]
        else:
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]:
                mem[(32 * idx) + mem[_2322 + 96] + 32] = sub_b729cbebAddress
            else:
                mem[(32 * idx) + mem[_2322 + 96] + 32] = mem[mem[(32 * idx) + mem[96] + 32] + 44 len 20]
        if idx >= mem[mem[_2322 + 32]]:
            revert with 0, 50
        mem[(32 * idx) + mem[_2322 + 32] + 32] = _3541
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    idx = 0
    while idx < _2326:
        if idx >= mem[mem[128]]:
            revert with 0, 50
        _4693 = mem[mem[(32 * idx) + mem[128] + 32] + 64]
        if idx >= mem[mem[128]]:
            revert with 0, 50
        if idx >= mem[mem[_2322 + 128]]:
            revert with 0, 50
        if not cd[36]:
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]:
                mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
            else:
                mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 12 len 20]
        else:
            if 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee == mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]:
                mem[(32 * idx) + mem[_2322 + 128] + 32] = sub_b729cbebAddress
            else:
                mem[(32 * idx) + mem[_2322 + 128] + 32] = mem[mem[(32 * idx) + mem[128] + 32] + 44 len 20]
        if idx >= mem[mem[_2322 + 64]]:
            revert with 0, 50
        mem[(32 * idx) + mem[_2322 + 64] + 32] = _4693
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    _4691 = mem[64]
    mem[mem[64]] = 32
    mem[mem[64] + 32] = mem[_2322 + 12 len 20]
    _4785 = mem[_2322 + 32]
    mem[mem[64] + 64] = 160
    _4865 = mem[_4785]
    mem[mem[64] + 192] = mem[_4785]
    mem[mem[64] + 224 len 32 * _4865] = mem[_4785 + 32 len 32 * _4865]
    var66001 = _4865
    _5333 = mem[_2322 + 64]
    mem[mem[64] + 96] = (32 * _4865) + 192
    _5349 = mem[_5333]
    mem[mem[64] + (32 * _4865) + 224] = mem[_5333]
    mem[mem[64] + (32 * _4865) + 256 len 32 * _5349] = mem[_5333 + 32 len 32 * _5349]
    idx = _5349
    _5509 = mem[_2322 + 96]
    mem[mem[64] + 128] = (32 * _4865) + (32 * _5349) + 224
    _5525 = mem[_5509]
    mem[mem[64] + (32 * _4865) + (32 * _5349) + 256] = mem[_5509]
    idx = 0
    s = _5509 + 32
    t = mem[64] + (32 * _4865) + (32 * _5349) + 288
    while idx < _5525:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    _5637 = mem[_2322 + 128]
    mem[_4691 + 160] = (32 * _4865) + (32 * _5349) + (32 * _5525) + 256
    _5653 = mem[_5637]
    mem[_4691 + (32 * _4865) + (32 * _5349) + (32 * _5525) + 288] = mem[_5637]
    idx = 0
    s = _5637 + 32
    t = _4691 + (32 * _4865) + (32 * _5349) + (32 * _5525) + 320
    while idx < _5653:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len _4691 + (32 * _4865) + (32 * _5349) + (32 * _5525) + (32 * _5653) + -mem[64] + 320
}

function sub_d3cbd8b3(?) payable {
    require calldata.size - 4 >= 64
    require cd[4] == address(cd[4])
    require cd[36] <= test266151307()
    require calldata.size + -cd[36] - 4 >= 160
    require ('cd', 36).length == address(('cd', 36).length)
    mem[96] = ('cd', 36).length
    require ('cd', 36)[0] <= test266151307()
    require cd[36] + ('cd', 36)[0] + 35 < calldata.size
    if cd[(cd[36] + ('cd', 36)[0] + 4)] > test266151307():
        revert with 0, 65
    if ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + 257 < 256 or ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + 257 > test266151307():
        revert with 0, 65
    mem[256] = cd[(cd[36] + ('cd', 36)[0] + 4)]
    require cd[36] + ('cd', 36)[0] + (32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + 36 <= calldata.size
    idx = 0
    s = cd[36] + ('cd', 36)[0] + 36
    t = 288
    while idx < cd[(cd[36] + ('cd', 36)[0] + 4)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[128] = 256
    require ('cd', 36)[1] <= test266151307()
    require cd[36] + ('cd', 36)[1] + 35 < calldata.size
    if cd[(cd[36] + ('cd', 36)[1] + 4)] > test266151307():
        revert with 0, 65
    if ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258 < 257 or ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + 257] = cd[(cd[36] + ('cd', 36)[1] + 4)]
    require cd[36] + ('cd', 36)[1] + (32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 36 <= calldata.size
    idx = 0
    s = cd[36] + ('cd', 36)[1] + 36
    t = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + 289
    while idx < cd[(cd[36] + ('cd', 36)[1] + 4)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[160] = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + 257
    require ('cd', 36)[2] <= test266151307()
    require cd[36] + ('cd', 36)[2] + 35 < calldata.size
    if cd[(cd[36] + ('cd', 36)[2] + 4)] > test266151307():
        revert with 0, 65
    if ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259 < 258 or ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258] = cd[(cd[36] + ('cd', 36)[2] + 4)]
    require cd[36] + ('cd', 36)[2] + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 36 <= calldata.size
    idx = 0
    s = cd[36] + ('cd', 36)[2] + 36
    t = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290
    while idx < cd[(cd[36] + ('cd', 36)[2] + 4)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[192] = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258
    require ('cd', 36)[3] <= test266151307()
    require cd[36] + ('cd', 36)[3] + 35 < calldata.size
    if cd[(cd[36] + ('cd', 36)[3] + 4)] > test266151307():
        revert with 0, 65
    if ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 260 < 259 or ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 260 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259] = cd[(cd[36] + ('cd', 36)[3] + 4)]
    require cd[36] + ('cd', 36)[3] + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 36 <= calldata.size
    idx = 0
    s = cd[36] + ('cd', 36)[3] + 36
    t = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291
    while idx < cd[(cd[36] + ('cd', 36)[3] + 4)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[224] = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259
    require ext_code.size(sub_238f9b7aAddress)
    staticcall sub_238f9b7aAddress.getPriceOracle() with:
            gas gas_remaining wei
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 260] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260] = 0x9d23d9f200000000000000000000000000000000000000000000000000000000
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 264] = 32
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 296] = cd[(cd[36] + ('cd', 36)[3] + 4)]
    idx = 0
    s = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291
    t = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 328
    while idx < cd[(cd[36] + ('cd', 36)[3] + 4)]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getAssetsPrices(address[] rg1) with:
            gas gas_remaining wei
           args Array(len=cd[(cd[36] + ('cd', 36)[3] + 4)], data=mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 328 len 32 * cd[(cd[36] + ('cd', 36)[3] + 4)]])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260
    require return_data.size >= 32
    _1045 = mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0
    require mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0 <= test266151307()
    require ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + return_data.size + 260 > ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0 + 291
    _1046 = mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0 + 260]
    if mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0 + 260] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0 + 260]) + 1 < 0 or ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0 + 260]) + 261 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0 + 260]) + 261
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260] = _1046
    require _1045 + (32 * _1046) + 32 <= return_data.size
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292 len 32 * _1046] = mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + _1045 + 292 len 32 * _1046]
    if cd[(cd[36] + ('cd', 36)[3] + 4)] > test266151307():
        revert with 0, 65
    _1244 = mem[64]
    mem[mem[64]] = cd[(cd[36] + ('cd', 36)[3] + 4)]
    mem[64] = mem[64] + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 32
    if not cd[(cd[36] + ('cd', 36)[3] + 4)]:
        idx = 0
        while idx < cd[(cd[36] + ('cd', 36)[3] + 4)]:
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1447 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1453 = mem[_1447]
            _1454 = mem[_1447 + 32]
            _1455 = mem[_1447 + 64]
            _1458 = mem[_1447 + 160]
            require mem[_1447 + 160] == bool(mem[_1447 + 160])
            _1476 = mem[_1447 + 192]
            require mem[_1447 + 192] == bool(mem[_1447 + 192])
            require mem[_1447 + 224] == bool(mem[_1447 + 224])
            _1498 = mem[_1447 + 256]
            require mem[_1447 + 256] == bool(mem[_1447 + 256])
            require mem[_1447 + 288] == bool(mem[_1447 + 288])
            if idx >= mem[_1244]:
                revert with 0, 50
            _1518 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _1524 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _1527 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _1531 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _1538 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _1546 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 192] = bool(mem[_1447 + 288])
            mem[_1546 + 160] = bool(_1498)
            mem[_1538 + 128] = bool(_1476)
            mem[_1531 + 96] = bool(_1458)
            mem[_1527 + 64] = _1455
            mem[_1524 + 32] = _1454
            mem[_1518] = _1453
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1565 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1571 = mem[_1565 + 32]
            _1572 = mem[_1565 + 64]
            require mem[_1565 + 288] == mem[_1565 + 315 len 5]
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 224] = mem[_1565]
            if _1571 > !_1572:
                revert with 0, 17
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 256] = _1571 + _1572
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _1625 = mem[mem[224]]
        idx = 0
        s = 1
        t = 0
        while idx < _1625:
            if idx >= mem[mem[224]]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + mem[224] + 44 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1635 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_1635 + 224] == mem[_1635 + 251 len 5]
            require mem[_1635 + 256] == bool(mem[_1635 + 256])
            if mem[_1635 + 32] > !mem[_1635 + 64]:
                revert with 0, 17
            if idx >= mem[mem[160]]:
                revert with 0, 50
            if idx >= mem[mem[160]]:
                revert with 0, 50
            if idx >= mem[_1244]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1244 + 32]]:
                revert with 0, 17
            if mem[_1635 + 32] + mem[_1635 + 64] >= mem[(32 * idx) + mem[160] + 32]:
                if not -mem[mem[(32 * idx) + _1244 + 32]] + 18:
                    if mem[(32 * idx) + mem[160] + 32] and 1 > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[160] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _1625 = mem[mem[224]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 32)):
                    if mem[(32 * idx) + mem[160] + 32] and 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18):
                        revert with 0, 17
                    if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _1625 = mem[mem[224]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                v = 10
                w = 1
                u = -mem[mem[(32 * idx) + _1244 + 32]] + 18
                while u > 1:
                    if v > -1 / v:
                        revert with 0, 17
                    _1625 = mem[mem[224]]
                    if not bool(u):
                        v = v * v
                        w = w
                        u = uint255(u) * 0.5
                        continue 
                    v = v * v
                    w = v * w
                    u = uint255(u) * 0.5
                    continue 
                if w > -1 / v:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] and v * w > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] * v * w and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * v * w:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _1625 = mem[mem[224]]
                idx = idx + 1
                s = s
                t = t + ((mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if not -mem[mem[(32 * idx) + _1244 + 32]] + 18:
                if mem[(32 * idx) + mem[160] + 32] and 1 > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _1625 = mem[mem[224]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 32)):
                if mem[(32 * idx) + mem[160] + 32] and 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18):
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _1625 = mem[mem[224]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            u = 10
            v = 1
            s = -mem[mem[(32 * idx) + _1244 + 32]] + 18
            while s > 1:
                if u > -1 / u:
                    revert with 0, 17
                _1625 = mem[mem[224]]
                if not bool(s):
                    u = u * u
                    v = v
                    s = uint255(s) * 0.5
                    continue 
                u = u * u
                v = u * v
                s = uint255(s) * 0.5
                continue 
            if v > -1 / u:
                revert with 0, 17
            if mem[(32 * idx) + mem[160] + 32] and u * v > -1 / mem[(32 * idx) + mem[160] + 32]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                revert with 0, 50
            if mem[(32 * idx) + mem[160] + 32] * u * v and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * u * v:
                revert with 0, 17
            if mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                revert with 0, 17
            if t > !((mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _1625 = mem[mem[224]]
            idx = idx + 1
            s = 0
            t = t + ((mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
            continue 
        return t, bool(s)
    mem[64] = _1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 320
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 32] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 64] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 96] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 128] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 160] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 192] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 224] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 256] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 288] = 0
    mem[var116002] = var116001
    if not var116003 - 1:
        idx = 0
        while idx < cd[(cd[36] + ('cd', 36)[3] + 4)]:
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1873 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1881 = mem[_1873]
            _1882 = mem[_1873 + 32]
            _1883 = mem[_1873 + 64]
            _1886 = mem[_1873 + 160]
            require mem[_1873 + 160] == bool(mem[_1873 + 160])
            _1907 = mem[_1873 + 192]
            require mem[_1873 + 192] == bool(mem[_1873 + 192])
            require mem[_1873 + 224] == bool(mem[_1873 + 224])
            _1927 = mem[_1873 + 256]
            require mem[_1873 + 256] == bool(mem[_1873 + 256])
            require mem[_1873 + 288] == bool(mem[_1873 + 288])
            if idx >= mem[_1244]:
                revert with 0, 50
            _1949 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _1954 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _1958 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _1965 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _1973 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _1979 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 192] = bool(mem[_1873 + 288])
            mem[_1979 + 160] = bool(_1927)
            mem[_1973 + 128] = bool(_1907)
            mem[_1965 + 96] = bool(_1886)
            mem[_1958 + 64] = _1883
            mem[_1954 + 32] = _1882
            mem[_1949] = _1881
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1996 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2001 = mem[_1996 + 32]
            _2002 = mem[_1996 + 64]
            require mem[_1996 + 288] == mem[_1996 + 315 len 5]
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 224] = mem[_1996]
            if _2001 > !_2002:
                revert with 0, 17
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 256] = _2001 + _2002
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _2054 = mem[mem[224]]
        idx = 0
        s = 1
        t = 0
        while idx < _2054:
            if idx >= mem[mem[224]]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + mem[224] + 44 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2066 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_2066 + 224] == mem[_2066 + 251 len 5]
            require mem[_2066 + 256] == bool(mem[_2066 + 256])
            if mem[_2066 + 32] > !mem[_2066 + 64]:
                revert with 0, 17
            if idx >= mem[mem[160]]:
                revert with 0, 50
            if idx >= mem[mem[160]]:
                revert with 0, 50
            if idx >= mem[_1244]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1244 + 32]]:
                revert with 0, 17
            if mem[_2066 + 32] + mem[_2066 + 64] >= mem[(32 * idx) + mem[160] + 32]:
                if not -mem[mem[(32 * idx) + _1244 + 32]] + 18:
                    if mem[(32 * idx) + mem[160] + 32] and 1 > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[160] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2054 = mem[mem[224]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 32)):
                    if mem[(32 * idx) + mem[160] + 32] and 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18):
                        revert with 0, 17
                    if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2054 = mem[mem[224]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                v = 10
                w = 1
                u = -mem[mem[(32 * idx) + _1244 + 32]] + 18
                while u > 1:
                    if v > -1 / v:
                        revert with 0, 17
                    _2054 = mem[mem[224]]
                    if not bool(u):
                        v = v * v
                        w = w
                        u = uint255(u) * 0.5
                        continue 
                    v = v * v
                    w = v * w
                    u = uint255(u) * 0.5
                    continue 
                if w > -1 / v:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] and v * w > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] * v * w and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * v * w:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2054 = mem[mem[224]]
                idx = idx + 1
                s = s
                t = t + ((mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if not -mem[mem[(32 * idx) + _1244 + 32]] + 18:
                if mem[(32 * idx) + mem[160] + 32] and 1 > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2054 = mem[mem[224]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 32)):
                if mem[(32 * idx) + mem[160] + 32] and 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18):
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2054 = mem[mem[224]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            u = 10
            v = 1
            s = -mem[mem[(32 * idx) + _1244 + 32]] + 18
            while s > 1:
                if u > -1 / u:
                    revert with 0, 17
                _2054 = mem[mem[224]]
                if not bool(s):
                    u = u * u
                    v = v
                    s = uint255(s) * 0.5
                    continue 
                u = u * u
                v = u * v
                s = uint255(s) * 0.5
                continue 
            if v > -1 / u:
                revert with 0, 17
            if mem[(32 * idx) + mem[160] + 32] and u * v > -1 / mem[(32 * idx) + mem[160] + 32]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                revert with 0, 50
            if mem[(32 * idx) + mem[160] + 32] * u * v and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * u * v:
                revert with 0, 17
            if mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                revert with 0, 17
            if t > !((mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _2054 = mem[mem[224]]
            idx = idx + 1
            s = 0
            t = t + ((mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
            continue 
        return t, bool(s)
    mem[64] = _1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 608
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 320] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 352] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 384] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 416] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 448] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 480] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 512] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 544] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 576] = 0
    mem[var120002] = var120001
    if not var120003 - 1:
        idx = 0
        while idx < cd[(cd[36] + ('cd', 36)[3] + 4)]:
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2302 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2310 = mem[_2302]
            _2311 = mem[_2302 + 32]
            _2312 = mem[_2302 + 64]
            _2315 = mem[_2302 + 160]
            require mem[_2302 + 160] == bool(mem[_2302 + 160])
            _2334 = mem[_2302 + 192]
            require mem[_2302 + 192] == bool(mem[_2302 + 192])
            require mem[_2302 + 224] == bool(mem[_2302 + 224])
            _2356 = mem[_2302 + 256]
            require mem[_2302 + 256] == bool(mem[_2302 + 256])
            require mem[_2302 + 288] == bool(mem[_2302 + 288])
            if idx >= mem[_1244]:
                revert with 0, 50
            _2378 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _2383 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _2387 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _2394 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _2402 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _2408 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 192] = bool(mem[_2302 + 288])
            mem[_2408 + 160] = bool(_2356)
            mem[_2402 + 128] = bool(_2334)
            mem[_2394 + 96] = bool(_2315)
            mem[_2387 + 64] = _2312
            mem[_2383 + 32] = _2311
            mem[_2378] = _2310
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2425 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2430 = mem[_2425 + 32]
            _2431 = mem[_2425 + 64]
            require mem[_2425 + 288] == mem[_2425 + 315 len 5]
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 224] = mem[_2425]
            if _2430 > !_2431:
                revert with 0, 17
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 256] = _2430 + _2431
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _2483 = mem[mem[224]]
        idx = 0
        s = 1
        t = 0
        while idx < _2483:
            if idx >= mem[mem[224]]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + mem[224] + 44 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2495 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_2495 + 224] == mem[_2495 + 251 len 5]
            require mem[_2495 + 256] == bool(mem[_2495 + 256])
            if mem[_2495 + 32] > !mem[_2495 + 64]:
                revert with 0, 17
            if idx >= mem[mem[160]]:
                revert with 0, 50
            if idx >= mem[mem[160]]:
                revert with 0, 50
            if idx >= mem[_1244]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1244 + 32]]:
                revert with 0, 17
            if mem[_2495 + 32] + mem[_2495 + 64] >= mem[(32 * idx) + mem[160] + 32]:
                if not -mem[mem[(32 * idx) + _1244 + 32]] + 18:
                    if mem[(32 * idx) + mem[160] + 32] and 1 > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[160] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2483 = mem[mem[224]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 32)):
                    if mem[(32 * idx) + mem[160] + 32] and 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18):
                        revert with 0, 17
                    if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2483 = mem[mem[224]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                v = 10
                w = 1
                u = -mem[mem[(32 * idx) + _1244 + 32]] + 18
                while u > 1:
                    if v > -1 / v:
                        revert with 0, 17
                    _2483 = mem[mem[224]]
                    if not bool(u):
                        v = v * v
                        w = w
                        u = uint255(u) * 0.5
                        continue 
                    v = v * v
                    w = v * w
                    u = uint255(u) * 0.5
                    continue 
                if w > -1 / v:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] and v * w > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] * v * w and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * v * w:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2483 = mem[mem[224]]
                idx = idx + 1
                s = s
                t = t + ((mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if not -mem[mem[(32 * idx) + _1244 + 32]] + 18:
                if mem[(32 * idx) + mem[160] + 32] and 1 > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2483 = mem[mem[224]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 32)):
                if mem[(32 * idx) + mem[160] + 32] and 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18):
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2483 = mem[mem[224]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            u = 10
            v = 1
            s = -mem[mem[(32 * idx) + _1244 + 32]] + 18
            while s > 1:
                if u > -1 / u:
                    revert with 0, 17
                _2483 = mem[mem[224]]
                if not bool(s):
                    u = u * u
                    v = v
                    s = uint255(s) * 0.5
                    continue 
                u = u * u
                v = u * v
                s = uint255(s) * 0.5
                continue 
            if v > -1 / u:
                revert with 0, 17
            if mem[(32 * idx) + mem[160] + 32] and u * v > -1 / mem[(32 * idx) + mem[160] + 32]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                revert with 0, 50
            if mem[(32 * idx) + mem[160] + 32] * u * v and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * u * v:
                revert with 0, 17
            if mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                revert with 0, 17
            if t > !((mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _2483 = mem[mem[224]]
            idx = idx + 1
            s = 0
            t = t + ((mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
            continue 
        return t, bool(s)
    mem[64] = _1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 896
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 608] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 640] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 672] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 704] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 736] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 768] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 800] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 832] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 864] = 0
    mem[var124002] = var124001
    if not var124003 - 1:
        idx = 0
        while idx < cd[(cd[36] + ('cd', 36)[3] + 4)]:
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2731 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2739 = mem[_2731]
            _2740 = mem[_2731 + 32]
            _2741 = mem[_2731 + 64]
            _2744 = mem[_2731 + 160]
            require mem[_2731 + 160] == bool(mem[_2731 + 160])
            _2763 = mem[_2731 + 192]
            require mem[_2731 + 192] == bool(mem[_2731 + 192])
            require mem[_2731 + 224] == bool(mem[_2731 + 224])
            _2785 = mem[_2731 + 256]
            require mem[_2731 + 256] == bool(mem[_2731 + 256])
            require mem[_2731 + 288] == bool(mem[_2731 + 288])
            if idx >= mem[_1244]:
                revert with 0, 50
            _2807 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _2812 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _2816 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _2823 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _2831 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _2837 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 192] = bool(mem[_2731 + 288])
            mem[_2837 + 160] = bool(_2785)
            mem[_2831 + 128] = bool(_2763)
            mem[_2823 + 96] = bool(_2744)
            mem[_2816 + 64] = _2741
            mem[_2812 + 32] = _2740
            mem[_2807] = _2739
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2854 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2859 = mem[_2854 + 32]
            _2860 = mem[_2854 + 64]
            require mem[_2854 + 288] == mem[_2854 + 315 len 5]
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 224] = mem[_2854]
            if _2859 > !_2860:
                revert with 0, 17
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 256] = _2859 + _2860
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _2912 = mem[mem[224]]
        idx = 0
        s = 1
        t = 0
        while idx < _2912:
            if idx >= mem[mem[224]]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + mem[224] + 44 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2924 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_2924 + 224] == mem[_2924 + 251 len 5]
            require mem[_2924 + 256] == bool(mem[_2924 + 256])
            if mem[_2924 + 32] > !mem[_2924 + 64]:
                revert with 0, 17
            if idx >= mem[mem[160]]:
                revert with 0, 50
            if idx >= mem[mem[160]]:
                revert with 0, 50
            if idx >= mem[_1244]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1244 + 32]]:
                revert with 0, 17
            if mem[_2924 + 32] + mem[_2924 + 64] >= mem[(32 * idx) + mem[160] + 32]:
                if not -mem[mem[(32 * idx) + _1244 + 32]] + 18:
                    if mem[(32 * idx) + mem[160] + 32] and 1 > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[160] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2912 = mem[mem[224]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 32)):
                    if mem[(32 * idx) + mem[160] + 32] and 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18):
                        revert with 0, 17
                    if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2912 = mem[mem[224]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                v = 10
                w = 1
                u = -mem[mem[(32 * idx) + _1244 + 32]] + 18
                while u > 1:
                    if v > -1 / v:
                        revert with 0, 17
                    _2912 = mem[mem[224]]
                    if not bool(u):
                        v = v * v
                        w = w
                        u = uint255(u) * 0.5
                        continue 
                    v = v * v
                    w = v * w
                    u = uint255(u) * 0.5
                    continue 
                if w > -1 / v:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] and v * w > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] * v * w and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * v * w:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2912 = mem[mem[224]]
                idx = idx + 1
                s = s
                t = t + ((mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if not -mem[mem[(32 * idx) + _1244 + 32]] + 18:
                if mem[(32 * idx) + mem[160] + 32] and 1 > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2912 = mem[mem[224]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 32)):
                if mem[(32 * idx) + mem[160] + 32] and 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18):
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2912 = mem[mem[224]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            u = 10
            v = 1
            s = -mem[mem[(32 * idx) + _1244 + 32]] + 18
            while s > 1:
                if u > -1 / u:
                    revert with 0, 17
                _2912 = mem[mem[224]]
                if not bool(s):
                    u = u * u
                    v = v
                    s = uint255(s) * 0.5
                    continue 
                u = u * u
                v = u * v
                s = uint255(s) * 0.5
                continue 
            if v > -1 / u:
                revert with 0, 17
            if mem[(32 * idx) + mem[160] + 32] and u * v > -1 / mem[(32 * idx) + mem[160] + 32]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                revert with 0, 50
            if mem[(32 * idx) + mem[160] + 32] * u * v and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * u * v:
                revert with 0, 17
            if mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                revert with 0, 17
            if t > !((mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _2912 = mem[mem[224]]
            idx = idx + 1
            s = 0
            t = t + ((mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
            continue 
        return t, bool(s)
    mem[64] = _1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1184
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 896] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 928] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 960] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 992] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1024] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1056] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1088] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1120] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1152] = 0
    mem[var128002] = var128001
    if not var128003 - 1:
        idx = 0
        while idx < cd[(cd[36] + ('cd', 36)[3] + 4)]:
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3160 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _3168 = mem[_3160]
            _3169 = mem[_3160 + 32]
            _3170 = mem[_3160 + 64]
            _3173 = mem[_3160 + 160]
            require mem[_3160 + 160] == bool(mem[_3160 + 160])
            _3192 = mem[_3160 + 192]
            require mem[_3160 + 192] == bool(mem[_3160 + 192])
            require mem[_3160 + 224] == bool(mem[_3160 + 224])
            _3214 = mem[_3160 + 256]
            require mem[_3160 + 256] == bool(mem[_3160 + 256])
            require mem[_3160 + 288] == bool(mem[_3160 + 288])
            if idx >= mem[_1244]:
                revert with 0, 50
            _3236 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _3241 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _3245 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _3252 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _3260 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _3266 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 192] = bool(mem[_3160 + 288])
            mem[_3266 + 160] = bool(_3214)
            mem[_3260 + 128] = bool(_3192)
            mem[_3252 + 96] = bool(_3173)
            mem[_3245 + 64] = _3170
            mem[_3241 + 32] = _3169
            mem[_3236] = _3168
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3283 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _3288 = mem[_3283 + 32]
            _3289 = mem[_3283 + 64]
            require mem[_3283 + 288] == mem[_3283 + 315 len 5]
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 224] = mem[_3283]
            if _3288 > !_3289:
                revert with 0, 17
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 256] = _3288 + _3289
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _3341 = mem[mem[224]]
        idx = 0
        s = 1
        t = 0
        while idx < _3341:
            if idx >= mem[mem[224]]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + mem[224] + 44 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3353 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_3353 + 224] == mem[_3353 + 251 len 5]
            require mem[_3353 + 256] == bool(mem[_3353 + 256])
            if mem[_3353 + 32] > !mem[_3353 + 64]:
                revert with 0, 17
            if idx >= mem[mem[160]]:
                revert with 0, 50
            if idx >= mem[mem[160]]:
                revert with 0, 50
            if idx >= mem[_1244]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1244 + 32]]:
                revert with 0, 17
            if mem[_3353 + 32] + mem[_3353 + 64] >= mem[(32 * idx) + mem[160] + 32]:
                if not -mem[mem[(32 * idx) + _1244 + 32]] + 18:
                    if mem[(32 * idx) + mem[160] + 32] and 1 > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[160] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3341 = mem[mem[224]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 32)):
                    if mem[(32 * idx) + mem[160] + 32] and 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18):
                        revert with 0, 17
                    if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3341 = mem[mem[224]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                v = 10
                w = 1
                u = -mem[mem[(32 * idx) + _1244 + 32]] + 18
                while u > 1:
                    if v > -1 / v:
                        revert with 0, 17
                    _3341 = mem[mem[224]]
                    if not bool(u):
                        v = v * v
                        w = w
                        u = uint255(u) * 0.5
                        continue 
                    v = v * v
                    w = v * w
                    u = uint255(u) * 0.5
                    continue 
                if w > -1 / v:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] and v * w > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] * v * w and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * v * w:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3341 = mem[mem[224]]
                idx = idx + 1
                s = s
                t = t + ((mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if not -mem[mem[(32 * idx) + _1244 + 32]] + 18:
                if mem[(32 * idx) + mem[160] + 32] and 1 > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3341 = mem[mem[224]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 32)):
                if mem[(32 * idx) + mem[160] + 32] and 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18):
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3341 = mem[mem[224]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            u = 10
            v = 1
            s = -mem[mem[(32 * idx) + _1244 + 32]] + 18
            while s > 1:
                if u > -1 / u:
                    revert with 0, 17
                _3341 = mem[mem[224]]
                if not bool(s):
                    u = u * u
                    v = v
                    s = uint255(s) * 0.5
                    continue 
                u = u * u
                v = u * v
                s = uint255(s) * 0.5
                continue 
            if v > -1 / u:
                revert with 0, 17
            if mem[(32 * idx) + mem[160] + 32] and u * v > -1 / mem[(32 * idx) + mem[160] + 32]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                revert with 0, 50
            if mem[(32 * idx) + mem[160] + 32] * u * v and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * u * v:
                revert with 0, 17
            if mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                revert with 0, 17
            if t > !((mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _3341 = mem[mem[224]]
            idx = idx + 1
            s = 0
            t = t + ((mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
            continue 
        return t, bool(s)
    mem[64] = _1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1472
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1184] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1216] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1248] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1280] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1312] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1344] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1376] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1408] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1440] = 0
    mem[var132002] = var132001
    if not var132003 - 1:
        idx = 0
        while idx < cd[(cd[36] + ('cd', 36)[3] + 4)]:
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3589 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _3597 = mem[_3589]
            _3598 = mem[_3589 + 32]
            _3599 = mem[_3589 + 64]
            _3602 = mem[_3589 + 160]
            require mem[_3589 + 160] == bool(mem[_3589 + 160])
            _3621 = mem[_3589 + 192]
            require mem[_3589 + 192] == bool(mem[_3589 + 192])
            require mem[_3589 + 224] == bool(mem[_3589 + 224])
            _3643 = mem[_3589 + 256]
            require mem[_3589 + 256] == bool(mem[_3589 + 256])
            require mem[_3589 + 288] == bool(mem[_3589 + 288])
            if idx >= mem[_1244]:
                revert with 0, 50
            _3665 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _3670 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _3674 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _3681 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _3689 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _3695 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 192] = bool(mem[_3589 + 288])
            mem[_3695 + 160] = bool(_3643)
            mem[_3689 + 128] = bool(_3621)
            mem[_3681 + 96] = bool(_3602)
            mem[_3674 + 64] = _3599
            mem[_3670 + 32] = _3598
            mem[_3665] = _3597
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3712 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _3717 = mem[_3712 + 32]
            _3718 = mem[_3712 + 64]
            require mem[_3712 + 288] == mem[_3712 + 315 len 5]
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 224] = mem[_3712]
            if _3717 > !_3718:
                revert with 0, 17
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 256] = _3717 + _3718
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _3770 = mem[mem[224]]
        idx = 0
        s = 1
        t = 0
        while idx < _3770:
            if idx >= mem[mem[224]]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + mem[224] + 44 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3782 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_3782 + 224] == mem[_3782 + 251 len 5]
            require mem[_3782 + 256] == bool(mem[_3782 + 256])
            if mem[_3782 + 32] > !mem[_3782 + 64]:
                revert with 0, 17
            if idx >= mem[mem[160]]:
                revert with 0, 50
            if idx >= mem[mem[160]]:
                revert with 0, 50
            if idx >= mem[_1244]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1244 + 32]]:
                revert with 0, 17
            if mem[_3782 + 32] + mem[_3782 + 64] >= mem[(32 * idx) + mem[160] + 32]:
                if not -mem[mem[(32 * idx) + _1244 + 32]] + 18:
                    if mem[(32 * idx) + mem[160] + 32] and 1 > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[160] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3770 = mem[mem[224]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 32)):
                    if mem[(32 * idx) + mem[160] + 32] and 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) > -1 / mem[(32 * idx) + mem[160] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18):
                        revert with 0, 17
                    if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3770 = mem[mem[224]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                v = 10
                w = 1
                u = -mem[mem[(32 * idx) + _1244 + 32]] + 18
                while u > 1:
                    if v > -1 / v:
                        revert with 0, 17
                    _3770 = mem[mem[224]]
                    if not bool(u):
                        v = v * v
                        w = w
                        u = uint255(u) * 0.5
                        continue 
                    v = v * v
                    w = v * w
                    u = uint255(u) * 0.5
                    continue 
                if w > -1 / v:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] and v * w > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] * v * w and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * v * w:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3770 = mem[mem[224]]
                idx = idx + 1
                s = s
                t = t + ((mem[(32 * idx) + mem[160] + 32] * v * w * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if not -mem[mem[(32 * idx) + _1244 + 32]] + 18:
                if mem[(32 * idx) + mem[160] + 32] and 1 > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3770 = mem[mem[224]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[160] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1244 + 32]] + 18 < 32)):
                if mem[(32 * idx) + mem[160] + 32] and 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) > -1 / mem[(32 * idx) + mem[160] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18):
                    revert with 0, 17
                if mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3770 = mem[mem[224]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[160] + 32] * 10^(-mem[mem[(32 * idx) + _1244 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            u = 10
            v = 1
            s = -mem[mem[(32 * idx) + _1244 + 32]] + 18
            while s > 1:
                if u > -1 / u:
                    revert with 0, 17
                _3770 = mem[mem[224]]
                if not bool(s):
                    u = u * u
                    v = v
                    s = uint255(s) * 0.5
                    continue 
                u = u * u
                v = u * v
                s = uint255(s) * 0.5
                continue 
            if v > -1 / u:
                revert with 0, 17
            if mem[(32 * idx) + mem[160] + 32] and u * v > -1 / mem[(32 * idx) + mem[160] + 32]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                revert with 0, 50
            if mem[(32 * idx) + mem[160] + 32] * u * v and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[160] + 32] * u * v:
                revert with 0, 17
            if mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                revert with 0, 17
            if t > !((mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _3770 = mem[mem[224]]
            idx = idx + 1
            s = 0
            t = t + ((mem[(32 * idx) + mem[160] + 32] * u * v * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
            continue 
        return t, bool(s)
    mem[64] = _1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1760
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1472] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1504] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1536] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1568] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1600] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1632] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1664] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1696] = 0
    mem[_1244 + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 1728] = 0
    mem[var136002] = var136001
    if not var136003 - 1:
        idx = 0
        while idx < cd[(cd[36] + ('cd', 36)[3] + 4)]:
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4018 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _4026 = mem[_4018]
            _4027 = mem[_4018 + 32]
            _4028 = mem[_4018 + 64]
            _4031 = mem[_4018 + 160]
            require mem[_4018 + 160] == bool(mem[_4018 + 160])
            _4050 = mem[_4018 + 192]
            require mem[_4018 + 192] == bool(mem[_4018 + 192])
            require mem[_4018 + 224] == bool(mem[_4018 + 224])
            _4072 = mem[_4018 + 256]
            require mem[_4018 + 256] == bool(mem[_4018 + 256])
            require mem[_4018 + 288] == bool(mem[_4018 + 288])
            if idx >= mem[_1244]:
                revert with 0, 50
            _4094 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _4099 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _4103 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _4110 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _4118 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            _4124 = mem[(32 * idx) + _1244 + 32]
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 192] = bool(mem[_4018 + 288])
            mem[_4124 + 160] = bool(_4072)
            mem[_4118 + 128] = bool(_4050)
            mem[_4110 + 96] = bool(_4031)
            mem[_4103 + 64] = _4028
            mem[_4099 + 32] = _4027
            mem[_4094] = _4026
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4141 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _4146 = mem[_4141 + 32]
            _4147 = mem[_4141 + 64]
            require mem[_4141 + 288] == mem[_4141 + 315 len 5]
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 224] = mem[_4141]
            if _4146 > !_4147:
                revert with 0, 17
            if idx >= mem[_1244]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1244 + 32] + 256] = _4146 + _4147
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
    # nil
}

function sub_35908685(?) payable {
    require calldata.size - 4 >= 64
    require cd[4] == address(cd[4])
    require cd[36] <= test266151307()
    require calldata.size + -cd[36] - 4 >= 160
    require ('cd', 36).length == address(('cd', 36).length)
    mem[96] = ('cd', 36).length
    require ('cd', 36)[0] <= test266151307()
    require cd[36] + ('cd', 36)[0] + 35 < calldata.size
    if cd[(cd[36] + ('cd', 36)[0] + 4)] > test266151307():
        revert with 0, 65
    if ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + 257 < 256 or ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + 257 > test266151307():
        revert with 0, 65
    mem[256] = cd[(cd[36] + ('cd', 36)[0] + 4)]
    require cd[36] + ('cd', 36)[0] + (32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + 36 <= calldata.size
    idx = 0
    s = cd[36] + ('cd', 36)[0] + 36
    t = 288
    while idx < cd[(cd[36] + ('cd', 36)[0] + 4)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[128] = 256
    require ('cd', 36)[1] <= test266151307()
    require cd[36] + ('cd', 36)[1] + 35 < calldata.size
    if cd[(cd[36] + ('cd', 36)[1] + 4)] > test266151307():
        revert with 0, 65
    if ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258 < 257 or ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + 257] = cd[(cd[36] + ('cd', 36)[1] + 4)]
    require cd[36] + ('cd', 36)[1] + (32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 36 <= calldata.size
    idx = 0
    s = cd[36] + ('cd', 36)[1] + 36
    t = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + 289
    while idx < cd[(cd[36] + ('cd', 36)[1] + 4)]:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[160] = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + 257
    require ('cd', 36)[2] <= test266151307()
    require cd[36] + ('cd', 36)[2] + 35 < calldata.size
    if cd[(cd[36] + ('cd', 36)[2] + 4)] > test266151307():
        revert with 0, 65
    if ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259 < 258 or ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258] = cd[(cd[36] + ('cd', 36)[2] + 4)]
    require cd[36] + ('cd', 36)[2] + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 36 <= calldata.size
    idx = 0
    s = cd[36] + ('cd', 36)[2] + 36
    t = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290
    while idx < cd[(cd[36] + ('cd', 36)[2] + 4)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[192] = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258
    require ('cd', 36)[3] <= test266151307()
    require cd[36] + ('cd', 36)[3] + 35 < calldata.size
    if cd[(cd[36] + ('cd', 36)[3] + 4)] > test266151307():
        revert with 0, 65
    if ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 260 < 259 or ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 260 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259] = cd[(cd[36] + ('cd', 36)[3] + 4)]
    require cd[36] + ('cd', 36)[3] + (32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 36 <= calldata.size
    idx = 0
    s = cd[36] + ('cd', 36)[3] + 36
    t = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 291
    while idx < cd[(cd[36] + ('cd', 36)[3] + 4)]:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[224] = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 259
    require ext_code.size(sub_238f9b7aAddress)
    staticcall sub_238f9b7aAddress.getPriceOracle() with:
            gas gas_remaining wei
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + 260] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260] = 0x9d23d9f200000000000000000000000000000000000000000000000000000000
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 264] = 32
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 296] = cd[(cd[36] + ('cd', 36)[2] + 4)]
    idx = 0
    s = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290
    t = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 328
    while idx < cd[(cd[36] + ('cd', 36)[2] + 4)]:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getAssetsPrices(address[] rg1) with:
            gas gas_remaining wei
           args Array(len=cd[(cd[36] + ('cd', 36)[2] + 4)], data=mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 328 len 32 * cd[(cd[36] + ('cd', 36)[2] + 4)]])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260
    require return_data.size >= 32
    _1405 = mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0
    require mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0 <= test266151307()
    require ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + return_data.size + 260 > ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0 + 291
    _1406 = mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0 + 260]
    if mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0 + 260] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0 + 260]) + 1 < 0 or ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0 + 260]) + 261 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + 260 len 4], 0 + 260]) + 261
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260] = _1406
    require _1405 + (32 * _1406) + 32 <= return_data.size
    mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292 len 32 * _1406] = mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + ceil32(return_data.size) + _1405 + 292 len 32 * _1406]
    if cd[(cd[36] + ('cd', 36)[2] + 4)] > test266151307():
        revert with 0, 65
    _1676 = mem[64]
    mem[mem[64]] = cd[(cd[36] + ('cd', 36)[2] + 4)]
    mem[64] = mem[64] + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 32
    if not cd[(cd[36] + ('cd', 36)[2] + 4)]:
        idx = 0
        while idx < cd[(cd[36] + ('cd', 36)[2] + 4)]:
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1951 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1957 = mem[_1951]
            _1958 = mem[_1951 + 32]
            _1959 = mem[_1951 + 64]
            _1962 = mem[_1951 + 160]
            require mem[_1951 + 160] == bool(mem[_1951 + 160])
            _1980 = mem[_1951 + 192]
            require mem[_1951 + 192] == bool(mem[_1951 + 192])
            require mem[_1951 + 224] == bool(mem[_1951 + 224])
            _2002 = mem[_1951 + 256]
            require mem[_1951 + 256] == bool(mem[_1951 + 256])
            require mem[_1951 + 288] == bool(mem[_1951 + 288])
            if idx >= mem[_1676]:
                revert with 0, 50
            _2029 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _2035 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _2041 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _2045 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _2048 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _2052 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 192] = bool(mem[_1951 + 288])
            mem[_2052 + 160] = bool(_2002)
            mem[_2048 + 128] = bool(_1980)
            mem[_2045 + 96] = bool(_1962)
            mem[_2041 + 64] = _1959
            mem[_2035 + 32] = _1958
            mem[_2029] = _1957
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2070 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2079 = mem[_2070 + 32]
            _2080 = mem[_2070 + 64]
            require mem[_2070 + 288] == mem[_2070 + 315 len 5]
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 224] = mem[_2070]
            if _2079 > !_2080:
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 256] = _2079 + _2080
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _2201 = mem[mem[192]]
        idx = 0
        s = 1
        t = 0
        u = 0
        v = 0
        while idx < _2201:
            if idx >= mem[mem[192]]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + mem[192] + 44 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2211 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_2211 + 224] == mem[_2211 + 251 len 5]
            require mem[_2211 + 256] == bool(mem[_2211 + 256])
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[_1676]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1676 + 32]]:
                revert with 0, 17
            if mem[_2211] >= mem[(32 * idx) + mem[128] + 32]:
                if not -mem[mem[(32 * idx) + _1676 + 32]] + 18:
                    if mem[(32 * idx) + mem[128] + 32] and 1 > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[128] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if u > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2201 = mem[mem[192]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                    u = u + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                    v = v + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 32)):
                    if mem[(32 * idx) + mem[128] + 32] and 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18):
                        revert with 0, 17
                    if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if u > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2201 = mem[mem[192]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                    u = u + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                    v = v + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1676 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _2201 = mem[mem[192]]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] and x * y > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] * x * y and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * x * y:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2201 = mem[mem[192]]
                idx = idx + 1
                s = s
                t = t + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if not -mem[mem[(32 * idx) + _1676 + 32]] + 18:
                if mem[(32 * idx) + mem[128] + 32] and 1 > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2201 = mem[mem[192]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 32)):
                if mem[(32 * idx) + mem[128] + 32] and 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18):
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2201 = mem[mem[192]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            w = 10
            x = 1
            s = -mem[mem[(32 * idx) + _1676 + 32]] + 18
            while s > 1:
                if w > -1 / w:
                    revert with 0, 17
                _2201 = mem[mem[192]]
                if not bool(s):
                    w = w * w
                    x = x
                    s = uint255(s) * 0.5
                    continue 
                w = w * w
                x = w * x
                s = uint255(s) * 0.5
                continue 
            if x > -1 / w:
                revert with 0, 17
            if mem[(32 * idx) + mem[128] + 32] and w * x > -1 / mem[(32 * idx) + mem[128] + 32]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                revert with 0, 50
            if mem[(32 * idx) + mem[128] + 32] * w * x and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * w * x:
                revert with 0, 17
            if mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                revert with 0, 17
            if v > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            if (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            if (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if u > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _2201 = mem[mem[192]]
            idx = idx + 1
            s = 0
            t = t + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
            u = u + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
            v = v + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
            continue 
        return v, u, t, bool(s)
    mem[64] = _1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 320
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 32] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 64] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 96] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 128] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 160] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 192] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 224] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 256] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 288] = 0
    mem[var116002] = var116001
    if not var116003 - 1:
        idx = 0
        while idx < cd[(cd[36] + ('cd', 36)[2] + 4)]:
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2557 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2565 = mem[_2557]
            _2566 = mem[_2557 + 32]
            _2567 = mem[_2557 + 64]
            _2570 = mem[_2557 + 160]
            require mem[_2557 + 160] == bool(mem[_2557 + 160])
            _2591 = mem[_2557 + 192]
            require mem[_2557 + 192] == bool(mem[_2557 + 192])
            require mem[_2557 + 224] == bool(mem[_2557 + 224])
            _2611 = mem[_2557 + 256]
            require mem[_2557 + 256] == bool(mem[_2557 + 256])
            require mem[_2557 + 288] == bool(mem[_2557 + 288])
            if idx >= mem[_1676]:
                revert with 0, 50
            _2642 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _2648 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _2652 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _2655 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _2659 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _2663 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 192] = bool(mem[_2557 + 288])
            mem[_2663 + 160] = bool(_2611)
            mem[_2659 + 128] = bool(_2591)
            mem[_2655 + 96] = bool(_2570)
            mem[_2652 + 64] = _2567
            mem[_2648 + 32] = _2566
            mem[_2642] = _2565
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2687 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2695 = mem[_2687 + 32]
            _2696 = mem[_2687 + 64]
            require mem[_2687 + 288] == mem[_2687 + 315 len 5]
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 224] = mem[_2687]
            if _2695 > !_2696:
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 256] = _2695 + _2696
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _2822 = mem[mem[192]]
        idx = 0
        s = 1
        t = 0
        u = 0
        v = 0
        while idx < _2822:
            if idx >= mem[mem[192]]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + mem[192] + 44 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2834 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_2834 + 224] == mem[_2834 + 251 len 5]
            require mem[_2834 + 256] == bool(mem[_2834 + 256])
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[_1676]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1676 + 32]]:
                revert with 0, 17
            if mem[_2834] >= mem[(32 * idx) + mem[128] + 32]:
                if not -mem[mem[(32 * idx) + _1676 + 32]] + 18:
                    if mem[(32 * idx) + mem[128] + 32] and 1 > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[128] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if u > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2822 = mem[mem[192]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                    u = u + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                    v = v + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 32)):
                    if mem[(32 * idx) + mem[128] + 32] and 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18):
                        revert with 0, 17
                    if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if u > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2822 = mem[mem[192]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                    u = u + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                    v = v + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1676 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _2822 = mem[mem[192]]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] and x * y > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] * x * y and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * x * y:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2822 = mem[mem[192]]
                idx = idx + 1
                s = s
                t = t + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if not -mem[mem[(32 * idx) + _1676 + 32]] + 18:
                if mem[(32 * idx) + mem[128] + 32] and 1 > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2822 = mem[mem[192]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 32)):
                if mem[(32 * idx) + mem[128] + 32] and 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18):
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2822 = mem[mem[192]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            w = 10
            x = 1
            s = -mem[mem[(32 * idx) + _1676 + 32]] + 18
            while s > 1:
                if w > -1 / w:
                    revert with 0, 17
                _2822 = mem[mem[192]]
                if not bool(s):
                    w = w * w
                    x = x
                    s = uint255(s) * 0.5
                    continue 
                w = w * w
                x = w * x
                s = uint255(s) * 0.5
                continue 
            if x > -1 / w:
                revert with 0, 17
            if mem[(32 * idx) + mem[128] + 32] and w * x > -1 / mem[(32 * idx) + mem[128] + 32]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                revert with 0, 50
            if mem[(32 * idx) + mem[128] + 32] * w * x and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * w * x:
                revert with 0, 17
            if mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                revert with 0, 17
            if v > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            if (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            if (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if u > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _2822 = mem[mem[192]]
            idx = idx + 1
            s = 0
            t = t + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
            u = u + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
            v = v + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
            continue 
        return v, u, t, bool(s)
    mem[64] = _1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 608
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 320] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 352] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 384] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 416] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 448] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 480] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 512] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 544] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 576] = 0
    mem[var120002] = var120001
    if not var120003 - 1:
        idx = 0
        while idx < cd[(cd[36] + ('cd', 36)[2] + 4)]:
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3178 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _3186 = mem[_3178]
            _3187 = mem[_3178 + 32]
            _3188 = mem[_3178 + 64]
            _3191 = mem[_3178 + 160]
            require mem[_3178 + 160] == bool(mem[_3178 + 160])
            _3210 = mem[_3178 + 192]
            require mem[_3178 + 192] == bool(mem[_3178 + 192])
            require mem[_3178 + 224] == bool(mem[_3178 + 224])
            _3232 = mem[_3178 + 256]
            require mem[_3178 + 256] == bool(mem[_3178 + 256])
            require mem[_3178 + 288] == bool(mem[_3178 + 288])
            if idx >= mem[_1676]:
                revert with 0, 50
            _3263 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _3269 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _3273 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _3276 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _3280 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _3284 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 192] = bool(mem[_3178 + 288])
            mem[_3284 + 160] = bool(_3232)
            mem[_3280 + 128] = bool(_3210)
            mem[_3276 + 96] = bool(_3191)
            mem[_3273 + 64] = _3188
            mem[_3269 + 32] = _3187
            mem[_3263] = _3186
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3308 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _3316 = mem[_3308 + 32]
            _3317 = mem[_3308 + 64]
            require mem[_3308 + 288] == mem[_3308 + 315 len 5]
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 224] = mem[_3308]
            if _3316 > !_3317:
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 256] = _3316 + _3317
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _3443 = mem[mem[192]]
        idx = 0
        s = 1
        t = 0
        u = 0
        v = 0
        while idx < _3443:
            if idx >= mem[mem[192]]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + mem[192] + 44 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3455 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_3455 + 224] == mem[_3455 + 251 len 5]
            require mem[_3455 + 256] == bool(mem[_3455 + 256])
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[_1676]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1676 + 32]]:
                revert with 0, 17
            if mem[_3455] >= mem[(32 * idx) + mem[128] + 32]:
                if not -mem[mem[(32 * idx) + _1676 + 32]] + 18:
                    if mem[(32 * idx) + mem[128] + 32] and 1 > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[128] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if u > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3443 = mem[mem[192]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                    u = u + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                    v = v + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 32)):
                    if mem[(32 * idx) + mem[128] + 32] and 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18):
                        revert with 0, 17
                    if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if u > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3443 = mem[mem[192]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                    u = u + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                    v = v + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1676 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _3443 = mem[mem[192]]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] and x * y > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] * x * y and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * x * y:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3443 = mem[mem[192]]
                idx = idx + 1
                s = s
                t = t + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if not -mem[mem[(32 * idx) + _1676 + 32]] + 18:
                if mem[(32 * idx) + mem[128] + 32] and 1 > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3443 = mem[mem[192]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 32)):
                if mem[(32 * idx) + mem[128] + 32] and 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18):
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3443 = mem[mem[192]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            w = 10
            x = 1
            s = -mem[mem[(32 * idx) + _1676 + 32]] + 18
            while s > 1:
                if w > -1 / w:
                    revert with 0, 17
                _3443 = mem[mem[192]]
                if not bool(s):
                    w = w * w
                    x = x
                    s = uint255(s) * 0.5
                    continue 
                w = w * w
                x = w * x
                s = uint255(s) * 0.5
                continue 
            if x > -1 / w:
                revert with 0, 17
            if mem[(32 * idx) + mem[128] + 32] and w * x > -1 / mem[(32 * idx) + mem[128] + 32]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                revert with 0, 50
            if mem[(32 * idx) + mem[128] + 32] * w * x and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * w * x:
                revert with 0, 17
            if mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                revert with 0, 17
            if v > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            if (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            if (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if u > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _3443 = mem[mem[192]]
            idx = idx + 1
            s = 0
            t = t + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
            u = u + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
            v = v + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
            continue 
        return v, u, t, bool(s)
    mem[64] = _1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 896
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 608] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 640] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 672] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 704] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 736] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 768] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 800] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 832] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 864] = 0
    mem[var124002] = var124001
    if not var124003 - 1:
        idx = 0
        while idx < cd[(cd[36] + ('cd', 36)[2] + 4)]:
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3799 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _3807 = mem[_3799]
            _3808 = mem[_3799 + 32]
            _3809 = mem[_3799 + 64]
            _3812 = mem[_3799 + 160]
            require mem[_3799 + 160] == bool(mem[_3799 + 160])
            _3831 = mem[_3799 + 192]
            require mem[_3799 + 192] == bool(mem[_3799 + 192])
            require mem[_3799 + 224] == bool(mem[_3799 + 224])
            _3853 = mem[_3799 + 256]
            require mem[_3799 + 256] == bool(mem[_3799 + 256])
            require mem[_3799 + 288] == bool(mem[_3799 + 288])
            if idx >= mem[_1676]:
                revert with 0, 50
            _3884 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _3890 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _3894 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _3897 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _3901 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _3905 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 192] = bool(mem[_3799 + 288])
            mem[_3905 + 160] = bool(_3853)
            mem[_3901 + 128] = bool(_3831)
            mem[_3897 + 96] = bool(_3812)
            mem[_3894 + 64] = _3809
            mem[_3890 + 32] = _3808
            mem[_3884] = _3807
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3929 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _3937 = mem[_3929 + 32]
            _3938 = mem[_3929 + 64]
            require mem[_3929 + 288] == mem[_3929 + 315 len 5]
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 224] = mem[_3929]
            if _3937 > !_3938:
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 256] = _3937 + _3938
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _4064 = mem[mem[192]]
        idx = 0
        s = 1
        t = 0
        u = 0
        v = 0
        while idx < _4064:
            if idx >= mem[mem[192]]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + mem[192] + 44 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4076 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_4076 + 224] == mem[_4076 + 251 len 5]
            require mem[_4076 + 256] == bool(mem[_4076 + 256])
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[_1676]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1676 + 32]]:
                revert with 0, 17
            if mem[_4076] >= mem[(32 * idx) + mem[128] + 32]:
                if not -mem[mem[(32 * idx) + _1676 + 32]] + 18:
                    if mem[(32 * idx) + mem[128] + 32] and 1 > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[128] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if u > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _4064 = mem[mem[192]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                    u = u + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                    v = v + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 32)):
                    if mem[(32 * idx) + mem[128] + 32] and 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18):
                        revert with 0, 17
                    if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if u > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _4064 = mem[mem[192]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                    u = u + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                    v = v + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1676 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _4064 = mem[mem[192]]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] and x * y > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] * x * y and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * x * y:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _4064 = mem[mem[192]]
                idx = idx + 1
                s = s
                t = t + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if not -mem[mem[(32 * idx) + _1676 + 32]] + 18:
                if mem[(32 * idx) + mem[128] + 32] and 1 > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _4064 = mem[mem[192]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 32)):
                if mem[(32 * idx) + mem[128] + 32] and 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18):
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _4064 = mem[mem[192]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            w = 10
            x = 1
            s = -mem[mem[(32 * idx) + _1676 + 32]] + 18
            while s > 1:
                if w > -1 / w:
                    revert with 0, 17
                _4064 = mem[mem[192]]
                if not bool(s):
                    w = w * w
                    x = x
                    s = uint255(s) * 0.5
                    continue 
                w = w * w
                x = w * x
                s = uint255(s) * 0.5
                continue 
            if x > -1 / w:
                revert with 0, 17
            if mem[(32 * idx) + mem[128] + 32] and w * x > -1 / mem[(32 * idx) + mem[128] + 32]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                revert with 0, 50
            if mem[(32 * idx) + mem[128] + 32] * w * x and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * w * x:
                revert with 0, 17
            if mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                revert with 0, 17
            if v > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            if (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            if (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if u > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _4064 = mem[mem[192]]
            idx = idx + 1
            s = 0
            t = t + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
            u = u + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
            v = v + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
            continue 
        return v, u, t, bool(s)
    mem[64] = _1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1184
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 896] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 928] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 960] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 992] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1024] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1056] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1088] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1120] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1152] = 0
    mem[var128002] = var128001
    if not var128003 - 1:
        idx = 0
        while idx < cd[(cd[36] + ('cd', 36)[2] + 4)]:
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4420 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _4428 = mem[_4420]
            _4429 = mem[_4420 + 32]
            _4430 = mem[_4420 + 64]
            _4433 = mem[_4420 + 160]
            require mem[_4420 + 160] == bool(mem[_4420 + 160])
            _4452 = mem[_4420 + 192]
            require mem[_4420 + 192] == bool(mem[_4420 + 192])
            require mem[_4420 + 224] == bool(mem[_4420 + 224])
            _4474 = mem[_4420 + 256]
            require mem[_4420 + 256] == bool(mem[_4420 + 256])
            require mem[_4420 + 288] == bool(mem[_4420 + 288])
            if idx >= mem[_1676]:
                revert with 0, 50
            _4505 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _4511 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _4515 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _4518 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _4522 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _4526 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 192] = bool(mem[_4420 + 288])
            mem[_4526 + 160] = bool(_4474)
            mem[_4522 + 128] = bool(_4452)
            mem[_4518 + 96] = bool(_4433)
            mem[_4515 + 64] = _4430
            mem[_4511 + 32] = _4429
            mem[_4505] = _4428
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4550 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _4558 = mem[_4550 + 32]
            _4559 = mem[_4550 + 64]
            require mem[_4550 + 288] == mem[_4550 + 315 len 5]
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 224] = mem[_4550]
            if _4558 > !_4559:
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 256] = _4558 + _4559
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _4685 = mem[mem[192]]
        idx = 0
        s = 1
        t = 0
        u = 0
        v = 0
        while idx < _4685:
            if idx >= mem[mem[192]]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + mem[192] + 44 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4697 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_4697 + 224] == mem[_4697 + 251 len 5]
            require mem[_4697 + 256] == bool(mem[_4697 + 256])
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[_1676]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1676 + 32]]:
                revert with 0, 17
            if mem[_4697] >= mem[(32 * idx) + mem[128] + 32]:
                if not -mem[mem[(32 * idx) + _1676 + 32]] + 18:
                    if mem[(32 * idx) + mem[128] + 32] and 1 > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[128] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if u > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _4685 = mem[mem[192]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                    u = u + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                    v = v + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 32)):
                    if mem[(32 * idx) + mem[128] + 32] and 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18):
                        revert with 0, 17
                    if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if u > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _4685 = mem[mem[192]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                    u = u + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                    v = v + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1676 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _4685 = mem[mem[192]]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] and x * y > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] * x * y and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * x * y:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _4685 = mem[mem[192]]
                idx = idx + 1
                s = s
                t = t + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if not -mem[mem[(32 * idx) + _1676 + 32]] + 18:
                if mem[(32 * idx) + mem[128] + 32] and 1 > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _4685 = mem[mem[192]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 32)):
                if mem[(32 * idx) + mem[128] + 32] and 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18):
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _4685 = mem[mem[192]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            w = 10
            x = 1
            s = -mem[mem[(32 * idx) + _1676 + 32]] + 18
            while s > 1:
                if w > -1 / w:
                    revert with 0, 17
                _4685 = mem[mem[192]]
                if not bool(s):
                    w = w * w
                    x = x
                    s = uint255(s) * 0.5
                    continue 
                w = w * w
                x = w * x
                s = uint255(s) * 0.5
                continue 
            if x > -1 / w:
                revert with 0, 17
            if mem[(32 * idx) + mem[128] + 32] and w * x > -1 / mem[(32 * idx) + mem[128] + 32]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                revert with 0, 50
            if mem[(32 * idx) + mem[128] + 32] * w * x and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * w * x:
                revert with 0, 17
            if mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                revert with 0, 17
            if v > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            if (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            if (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if u > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _4685 = mem[mem[192]]
            idx = idx + 1
            s = 0
            t = t + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
            u = u + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
            v = v + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
            continue 
        return v, u, t, bool(s)
    mem[64] = _1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1472
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1184] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1216] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1248] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1280] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1312] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1344] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1376] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1408] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1440] = 0
    mem[var132002] = var132001
    if not var132003 - 1:
        idx = 0
        while idx < cd[(cd[36] + ('cd', 36)[2] + 4)]:
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5041 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _5049 = mem[_5041]
            _5050 = mem[_5041 + 32]
            _5051 = mem[_5041 + 64]
            _5054 = mem[_5041 + 160]
            require mem[_5041 + 160] == bool(mem[_5041 + 160])
            _5073 = mem[_5041 + 192]
            require mem[_5041 + 192] == bool(mem[_5041 + 192])
            require mem[_5041 + 224] == bool(mem[_5041 + 224])
            _5095 = mem[_5041 + 256]
            require mem[_5041 + 256] == bool(mem[_5041 + 256])
            require mem[_5041 + 288] == bool(mem[_5041 + 288])
            if idx >= mem[_1676]:
                revert with 0, 50
            _5126 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _5132 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _5136 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _5139 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _5143 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _5147 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 192] = bool(mem[_5041 + 288])
            mem[_5147 + 160] = bool(_5095)
            mem[_5143 + 128] = bool(_5073)
            mem[_5139 + 96] = bool(_5054)
            mem[_5136 + 64] = _5051
            mem[_5132 + 32] = _5050
            mem[_5126] = _5049
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5171 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _5179 = mem[_5171 + 32]
            _5180 = mem[_5171 + 64]
            require mem[_5171 + 288] == mem[_5171 + 315 len 5]
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 224] = mem[_5171]
            if _5179 > !_5180:
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 256] = _5179 + _5180
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _5306 = mem[mem[192]]
        idx = 0
        s = 1
        t = 0
        u = 0
        v = 0
        while idx < _5306:
            if idx >= mem[mem[192]]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + mem[192] + 44 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5318 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_5318 + 224] == mem[_5318 + 251 len 5]
            require mem[_5318 + 256] == bool(mem[_5318 + 256])
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[mem[128]]:
                revert with 0, 50
            if idx >= mem[_1676]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1676 + 32]]:
                revert with 0, 17
            if mem[_5318] >= mem[(32 * idx) + mem[128] + 32]:
                if not -mem[mem[(32 * idx) + _1676 + 32]] + 18:
                    if mem[(32 * idx) + mem[128] + 32] and 1 > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[128] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if u > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5306 = mem[mem[192]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                    u = u + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                    v = v + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 32)):
                    if mem[(32 * idx) + mem[128] + 32] and 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) > -1 / mem[(32 * idx) + mem[128] + 32]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                        revert with 0, 50
                    if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18):
                        revert with 0, 17
                    if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1676]:
                        revert with 0, 50
                    if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if u > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5306 = mem[mem[192]]
                    idx = idx + 1
                    s = s
                    t = t + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                    u = u + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                    v = v + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1676 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _5306 = mem[mem[192]]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] and x * y > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] * x * y and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * x * y:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5306 = mem[mem[192]]
                idx = idx + 1
                s = s
                t = t + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * x * y * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if not -mem[mem[(32 * idx) + _1676 + 32]] + 18:
                if mem[(32 * idx) + mem[128] + 32] and 1 > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5306 = mem[mem[192]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1676 + 32]] + 18 < 32)):
                if mem[(32 * idx) + mem[128] + 32] and 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) > -1 / mem[(32 * idx) + mem[128] + 32]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                    revert with 0, 50
                if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18):
                    revert with 0, 17
                if mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1676]:
                    revert with 0, 50
                if (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if u > !((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5306 = mem[mem[192]]
                idx = idx + 1
                s = 0
                t = t + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
                u = u + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
                v = v + ((mem[(32 * idx) + mem[128] + 32] * 10^(-mem[mem[(32 * idx) + _1676 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
                continue 
            w = 10
            x = 1
            s = -mem[mem[(32 * idx) + _1676 + 32]] + 18
            while s > 1:
                if w > -1 / w:
                    revert with 0, 17
                _5306 = mem[mem[192]]
                if not bool(s):
                    w = w * w
                    x = x
                    s = uint255(s) * 0.5
                    continue 
                w = w * w
                x = w * x
                s = uint255(s) * 0.5
                continue 
            if x > -1 / w:
                revert with 0, 17
            if mem[(32 * idx) + mem[128] + 32] and w * x > -1 / mem[(32 * idx) + mem[128] + 32]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 260]:
                revert with 0, 50
            if mem[(32 * idx) + mem[128] + 32] * w * x and mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -1 / mem[(32 * idx) + mem[128] + 32] * w * x:
                revert with 0, 17
            if mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292] > -500000000000000001:
                revert with 0, 17
            if v > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            if (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 64] > -1 / (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            if (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1676 + 32] + 32] > -1 / (mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if u > !((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _5306 = mem[mem[192]]
            idx = idx + 1
            s = 0
            t = t + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 64] / 10000)
            u = u + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1676 + 32] + 32] / 10000)
            v = v + ((mem[(32 * idx) + mem[128] + 32] * w * x * mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[3] + 4)]) + (2 * ceil32(return_data.size)) + 292]) + 5 * 10^17 / 10^18)
            continue 
        return v, u, t, bool(s)
    mem[64] = _1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1760
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1472] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1504] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1536] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1568] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1600] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1632] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1664] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1696] = 0
    mem[_1676 + (32 * cd[(cd[36] + ('cd', 36)[2] + 4)]) + 1728] = 0
    mem[var136002] = var136001
    if not var136003 - 1:
        idx = 0
        while idx < cd[(cd[36] + ('cd', 36)[2] + 4)]:
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5662 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _5670 = mem[_5662]
            _5671 = mem[_5662 + 32]
            _5672 = mem[_5662 + 64]
            _5675 = mem[_5662 + 160]
            require mem[_5662 + 160] == bool(mem[_5662 + 160])
            _5694 = mem[_5662 + 192]
            require mem[_5662 + 192] == bool(mem[_5662 + 192])
            require mem[_5662 + 224] == bool(mem[_5662 + 224])
            _5716 = mem[_5662 + 256]
            require mem[_5662 + 256] == bool(mem[_5662 + 256])
            require mem[_5662 + 288] == bool(mem[_5662 + 288])
            if idx >= mem[_1676]:
                revert with 0, 50
            _5747 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _5753 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _5757 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _5760 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _5764 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            _5768 = mem[(32 * idx) + _1676 + 32]
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 192] = bool(mem[_5662 + 288])
            mem[_5768 + 160] = bool(_5716)
            mem[_5764 + 128] = bool(_5694)
            mem[_5760 + 96] = bool(_5675)
            mem[_5757 + 64] = _5672
            mem[_5753 + 32] = _5671
            mem[_5747] = _5670
            if idx >= mem[ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 258]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + ceil32(32 * cd[(cd[36] + ('cd', 36)[0] + 4)]) + ceil32(32 * cd[(cd[36] + ('cd', 36)[1] + 4)]) + 290])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5792 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _5800 = mem[_5792 + 32]
            _5801 = mem[_5792 + 64]
            require mem[_5792 + 288] == mem[_5792 + 315 len 5]
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 224] = mem[_5792]
            if _5800 > !_5801:
                revert with 0, 17
            if idx >= mem[_1676]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1676 + 32] + 256] = _5800 + _5801
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
    # nil
}

function sub_83382653(?) payable {
    require calldata.size - 4 >= 64
    require cd[4] == address(cd[4])
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 97 < 96 or ceil32(32 * ('cd', 36).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = 128
    while idx < ('cd', 36).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(sub_238f9b7aAddress)
    staticcall sub_238f9b7aAddress.getPriceOracle() with:
            gas gas_remaining wei
    mem[ceil32(32 * ('cd', 36).length) + 97] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97] = 0x9d23d9f200000000000000000000000000000000000000000000000000000000
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 101] = 32
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 133] = ('cd', 36).length
    idx = 0
    s = 128
    t = ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 165
    while idx < ('cd', 36).length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getAssetsPrices(address[] rg1) with:
            gas gas_remaining wei
           args Array(len=('cd', 36).length, data=mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 165 len 32 * ('cd', 36).length])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97
    require return_data.size >= 32
    _657 = mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97 len 4], 0
    require mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97 len 4], 0 <= test266151307()
    require ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + return_data.size + 97 > ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97 len 4], 0 + 128
    _658 = mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97 len 4], 0 + 97]
    if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97 len 4], 0 + 97] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97 len 4], 0 + 97]) + 1 < 0 or ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97 len 4], 0 + 97]) + 98 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 97 len 4], 0 + 97]) + 98
    mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97] = _658
    require _657 + (32 * _658) + 32 <= return_data.size
    mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129 len 32 * _658] = mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + _657 + 129 len 32 * _658]
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    _976 = mem[64]
    mem[mem[64]] = ('cd', 36).length
    mem[64] = mem[64] + (32 * ('cd', 36).length) + 32
    if not ('cd', 36).length:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1299 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1305 = mem[_1299]
            _1306 = mem[_1299 + 32]
            _1307 = mem[_1299 + 64]
            _1310 = mem[_1299 + 160]
            require mem[_1299 + 160] == bool(mem[_1299 + 160])
            _1326 = mem[_1299 + 192]
            require mem[_1299 + 192] == bool(mem[_1299 + 192])
            require mem[_1299 + 224] == bool(mem[_1299 + 224])
            _1348 = mem[_1299 + 256]
            require mem[_1299 + 256] == bool(mem[_1299 + 256])
            require mem[_1299 + 288] == bool(mem[_1299 + 288])
            if idx >= mem[_976]:
                revert with 0, 50
            _1361 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _1363 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _1365 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _1367 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _1370 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _1374 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 192] = bool(mem[_1299 + 288])
            mem[_1374 + 160] = bool(_1348)
            mem[_1370 + 128] = bool(_1326)
            mem[_1367 + 96] = bool(_1310)
            mem[_1365 + 64] = _1307
            mem[_1363 + 32] = _1306
            mem[_1361] = _1305
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1393 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1401 = mem[_1393 + 32]
            _1402 = mem[_1393 + 64]
            require mem[_1393 + 288] == mem[_1393 + 315 len 5]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 224] = mem[_1393]
            if _1401 > !_1402:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 256] = _1401 + _1402
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _1600 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _1600:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1609 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_1609 + 224] == mem[_1609 + 251 len 5]
            require mem[_1609 + 256] == bool(mem[_1609 + 256])
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_1609] and 1 > -1 / mem[_1609]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_1609] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_1609]:
                    revert with 0, 17
                if mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_1609 + 32] > !mem[_1609 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_1609 + 32] + mem[_1609 + 64] and 1 > -1 / mem[_1609 + 32] + mem[_1609 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_1609 + 32] + mem[_1609 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_1609 + 32] + mem[_1609 + 64]:
                        revert with 0, 17
                    if (mem[_1609 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_1609 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _1600 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_1609 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                    if mem[_1609 + 32] + mem[_1609 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_1609 + 32] + mem[_1609 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _1600 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _976 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _1600 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_1609 + 32] + mem[_1609 + 64] and x * y > -1 / mem[_1609 + 32] + mem[_1609 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_1609 + 32] * x * y) + (mem[_1609 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_1609 + 32] * x * y) + (mem[_1609 + 64] * x * y):
                    revert with 0, 17
                if (mem[_1609 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_1609 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _1600 = mem[96]
                idx = idx + 1
                s = s + ((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_1609 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_1609] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                if mem[_1609] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_1609]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18):
                    revert with 0, 17
                if mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_1609 + 32] > !mem[_1609 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_1609 + 32] + mem[_1609 + 64] and 1 > -1 / mem[_1609 + 32] + mem[_1609 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_1609 + 32] + mem[_1609 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_1609 + 32] + mem[_1609 + 64]:
                        revert with 0, 17
                    if (mem[_1609 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_1609 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _1600 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_1609 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                    if mem[_1609 + 32] + mem[_1609 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_1609 + 32] + mem[_1609 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _1600 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _976 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _1600 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_1609 + 32] + mem[_1609 + 64] and x * y > -1 / mem[_1609 + 32] + mem[_1609 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_1609 + 32] * x * y) + (mem[_1609 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_1609 + 32] * x * y) + (mem[_1609 + 64] * x * y):
                    revert with 0, 17
                if (mem[_1609 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_1609 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _1600 = mem[96]
                idx = idx + 1
                s = s + ((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_1609 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_1609] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            x = 10
            y = 1
            w = -mem[mem[(32 * idx) + _976 + 32]] + 18
            while w > 1:
                if x > -1 / x:
                    revert with 0, 17
                _1600 = mem[96]
                if not bool(w):
                    x = x * x
                    y = y
                    w = uint255(w) * 0.5
                    continue 
                x = x * x
                y = x * y
                w = uint255(w) * 0.5
                continue 
            if y > -1 / x:
                revert with 0, 17
            if mem[_1609] and x * y > -1 / mem[_1609]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                revert with 0, 50
            if mem[_1609] * x * y and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_1609] * x * y:
                revert with 0, 17
            if mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                revert with 0, 17
            if mem[_1609 + 32] > !mem[_1609 + 64]:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_1609 + 32] + mem[_1609 + 64] and 1 > -1 / mem[_1609 + 32] + mem[_1609 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_1609 + 32] + mem[_1609 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_1609 + 32] + mem[_1609 + 64]:
                    revert with 0, 17
                if (mem[_1609 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_1609 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _1600 = mem[96]
                idx = idx + 1
                s = s + ((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_1609 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                if mem[_1609 + 32] + mem[_1609 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_1609 + 32] + mem[_1609 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                    revert with 0, 17
                if (mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _1600 = mem[96]
                idx = idx + 1
                s = s + ((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_1609 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            z = 10
            a = 1
            w = -mem[mem[(32 * idx) + _976 + 32]] + 18
            while w > 1:
                if z > -1 / z:
                    revert with 0, 17
                _1600 = mem[96]
                if not bool(w):
                    z = z * z
                    a = a
                    w = uint255(w) * 0.5
                    continue 
                z = z * z
                a = z * a
                w = uint255(w) * 0.5
                continue 
            if a > -1 / z:
                revert with 0, 17
            if mem[_1609 + 32] + mem[_1609 + 64] and z * a > -1 / mem[_1609 + 32] + mem[_1609 + 64]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                revert with 0, 50
            if (mem[_1609 + 32] * z * a) + (mem[_1609 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_1609 + 32] * z * a) + (mem[_1609 + 64] * z * a):
                revert with 0, 17
            if (mem[_1609 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                revert with 0, 17
            if v > !((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if u > !((mem[_1609 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if (mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if s > !((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if (mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _1600 = mem[96]
            idx = idx + 1
            s = s + ((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
            t = t + ((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
            u = u + ((mem[_1609 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_1609 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
            v = v + ((mem[_1609] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
            continue 
        return v, u, t, s
    mem[64] = _976 + (32 * ('cd', 36).length) + 320
    mem[_976 + (32 * ('cd', 36).length) + 32] = 0
    mem[_976 + (32 * ('cd', 36).length) + 64] = 0
    mem[_976 + (32 * ('cd', 36).length) + 96] = 0
    mem[_976 + (32 * ('cd', 36).length) + 128] = 0
    mem[_976 + (32 * ('cd', 36).length) + 160] = 0
    mem[_976 + (32 * ('cd', 36).length) + 192] = 0
    mem[_976 + (32 * ('cd', 36).length) + 224] = 0
    mem[_976 + (32 * ('cd', 36).length) + 256] = 0
    mem[_976 + (32 * ('cd', 36).length) + 288] = 0
    mem[var64002] = var64001
    if not var64003 - 1:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2030 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2037 = mem[_2030]
            _2038 = mem[_2030 + 32]
            _2039 = mem[_2030 + 64]
            _2042 = mem[_2030 + 160]
            require mem[_2030 + 160] == bool(mem[_2030 + 160])
            _2064 = mem[_2030 + 192]
            require mem[_2030 + 192] == bool(mem[_2030 + 192])
            require mem[_2030 + 224] == bool(mem[_2030 + 224])
            _2084 = mem[_2030 + 256]
            require mem[_2030 + 256] == bool(mem[_2030 + 256])
            require mem[_2030 + 288] == bool(mem[_2030 + 288])
            if idx >= mem[_976]:
                revert with 0, 50
            _2097 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _2099 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _2101 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _2104 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _2108 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _2112 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 192] = bool(mem[_2030 + 288])
            mem[_2112 + 160] = bool(_2084)
            mem[_2108 + 128] = bool(_2064)
            mem[_2104 + 96] = bool(_2042)
            mem[_2101 + 64] = _2039
            mem[_2099 + 32] = _2038
            mem[_2097] = _2037
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2133 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2148 = mem[_2133 + 32]
            _2149 = mem[_2133 + 64]
            require mem[_2133 + 288] == mem[_2133 + 315 len 5]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 224] = mem[_2133]
            if _2148 > !_2149:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 256] = _2148 + _2149
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _2375 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _2375:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2386 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_2386 + 224] == mem[_2386 + 251 len 5]
            require mem[_2386 + 256] == bool(mem[_2386 + 256])
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_2386] and 1 > -1 / mem[_2386]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_2386] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_2386]:
                    revert with 0, 17
                if mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_2386 + 32] > !mem[_2386 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_2386 + 32] + mem[_2386 + 64] and 1 > -1 / mem[_2386 + 32] + mem[_2386 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_2386 + 32] + mem[_2386 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_2386 + 32] + mem[_2386 + 64]:
                        revert with 0, 17
                    if (mem[_2386 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_2386 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2375 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_2386 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                    if mem[_2386 + 32] + mem[_2386 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_2386 + 32] + mem[_2386 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2375 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _976 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _2375 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_2386 + 32] + mem[_2386 + 64] and x * y > -1 / mem[_2386 + 32] + mem[_2386 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_2386 + 32] * x * y) + (mem[_2386 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_2386 + 32] * x * y) + (mem[_2386 + 64] * x * y):
                    revert with 0, 17
                if (mem[_2386 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_2386 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2375 = mem[96]
                idx = idx + 1
                s = s + ((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_2386 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_2386] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                if mem[_2386] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_2386]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18):
                    revert with 0, 17
                if mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_2386 + 32] > !mem[_2386 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_2386 + 32] + mem[_2386 + 64] and 1 > -1 / mem[_2386 + 32] + mem[_2386 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_2386 + 32] + mem[_2386 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_2386 + 32] + mem[_2386 + 64]:
                        revert with 0, 17
                    if (mem[_2386 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_2386 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2375 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_2386 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                    if mem[_2386 + 32] + mem[_2386 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_2386 + 32] + mem[_2386 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2375 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _976 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _2375 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_2386 + 32] + mem[_2386 + 64] and x * y > -1 / mem[_2386 + 32] + mem[_2386 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_2386 + 32] * x * y) + (mem[_2386 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_2386 + 32] * x * y) + (mem[_2386 + 64] * x * y):
                    revert with 0, 17
                if (mem[_2386 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_2386 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2375 = mem[96]
                idx = idx + 1
                s = s + ((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_2386 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_2386] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            x = 10
            y = 1
            w = -mem[mem[(32 * idx) + _976 + 32]] + 18
            while w > 1:
                if x > -1 / x:
                    revert with 0, 17
                _2375 = mem[96]
                if not bool(w):
                    x = x * x
                    y = y
                    w = uint255(w) * 0.5
                    continue 
                x = x * x
                y = x * y
                w = uint255(w) * 0.5
                continue 
            if y > -1 / x:
                revert with 0, 17
            if mem[_2386] and x * y > -1 / mem[_2386]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                revert with 0, 50
            if mem[_2386] * x * y and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_2386] * x * y:
                revert with 0, 17
            if mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                revert with 0, 17
            if mem[_2386 + 32] > !mem[_2386 + 64]:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_2386 + 32] + mem[_2386 + 64] and 1 > -1 / mem[_2386 + 32] + mem[_2386 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_2386 + 32] + mem[_2386 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_2386 + 32] + mem[_2386 + 64]:
                    revert with 0, 17
                if (mem[_2386 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_2386 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2375 = mem[96]
                idx = idx + 1
                s = s + ((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_2386 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                if mem[_2386 + 32] + mem[_2386 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_2386 + 32] + mem[_2386 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                    revert with 0, 17
                if (mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2375 = mem[96]
                idx = idx + 1
                s = s + ((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_2386 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            z = 10
            a = 1
            w = -mem[mem[(32 * idx) + _976 + 32]] + 18
            while w > 1:
                if z > -1 / z:
                    revert with 0, 17
                _2375 = mem[96]
                if not bool(w):
                    z = z * z
                    a = a
                    w = uint255(w) * 0.5
                    continue 
                z = z * z
                a = z * a
                w = uint255(w) * 0.5
                continue 
            if a > -1 / z:
                revert with 0, 17
            if mem[_2386 + 32] + mem[_2386 + 64] and z * a > -1 / mem[_2386 + 32] + mem[_2386 + 64]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                revert with 0, 50
            if (mem[_2386 + 32] * z * a) + (mem[_2386 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_2386 + 32] * z * a) + (mem[_2386 + 64] * z * a):
                revert with 0, 17
            if (mem[_2386 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                revert with 0, 17
            if v > !((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if u > !((mem[_2386 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if (mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if s > !((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if (mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _2375 = mem[96]
            idx = idx + 1
            s = s + ((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
            t = t + ((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
            u = u + ((mem[_2386 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_2386 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
            v = v + ((mem[_2386] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
            continue 
        return v, u, t, s
    mem[64] = _976 + (32 * ('cd', 36).length) + 608
    mem[_976 + (32 * ('cd', 36).length) + 320] = 0
    mem[_976 + (32 * ('cd', 36).length) + 352] = 0
    mem[_976 + (32 * ('cd', 36).length) + 384] = 0
    mem[_976 + (32 * ('cd', 36).length) + 416] = 0
    mem[_976 + (32 * ('cd', 36).length) + 448] = 0
    mem[_976 + (32 * ('cd', 36).length) + 480] = 0
    mem[_976 + (32 * ('cd', 36).length) + 512] = 0
    mem[_976 + (32 * ('cd', 36).length) + 544] = 0
    mem[_976 + (32 * ('cd', 36).length) + 576] = 0
    mem[var68002] = var68001
    if not var68003 - 1:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2813 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2820 = mem[_2813]
            _2821 = mem[_2813 + 32]
            _2822 = mem[_2813 + 64]
            _2825 = mem[_2813 + 160]
            require mem[_2813 + 160] == bool(mem[_2813 + 160])
            _2844 = mem[_2813 + 192]
            require mem[_2813 + 192] == bool(mem[_2813 + 192])
            require mem[_2813 + 224] == bool(mem[_2813 + 224])
            _2867 = mem[_2813 + 256]
            require mem[_2813 + 256] == bool(mem[_2813 + 256])
            require mem[_2813 + 288] == bool(mem[_2813 + 288])
            if idx >= mem[_976]:
                revert with 0, 50
            _2880 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _2882 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _2884 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _2887 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _2891 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _2895 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 192] = bool(mem[_2813 + 288])
            mem[_2895 + 160] = bool(_2867)
            mem[_2891 + 128] = bool(_2844)
            mem[_2887 + 96] = bool(_2825)
            mem[_2884 + 64] = _2822
            mem[_2882 + 32] = _2821
            mem[_2880] = _2820
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2914 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2929 = mem[_2914 + 32]
            _2930 = mem[_2914 + 64]
            require mem[_2914 + 288] == mem[_2914 + 315 len 5]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 224] = mem[_2914]
            if _2929 > !_2930:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 256] = _2929 + _2930
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _3158 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _3158:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3169 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_3169 + 224] == mem[_3169 + 251 len 5]
            require mem[_3169 + 256] == bool(mem[_3169 + 256])
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_3169] and 1 > -1 / mem[_3169]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_3169] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_3169]:
                    revert with 0, 17
                if mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_3169 + 32] > !mem[_3169 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_3169 + 32] + mem[_3169 + 64] and 1 > -1 / mem[_3169 + 32] + mem[_3169 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_3169 + 32] + mem[_3169 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_3169 + 32] + mem[_3169 + 64]:
                        revert with 0, 17
                    if (mem[_3169 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3169 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3158 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_3169 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                    if mem[_3169 + 32] + mem[_3169 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_3169 + 32] + mem[_3169 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3158 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _976 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _3158 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_3169 + 32] + mem[_3169 + 64] and x * y > -1 / mem[_3169 + 32] + mem[_3169 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_3169 + 32] * x * y) + (mem[_3169 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_3169 + 32] * x * y) + (mem[_3169 + 64] * x * y):
                    revert with 0, 17
                if (mem[_3169 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_3169 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3158 = mem[96]
                idx = idx + 1
                s = s + ((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_3169 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_3169] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                if mem[_3169] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_3169]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18):
                    revert with 0, 17
                if mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_3169 + 32] > !mem[_3169 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_3169 + 32] + mem[_3169 + 64] and 1 > -1 / mem[_3169 + 32] + mem[_3169 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_3169 + 32] + mem[_3169 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_3169 + 32] + mem[_3169 + 64]:
                        revert with 0, 17
                    if (mem[_3169 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3169 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3158 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_3169 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                    if mem[_3169 + 32] + mem[_3169 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_3169 + 32] + mem[_3169 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3158 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _976 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _3158 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_3169 + 32] + mem[_3169 + 64] and x * y > -1 / mem[_3169 + 32] + mem[_3169 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_3169 + 32] * x * y) + (mem[_3169 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_3169 + 32] * x * y) + (mem[_3169 + 64] * x * y):
                    revert with 0, 17
                if (mem[_3169 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_3169 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3158 = mem[96]
                idx = idx + 1
                s = s + ((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_3169 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_3169] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            x = 10
            y = 1
            w = -mem[mem[(32 * idx) + _976 + 32]] + 18
            while w > 1:
                if x > -1 / x:
                    revert with 0, 17
                _3158 = mem[96]
                if not bool(w):
                    x = x * x
                    y = y
                    w = uint255(w) * 0.5
                    continue 
                x = x * x
                y = x * y
                w = uint255(w) * 0.5
                continue 
            if y > -1 / x:
                revert with 0, 17
            if mem[_3169] and x * y > -1 / mem[_3169]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                revert with 0, 50
            if mem[_3169] * x * y and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_3169] * x * y:
                revert with 0, 17
            if mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                revert with 0, 17
            if mem[_3169 + 32] > !mem[_3169 + 64]:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_3169 + 32] + mem[_3169 + 64] and 1 > -1 / mem[_3169 + 32] + mem[_3169 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_3169 + 32] + mem[_3169 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_3169 + 32] + mem[_3169 + 64]:
                    revert with 0, 17
                if (mem[_3169 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_3169 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3158 = mem[96]
                idx = idx + 1
                s = s + ((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_3169 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                if mem[_3169 + 32] + mem[_3169 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_3169 + 32] + mem[_3169 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                    revert with 0, 17
                if (mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3158 = mem[96]
                idx = idx + 1
                s = s + ((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_3169 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            z = 10
            a = 1
            w = -mem[mem[(32 * idx) + _976 + 32]] + 18
            while w > 1:
                if z > -1 / z:
                    revert with 0, 17
                _3158 = mem[96]
                if not bool(w):
                    z = z * z
                    a = a
                    w = uint255(w) * 0.5
                    continue 
                z = z * z
                a = z * a
                w = uint255(w) * 0.5
                continue 
            if a > -1 / z:
                revert with 0, 17
            if mem[_3169 + 32] + mem[_3169 + 64] and z * a > -1 / mem[_3169 + 32] + mem[_3169 + 64]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                revert with 0, 50
            if (mem[_3169 + 32] * z * a) + (mem[_3169 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_3169 + 32] * z * a) + (mem[_3169 + 64] * z * a):
                revert with 0, 17
            if (mem[_3169 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                revert with 0, 17
            if v > !((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if u > !((mem[_3169 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if (mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if s > !((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if (mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _3158 = mem[96]
            idx = idx + 1
            s = s + ((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
            t = t + ((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
            u = u + ((mem[_3169 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3169 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
            v = v + ((mem[_3169] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
            continue 
        return v, u, t, s
    mem[64] = _976 + (32 * ('cd', 36).length) + 896
    mem[_976 + (32 * ('cd', 36).length) + 608] = 0
    mem[_976 + (32 * ('cd', 36).length) + 640] = 0
    mem[_976 + (32 * ('cd', 36).length) + 672] = 0
    mem[_976 + (32 * ('cd', 36).length) + 704] = 0
    mem[_976 + (32 * ('cd', 36).length) + 736] = 0
    mem[_976 + (32 * ('cd', 36).length) + 768] = 0
    mem[_976 + (32 * ('cd', 36).length) + 800] = 0
    mem[_976 + (32 * ('cd', 36).length) + 832] = 0
    mem[_976 + (32 * ('cd', 36).length) + 864] = 0
    mem[var72002] = var72001
    if not var72003 - 1:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3596 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _3603 = mem[_3596]
            _3604 = mem[_3596 + 32]
            _3605 = mem[_3596 + 64]
            _3608 = mem[_3596 + 160]
            require mem[_3596 + 160] == bool(mem[_3596 + 160])
            _3627 = mem[_3596 + 192]
            require mem[_3596 + 192] == bool(mem[_3596 + 192])
            require mem[_3596 + 224] == bool(mem[_3596 + 224])
            _3650 = mem[_3596 + 256]
            require mem[_3596 + 256] == bool(mem[_3596 + 256])
            require mem[_3596 + 288] == bool(mem[_3596 + 288])
            if idx >= mem[_976]:
                revert with 0, 50
            _3663 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _3665 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _3667 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _3670 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _3674 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _3678 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 192] = bool(mem[_3596 + 288])
            mem[_3678 + 160] = bool(_3650)
            mem[_3674 + 128] = bool(_3627)
            mem[_3670 + 96] = bool(_3608)
            mem[_3667 + 64] = _3605
            mem[_3665 + 32] = _3604
            mem[_3663] = _3603
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3697 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _3712 = mem[_3697 + 32]
            _3713 = mem[_3697 + 64]
            require mem[_3697 + 288] == mem[_3697 + 315 len 5]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 224] = mem[_3697]
            if _3712 > !_3713:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 256] = _3712 + _3713
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _3941 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _3941:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3952 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_3952 + 224] == mem[_3952 + 251 len 5]
            require mem[_3952 + 256] == bool(mem[_3952 + 256])
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_3952] and 1 > -1 / mem[_3952]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_3952] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_3952]:
                    revert with 0, 17
                if mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_3952 + 32] > !mem[_3952 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_3952 + 32] + mem[_3952 + 64] and 1 > -1 / mem[_3952 + 32] + mem[_3952 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_3952 + 32] + mem[_3952 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_3952 + 32] + mem[_3952 + 64]:
                        revert with 0, 17
                    if (mem[_3952 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3952 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3941 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_3952 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                    if mem[_3952 + 32] + mem[_3952 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_3952 + 32] + mem[_3952 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3941 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _976 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _3941 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_3952 + 32] + mem[_3952 + 64] and x * y > -1 / mem[_3952 + 32] + mem[_3952 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_3952 + 32] * x * y) + (mem[_3952 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_3952 + 32] * x * y) + (mem[_3952 + 64] * x * y):
                    revert with 0, 17
                if (mem[_3952 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_3952 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3941 = mem[96]
                idx = idx + 1
                s = s + ((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_3952 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_3952] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                if mem[_3952] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_3952]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18):
                    revert with 0, 17
                if mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_3952 + 32] > !mem[_3952 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_3952 + 32] + mem[_3952 + 64] and 1 > -1 / mem[_3952 + 32] + mem[_3952 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_3952 + 32] + mem[_3952 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_3952 + 32] + mem[_3952 + 64]:
                        revert with 0, 17
                    if (mem[_3952 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3952 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3941 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_3952 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                    if mem[_3952 + 32] + mem[_3952 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_3952 + 32] + mem[_3952 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3941 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _976 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _3941 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_3952 + 32] + mem[_3952 + 64] and x * y > -1 / mem[_3952 + 32] + mem[_3952 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_3952 + 32] * x * y) + (mem[_3952 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_3952 + 32] * x * y) + (mem[_3952 + 64] * x * y):
                    revert with 0, 17
                if (mem[_3952 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_3952 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3941 = mem[96]
                idx = idx + 1
                s = s + ((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_3952 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_3952] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            x = 10
            y = 1
            w = -mem[mem[(32 * idx) + _976 + 32]] + 18
            while w > 1:
                if x > -1 / x:
                    revert with 0, 17
                _3941 = mem[96]
                if not bool(w):
                    x = x * x
                    y = y
                    w = uint255(w) * 0.5
                    continue 
                x = x * x
                y = x * y
                w = uint255(w) * 0.5
                continue 
            if y > -1 / x:
                revert with 0, 17
            if mem[_3952] and x * y > -1 / mem[_3952]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                revert with 0, 50
            if mem[_3952] * x * y and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_3952] * x * y:
                revert with 0, 17
            if mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                revert with 0, 17
            if mem[_3952 + 32] > !mem[_3952 + 64]:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_3952 + 32] + mem[_3952 + 64] and 1 > -1 / mem[_3952 + 32] + mem[_3952 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_3952 + 32] + mem[_3952 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_3952 + 32] + mem[_3952 + 64]:
                    revert with 0, 17
                if (mem[_3952 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_3952 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3941 = mem[96]
                idx = idx + 1
                s = s + ((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_3952 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                if mem[_3952 + 32] + mem[_3952 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_3952 + 32] + mem[_3952 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                    revert with 0, 17
                if (mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3941 = mem[96]
                idx = idx + 1
                s = s + ((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_3952 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            z = 10
            a = 1
            w = -mem[mem[(32 * idx) + _976 + 32]] + 18
            while w > 1:
                if z > -1 / z:
                    revert with 0, 17
                _3941 = mem[96]
                if not bool(w):
                    z = z * z
                    a = a
                    w = uint255(w) * 0.5
                    continue 
                z = z * z
                a = z * a
                w = uint255(w) * 0.5
                continue 
            if a > -1 / z:
                revert with 0, 17
            if mem[_3952 + 32] + mem[_3952 + 64] and z * a > -1 / mem[_3952 + 32] + mem[_3952 + 64]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                revert with 0, 50
            if (mem[_3952 + 32] * z * a) + (mem[_3952 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_3952 + 32] * z * a) + (mem[_3952 + 64] * z * a):
                revert with 0, 17
            if (mem[_3952 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                revert with 0, 17
            if v > !((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if u > !((mem[_3952 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if (mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if s > !((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if (mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _3941 = mem[96]
            idx = idx + 1
            s = s + ((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
            t = t + ((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
            u = u + ((mem[_3952 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_3952 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
            v = v + ((mem[_3952] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
            continue 
        return v, u, t, s
    mem[64] = _976 + (32 * ('cd', 36).length) + 1184
    mem[_976 + (32 * ('cd', 36).length) + 896] = 0
    mem[_976 + (32 * ('cd', 36).length) + 928] = 0
    mem[_976 + (32 * ('cd', 36).length) + 960] = 0
    mem[_976 + (32 * ('cd', 36).length) + 992] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1024] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1056] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1088] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1120] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1152] = 0
    mem[var76002] = var76001
    if not var76003 - 1:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4379 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _4386 = mem[_4379]
            _4387 = mem[_4379 + 32]
            _4388 = mem[_4379 + 64]
            _4391 = mem[_4379 + 160]
            require mem[_4379 + 160] == bool(mem[_4379 + 160])
            _4410 = mem[_4379 + 192]
            require mem[_4379 + 192] == bool(mem[_4379 + 192])
            require mem[_4379 + 224] == bool(mem[_4379 + 224])
            _4433 = mem[_4379 + 256]
            require mem[_4379 + 256] == bool(mem[_4379 + 256])
            require mem[_4379 + 288] == bool(mem[_4379 + 288])
            if idx >= mem[_976]:
                revert with 0, 50
            _4446 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _4448 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _4450 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _4453 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _4457 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _4461 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 192] = bool(mem[_4379 + 288])
            mem[_4461 + 160] = bool(_4433)
            mem[_4457 + 128] = bool(_4410)
            mem[_4453 + 96] = bool(_4391)
            mem[_4450 + 64] = _4388
            mem[_4448 + 32] = _4387
            mem[_4446] = _4386
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4480 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _4495 = mem[_4480 + 32]
            _4496 = mem[_4480 + 64]
            require mem[_4480 + 288] == mem[_4480 + 315 len 5]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 224] = mem[_4480]
            if _4495 > !_4496:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 256] = _4495 + _4496
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _4724 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _4724:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4735 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_4735 + 224] == mem[_4735 + 251 len 5]
            require mem[_4735 + 256] == bool(mem[_4735 + 256])
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_4735] and 1 > -1 / mem[_4735]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_4735] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_4735]:
                    revert with 0, 17
                if mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_4735 + 32] > !mem[_4735 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_4735 + 32] + mem[_4735 + 64] and 1 > -1 / mem[_4735 + 32] + mem[_4735 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_4735 + 32] + mem[_4735 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_4735 + 32] + mem[_4735 + 64]:
                        revert with 0, 17
                    if (mem[_4735 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_4735 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _4724 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_4735 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                    if mem[_4735 + 32] + mem[_4735 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_4735 + 32] + mem[_4735 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _4724 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _976 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _4724 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_4735 + 32] + mem[_4735 + 64] and x * y > -1 / mem[_4735 + 32] + mem[_4735 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_4735 + 32] * x * y) + (mem[_4735 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_4735 + 32] * x * y) + (mem[_4735 + 64] * x * y):
                    revert with 0, 17
                if (mem[_4735 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_4735 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _4724 = mem[96]
                idx = idx + 1
                s = s + ((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_4735 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_4735] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                if mem[_4735] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_4735]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18):
                    revert with 0, 17
                if mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_4735 + 32] > !mem[_4735 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_4735 + 32] + mem[_4735 + 64] and 1 > -1 / mem[_4735 + 32] + mem[_4735 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_4735 + 32] + mem[_4735 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_4735 + 32] + mem[_4735 + 64]:
                        revert with 0, 17
                    if (mem[_4735 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_4735 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _4724 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_4735 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                    if mem[_4735 + 32] + mem[_4735 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_4735 + 32] + mem[_4735 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _4724 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _976 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _4724 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_4735 + 32] + mem[_4735 + 64] and x * y > -1 / mem[_4735 + 32] + mem[_4735 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_4735 + 32] * x * y) + (mem[_4735 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_4735 + 32] * x * y) + (mem[_4735 + 64] * x * y):
                    revert with 0, 17
                if (mem[_4735 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_4735 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _4724 = mem[96]
                idx = idx + 1
                s = s + ((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_4735 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_4735] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            x = 10
            y = 1
            w = -mem[mem[(32 * idx) + _976 + 32]] + 18
            while w > 1:
                if x > -1 / x:
                    revert with 0, 17
                _4724 = mem[96]
                if not bool(w):
                    x = x * x
                    y = y
                    w = uint255(w) * 0.5
                    continue 
                x = x * x
                y = x * y
                w = uint255(w) * 0.5
                continue 
            if y > -1 / x:
                revert with 0, 17
            if mem[_4735] and x * y > -1 / mem[_4735]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                revert with 0, 50
            if mem[_4735] * x * y and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_4735] * x * y:
                revert with 0, 17
            if mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                revert with 0, 17
            if mem[_4735 + 32] > !mem[_4735 + 64]:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_4735 + 32] + mem[_4735 + 64] and 1 > -1 / mem[_4735 + 32] + mem[_4735 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_4735 + 32] + mem[_4735 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_4735 + 32] + mem[_4735 + 64]:
                    revert with 0, 17
                if (mem[_4735 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_4735 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _4724 = mem[96]
                idx = idx + 1
                s = s + ((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_4735 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                if mem[_4735 + 32] + mem[_4735 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_4735 + 32] + mem[_4735 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                    revert with 0, 17
                if (mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _4724 = mem[96]
                idx = idx + 1
                s = s + ((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_4735 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            z = 10
            a = 1
            w = -mem[mem[(32 * idx) + _976 + 32]] + 18
            while w > 1:
                if z > -1 / z:
                    revert with 0, 17
                _4724 = mem[96]
                if not bool(w):
                    z = z * z
                    a = a
                    w = uint255(w) * 0.5
                    continue 
                z = z * z
                a = z * a
                w = uint255(w) * 0.5
                continue 
            if a > -1 / z:
                revert with 0, 17
            if mem[_4735 + 32] + mem[_4735 + 64] and z * a > -1 / mem[_4735 + 32] + mem[_4735 + 64]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                revert with 0, 50
            if (mem[_4735 + 32] * z * a) + (mem[_4735 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_4735 + 32] * z * a) + (mem[_4735 + 64] * z * a):
                revert with 0, 17
            if (mem[_4735 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                revert with 0, 17
            if v > !((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if u > !((mem[_4735 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if (mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if s > !((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if (mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _4724 = mem[96]
            idx = idx + 1
            s = s + ((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
            t = t + ((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
            u = u + ((mem[_4735 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_4735 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
            v = v + ((mem[_4735] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
            continue 
        return v, u, t, s
    mem[64] = _976 + (32 * ('cd', 36).length) + 1472
    mem[_976 + (32 * ('cd', 36).length) + 1184] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1216] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1248] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1280] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1312] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1344] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1376] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1408] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1440] = 0
    mem[var80002] = var80001
    if not var80003 - 1:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5162 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _5169 = mem[_5162]
            _5170 = mem[_5162 + 32]
            _5171 = mem[_5162 + 64]
            _5174 = mem[_5162 + 160]
            require mem[_5162 + 160] == bool(mem[_5162 + 160])
            _5193 = mem[_5162 + 192]
            require mem[_5162 + 192] == bool(mem[_5162 + 192])
            require mem[_5162 + 224] == bool(mem[_5162 + 224])
            _5216 = mem[_5162 + 256]
            require mem[_5162 + 256] == bool(mem[_5162 + 256])
            require mem[_5162 + 288] == bool(mem[_5162 + 288])
            if idx >= mem[_976]:
                revert with 0, 50
            _5229 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _5231 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _5233 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _5236 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _5240 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _5244 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 192] = bool(mem[_5162 + 288])
            mem[_5244 + 160] = bool(_5216)
            mem[_5240 + 128] = bool(_5193)
            mem[_5236 + 96] = bool(_5174)
            mem[_5233 + 64] = _5171
            mem[_5231 + 32] = _5170
            mem[_5229] = _5169
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5263 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _5278 = mem[_5263 + 32]
            _5279 = mem[_5263 + 64]
            require mem[_5263 + 288] == mem[_5263 + 315 len 5]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 224] = mem[_5263]
            if _5278 > !_5279:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 256] = _5278 + _5279
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _5507 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _5507:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5518 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_5518 + 224] == mem[_5518 + 251 len 5]
            require mem[_5518 + 256] == bool(mem[_5518 + 256])
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_5518] and 1 > -1 / mem[_5518]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_5518] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_5518]:
                    revert with 0, 17
                if mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_5518 + 32] > !mem[_5518 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_5518 + 32] + mem[_5518 + 64] and 1 > -1 / mem[_5518 + 32] + mem[_5518 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_5518 + 32] + mem[_5518 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_5518 + 32] + mem[_5518 + 64]:
                        revert with 0, 17
                    if (mem[_5518 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5518 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5507 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_5518 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                    if mem[_5518 + 32] + mem[_5518 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_5518 + 32] + mem[_5518 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5507 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _976 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _5507 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_5518 + 32] + mem[_5518 + 64] and x * y > -1 / mem[_5518 + 32] + mem[_5518 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_5518 + 32] * x * y) + (mem[_5518 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_5518 + 32] * x * y) + (mem[_5518 + 64] * x * y):
                    revert with 0, 17
                if (mem[_5518 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_5518 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5507 = mem[96]
                idx = idx + 1
                s = s + ((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_5518 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_5518] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                if mem[_5518] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_5518]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18):
                    revert with 0, 17
                if mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_5518 + 32] > !mem[_5518 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_5518 + 32] + mem[_5518 + 64] and 1 > -1 / mem[_5518 + 32] + mem[_5518 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_5518 + 32] + mem[_5518 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_5518 + 32] + mem[_5518 + 64]:
                        revert with 0, 17
                    if (mem[_5518 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5518 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5507 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_5518 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                    if mem[_5518 + 32] + mem[_5518 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_5518 + 32] + mem[_5518 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5507 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _976 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _5507 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_5518 + 32] + mem[_5518 + 64] and x * y > -1 / mem[_5518 + 32] + mem[_5518 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_5518 + 32] * x * y) + (mem[_5518 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_5518 + 32] * x * y) + (mem[_5518 + 64] * x * y):
                    revert with 0, 17
                if (mem[_5518 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_5518 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5507 = mem[96]
                idx = idx + 1
                s = s + ((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_5518 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_5518] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            x = 10
            y = 1
            w = -mem[mem[(32 * idx) + _976 + 32]] + 18
            while w > 1:
                if x > -1 / x:
                    revert with 0, 17
                _5507 = mem[96]
                if not bool(w):
                    x = x * x
                    y = y
                    w = uint255(w) * 0.5
                    continue 
                x = x * x
                y = x * y
                w = uint255(w) * 0.5
                continue 
            if y > -1 / x:
                revert with 0, 17
            if mem[_5518] and x * y > -1 / mem[_5518]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                revert with 0, 50
            if mem[_5518] * x * y and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_5518] * x * y:
                revert with 0, 17
            if mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                revert with 0, 17
            if mem[_5518 + 32] > !mem[_5518 + 64]:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_5518 + 32] + mem[_5518 + 64] and 1 > -1 / mem[_5518 + 32] + mem[_5518 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_5518 + 32] + mem[_5518 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_5518 + 32] + mem[_5518 + 64]:
                    revert with 0, 17
                if (mem[_5518 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_5518 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5507 = mem[96]
                idx = idx + 1
                s = s + ((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_5518 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                if mem[_5518 + 32] + mem[_5518 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_5518 + 32] + mem[_5518 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                    revert with 0, 17
                if (mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5507 = mem[96]
                idx = idx + 1
                s = s + ((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_5518 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            z = 10
            a = 1
            w = -mem[mem[(32 * idx) + _976 + 32]] + 18
            while w > 1:
                if z > -1 / z:
                    revert with 0, 17
                _5507 = mem[96]
                if not bool(w):
                    z = z * z
                    a = a
                    w = uint255(w) * 0.5
                    continue 
                z = z * z
                a = z * a
                w = uint255(w) * 0.5
                continue 
            if a > -1 / z:
                revert with 0, 17
            if mem[_5518 + 32] + mem[_5518 + 64] and z * a > -1 / mem[_5518 + 32] + mem[_5518 + 64]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                revert with 0, 50
            if (mem[_5518 + 32] * z * a) + (mem[_5518 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_5518 + 32] * z * a) + (mem[_5518 + 64] * z * a):
                revert with 0, 17
            if (mem[_5518 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                revert with 0, 17
            if v > !((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if u > !((mem[_5518 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if (mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if s > !((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if (mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _5507 = mem[96]
            idx = idx + 1
            s = s + ((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
            t = t + ((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
            u = u + ((mem[_5518 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_5518 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
            v = v + ((mem[_5518] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
            continue 
        return v, u, t, s
    mem[64] = _976 + (32 * ('cd', 36).length) + 1760
    mem[_976 + (32 * ('cd', 36).length) + 1472] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1504] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1536] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1568] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1600] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1632] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1664] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1696] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1728] = 0
    mem[var84002] = var84001
    if not var84003 - 1:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5945 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _5952 = mem[_5945]
            _5953 = mem[_5945 + 32]
            _5954 = mem[_5945 + 64]
            _5957 = mem[_5945 + 160]
            require mem[_5945 + 160] == bool(mem[_5945 + 160])
            _5976 = mem[_5945 + 192]
            require mem[_5945 + 192] == bool(mem[_5945 + 192])
            require mem[_5945 + 224] == bool(mem[_5945 + 224])
            _5999 = mem[_5945 + 256]
            require mem[_5945 + 256] == bool(mem[_5945 + 256])
            require mem[_5945 + 288] == bool(mem[_5945 + 288])
            if idx >= mem[_976]:
                revert with 0, 50
            _6012 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _6014 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _6016 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _6019 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _6023 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _6027 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 192] = bool(mem[_5945 + 288])
            mem[_6027 + 160] = bool(_5999)
            mem[_6023 + 128] = bool(_5976)
            mem[_6019 + 96] = bool(_5957)
            mem[_6016 + 64] = _5954
            mem[_6014 + 32] = _5953
            mem[_6012] = _5952
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6046 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _6061 = mem[_6046 + 32]
            _6062 = mem[_6046 + 64]
            require mem[_6046 + 288] == mem[_6046 + 315 len 5]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 224] = mem[_6046]
            if _6061 > !_6062:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 256] = _6061 + _6062
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _6290 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _6290:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6301 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_6301 + 224] == mem[_6301 + 251 len 5]
            require mem[_6301 + 256] == bool(mem[_6301 + 256])
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_6301] and 1 > -1 / mem[_6301]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_6301] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_6301]:
                    revert with 0, 17
                if mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_6301 + 32] > !mem[_6301 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_6301 + 32] + mem[_6301 + 64] and 1 > -1 / mem[_6301 + 32] + mem[_6301 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_6301 + 32] + mem[_6301 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_6301 + 32] + mem[_6301 + 64]:
                        revert with 0, 17
                    if (mem[_6301 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_6301 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6290 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_6301 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                    if mem[_6301 + 32] + mem[_6301 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_6301 + 32] + mem[_6301 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6290 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _976 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _6290 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_6301 + 32] + mem[_6301 + 64] and x * y > -1 / mem[_6301 + 32] + mem[_6301 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_6301 + 32] * x * y) + (mem[_6301 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_6301 + 32] * x * y) + (mem[_6301 + 64] * x * y):
                    revert with 0, 17
                if (mem[_6301 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_6301 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6290 = mem[96]
                idx = idx + 1
                s = s + ((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_6301 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_6301] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                if mem[_6301] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_6301]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18):
                    revert with 0, 17
                if mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_6301 + 32] > !mem[_6301 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_6301 + 32] + mem[_6301 + 64] and 1 > -1 / mem[_6301 + 32] + mem[_6301 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_6301 + 32] + mem[_6301 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_6301 + 32] + mem[_6301 + 64]:
                        revert with 0, 17
                    if (mem[_6301 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_6301 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6290 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_6301 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                    if mem[_6301 + 32] + mem[_6301 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_6301 + 32] + mem[_6301 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6290 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _976 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _6290 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_6301 + 32] + mem[_6301 + 64] and x * y > -1 / mem[_6301 + 32] + mem[_6301 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_6301 + 32] * x * y) + (mem[_6301 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_6301 + 32] * x * y) + (mem[_6301 + 64] * x * y):
                    revert with 0, 17
                if (mem[_6301 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_6301 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6290 = mem[96]
                idx = idx + 1
                s = s + ((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_6301 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_6301] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            x = 10
            y = 1
            w = -mem[mem[(32 * idx) + _976 + 32]] + 18
            while w > 1:
                if x > -1 / x:
                    revert with 0, 17
                _6290 = mem[96]
                if not bool(w):
                    x = x * x
                    y = y
                    w = uint255(w) * 0.5
                    continue 
                x = x * x
                y = x * y
                w = uint255(w) * 0.5
                continue 
            if y > -1 / x:
                revert with 0, 17
            if mem[_6301] and x * y > -1 / mem[_6301]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                revert with 0, 50
            if mem[_6301] * x * y and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_6301] * x * y:
                revert with 0, 17
            if mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                revert with 0, 17
            if mem[_6301 + 32] > !mem[_6301 + 64]:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_6301 + 32] + mem[_6301 + 64] and 1 > -1 / mem[_6301 + 32] + mem[_6301 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_6301 + 32] + mem[_6301 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_6301 + 32] + mem[_6301 + 64]:
                    revert with 0, 17
                if (mem[_6301 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_6301 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6290 = mem[96]
                idx = idx + 1
                s = s + ((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_6301 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32)):
                if mem[_6301 + 32] + mem[_6301 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_6301 + 32] + mem[_6301 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if (mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                    revert with 0, 17
                if (mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if (mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6290 = mem[96]
                idx = idx + 1
                s = s + ((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                t = t + ((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                u = u + ((mem[_6301 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                continue 
            z = 10
            a = 1
            w = -mem[mem[(32 * idx) + _976 + 32]] + 18
            while w > 1:
                if z > -1 / z:
                    revert with 0, 17
                _6290 = mem[96]
                if not bool(w):
                    z = z * z
                    a = a
                    w = uint255(w) * 0.5
                    continue 
                z = z * z
                a = z * a
                w = uint255(w) * 0.5
                continue 
            if a > -1 / z:
                revert with 0, 17
            if mem[_6301 + 32] + mem[_6301 + 64] and z * a > -1 / mem[_6301 + 32] + mem[_6301 + 64]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                revert with 0, 50
            if (mem[_6301 + 32] * z * a) + (mem[_6301 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_6301 + 32] * z * a) + (mem[_6301 + 64] * z * a):
                revert with 0, 17
            if (mem[_6301 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                revert with 0, 17
            if v > !((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if u > !((mem[_6301 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if (mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if s > !((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            if (mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _6290 = mem[96]
            idx = idx + 1
            s = s + ((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
            t = t + ((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
            u = u + ((mem[_6301 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_6301 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
            v = v + ((mem[_6301] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
            continue 
        return v, u, t, s
    mem[64] = _976 + (32 * ('cd', 36).length) + 2048
    mem[_976 + (32 * ('cd', 36).length) + 1760] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1792] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1824] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1856] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1888] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1920] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1952] = 0
    mem[_976 + (32 * ('cd', 36).length) + 1984] = 0
    mem[_976 + (32 * ('cd', 36).length) + 2016] = 0
    mem[var88002] = var88001
    if var88003 - 1:
        # nil
    else:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6728 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _6735 = mem[_6728]
            _6736 = mem[_6728 + 32]
            _6737 = mem[_6728 + 64]
            _6740 = mem[_6728 + 160]
            require mem[_6728 + 160] == bool(mem[_6728 + 160])
            _6759 = mem[_6728 + 192]
            require mem[_6728 + 192] == bool(mem[_6728 + 192])
            require mem[_6728 + 224] == bool(mem[_6728 + 224])
            _6782 = mem[_6728 + 256]
            require mem[_6728 + 256] == bool(mem[_6728 + 256])
            require mem[_6728 + 288] == bool(mem[_6728 + 288])
            if idx >= mem[_976]:
                revert with 0, 50
            _6795 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _6797 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _6799 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _6802 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _6806 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            _6810 = mem[(32 * idx) + _976 + 32]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 192] = bool(mem[_6728 + 288])
            mem[_6810 + 160] = bool(_6782)
            mem[_6806 + 128] = bool(_6759)
            mem[_6802 + 96] = bool(_6740)
            mem[_6799 + 64] = _6737
            mem[_6797 + 32] = _6736
            mem[_6795] = _6735
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6829 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _6844 = mem[_6829 + 32]
            _6845 = mem[_6829 + 64]
            require mem[_6829 + 288] == mem[_6829 + 315 len 5]
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 224] = mem[_6829]
            if _6844 > !_6845:
                revert with 0, 17
            if idx >= mem[_976]:
                revert with 0, 50
            mem[mem[(32 * idx) + _976 + 32] + 256] = _6844 + _6845
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _7073 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _7073:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7084 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_7084 + 224] == mem[_7084 + 251 len 5]
            require mem[_7084 + 256] == bool(mem[_7084 + 256])
            if idx >= mem[_976]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                if mem[_7084] and 1 > -1 / mem[_7084]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                    revert with 0, 50
                if mem[_7084] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_7084]:
                    revert with 0, 17
                if mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                    revert with 0, 17
                if mem[_7084 + 32] > !mem[_7084 + 64]:
                    revert with 0, 17
                if idx >= mem[_976]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                    if mem[_7084 + 32] + mem[_7084 + 64] and 1 > -1 / mem[_7084 + 32] + mem[_7084 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_7084 + 32] + mem[_7084 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_7084 + 32] + mem[_7084 + 64]:
                        revert with 0, 17
                    if (mem[_7084 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_7084 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_7084 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_7084 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7073 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_7084 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_7084 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
                if not bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78) and not bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32):
                    # nil
                else:
                    if mem[_7084 + 32] + mem[_7084 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_7084 + 32] + mem[_7084 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if (mem[_7084 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_7084 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_7084 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_7084 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_7084 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_7084 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_7084 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_7084 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if (mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7073 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                    t = t + ((mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                    u = u + ((mem[_7084 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_7084 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_7084] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                    continue 
            else:
                if not bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78) and not bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32):
                    # nil
                else:
                    if mem[_7084] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_7084]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                        revert with 0, 50
                    if mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18):
                        revert with 0, 17
                    if mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -500000000000000001:
                        revert with 0, 17
                    if mem[_7084 + 32] > !mem[_7084 + 64]:
                        revert with 0, 17
                    if idx >= mem[_976]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _976 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _976 + 32]] + 18:
                        if mem[_7084 + 32] + mem[_7084 + 64] and 1 > -1 / mem[_7084 + 32] + mem[_7084 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                            revert with 0, 50
                        if mem[_7084 + 32] + mem[_7084 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / mem[_7084 + 32] + mem[_7084 + 64]:
                            revert with 0, 17
                        if (mem[_7084 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_7084 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_7084 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_7084 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_976]:
                            revert with 0, 50
                        if (mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_976]:
                            revert with 0, 50
                        if (mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _7073 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                        t = t + ((mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                        u = u + ((mem[_7084 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_7084 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                        continue 
                    if not bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 78) and not bool(-mem[mem[(32 * idx) + _976 + 32]] + 18 < 32):
                        # nil
                    else:
                        if mem[_7084 + 32] + mem[_7084 + 64] and 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) > -1 / mem[_7084 + 32] + mem[_7084 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 97]:
                            revert with 0, 50
                        if (mem[_7084 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_7084 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129] > -1 / (mem[_7084 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)) + (mem[_7084 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_7084 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_7084 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_7084 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_7084 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_976]:
                            revert with 0, 50
                        if (mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 64] > -1 / (mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_976]:
                            revert with 0, 50
                        if (mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _976 + 32] + 32] > -1 / (mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _7073 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 64] / 10000)
                        t = t + ((mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _976 + 32] + 32] / 10000)
                        u = u + ((mem[_7084 + 32] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + (mem[_7084 + 64] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_7084] * 10^(-mem[mem[(32 * idx) + _976 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 129]) + 5 * 10^17 / 10^18)
                        continue 
        return v, u, t, s
}

function sub_d4c40c0d(?) payable {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 97 < 96 or ceil32(32 * ('cd', 36).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = 128
    while idx < ('cd', 36).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[ceil32(32 * ('cd', 36).length) + 97] = 0
    mem[ceil32(32 * ('cd', 36).length) + 129] = 0
    mem[ceil32(32 * ('cd', 36).length) + 161] = 0
    mem[ceil32(32 * ('cd', 36).length) + 193] = 0
    mem[ceil32(32 * ('cd', 36).length) + 225] = 0
    mem[ceil32(32 * ('cd', 36).length) + 257] = 0
    mem[ceil32(32 * ('cd', 36).length) + 289] = 0
    mem[ceil32(32 * ('cd', 36).length) + 321] = 0
    mem[ceil32(32 * ('cd', 36).length) + 353] = 0
    require ext_code.size(sub_238f9b7aAddress)
    staticcall sub_238f9b7aAddress.getPriceOracle() with:
            gas gas_remaining wei
    mem[ceil32(32 * ('cd', 36).length) + 385] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 385] = 0x9d23d9f200000000000000000000000000000000000000000000000000000000
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 389] = 32
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 421] = ('cd', 36).length
    idx = 0
    s = 128
    t = ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 453
    while idx < ('cd', 36).length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getAssetsPrices(address[] rg1) with:
            gas gas_remaining wei
           args Array(len=('cd', 36).length, data=mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 453 len 32 * ('cd', 36).length])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 385 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385
    require return_data.size >= 32
    _775 = mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 385 len 4], 0
    require mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 385 len 4], 0 <= test266151307()
    require ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + return_data.size + 385 > ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 385 len 4], 0 + 416
    _776 = mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 385 len 4], 0 + 385]
    if mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 385 len 4], 0 + 385] > test266151307():
        revert with 0, 65
    if ceil32(32 * mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 385 len 4], 0 + 385]) + 1 < 0 or ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 385 len 4], 0 + 385]) + 386 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + 385 len 4], 0 + 385]) + 386
    mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385] = _776
    require _775 + (32 * _776) + 32 <= return_data.size
    mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417 len 32 * _776] = mem[ceil32(32 * ('cd', 36).length) + ceil32(return_data.size) + _775 + 417 len 32 * _776]
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    _1152 = mem[64]
    mem[mem[64]] = ('cd', 36).length
    mem[64] = mem[64] + (32 * ('cd', 36).length) + 32
    if not ('cd', 36).length:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1532 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1537 = mem[_1532]
            _1538 = mem[_1532 + 32]
            _1539 = mem[_1532 + 64]
            _1542 = mem[_1532 + 160]
            require mem[_1532 + 160] == bool(mem[_1532 + 160])
            _1557 = mem[_1532 + 192]
            require mem[_1532 + 192] == bool(mem[_1532 + 192])
            require mem[_1532 + 224] == bool(mem[_1532 + 224])
            _1581 = mem[_1532 + 256]
            require mem[_1532 + 256] == bool(mem[_1532 + 256])
            require mem[_1532 + 288] == bool(mem[_1532 + 288])
            if idx >= mem[_1152]:
                revert with 0, 50
            _1599 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _1603 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _1605 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _1607 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _1610 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _1614 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 192] = bool(mem[_1532 + 288])
            mem[_1614 + 160] = bool(_1581)
            mem[_1610 + 128] = bool(_1557)
            mem[_1607 + 96] = bool(_1542)
            mem[_1605 + 64] = _1539
            mem[_1603 + 32] = _1538
            mem[_1599] = _1537
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1636 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _1644 = mem[_1636 + 32]
            _1645 = mem[_1636 + 64]
            require mem[_1636 + 288] == mem[_1636 + 315 len 5]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 224] = mem[_1636]
            if _1644 > !_1645:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 256] = _1644 + _1645
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _1892 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _1892:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1899 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_1899 + 224] == mem[_1899 + 251 len 5]
            require mem[_1899 + 256] == bool(mem[_1899 + 256])
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_1899] and 1 > -1 / mem[_1899]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_1899] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_1899]:
                    revert with 0, 17
                if mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_1899 + 32] > !mem[_1899 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_1899 + 32] + mem[_1899 + 64] and 1 > -1 / mem[_1899 + 32] + mem[_1899 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_1899 + 32] + mem[_1899 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_1899 + 32] + mem[_1899 + 64]:
                        revert with 0, 17
                    if (mem[_1899 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_1899 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _1892 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_1899 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                    if mem[_1899 + 32] + mem[_1899 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_1899 + 32] + mem[_1899 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _1892 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _1892 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_1899 + 32] + mem[_1899 + 64] and x * y > -1 / mem[_1899 + 32] + mem[_1899 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_1899 + 32] * x * y) + (mem[_1899 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_1899 + 32] * x * y) + (mem[_1899 + 64] * x * y):
                    revert with 0, 17
                if (mem[_1899 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_1899 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _1892 = mem[96]
                idx = idx + 1
                s = s + ((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_1899 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_1899] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                if mem[_1899] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_1899]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18):
                    revert with 0, 17
                if mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_1899 + 32] > !mem[_1899 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_1899 + 32] + mem[_1899 + 64] and 1 > -1 / mem[_1899 + 32] + mem[_1899 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_1899 + 32] + mem[_1899 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_1899 + 32] + mem[_1899 + 64]:
                        revert with 0, 17
                    if (mem[_1899 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_1899 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _1892 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_1899 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                    if mem[_1899 + 32] + mem[_1899 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_1899 + 32] + mem[_1899 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _1892 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _1892 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_1899 + 32] + mem[_1899 + 64] and x * y > -1 / mem[_1899 + 32] + mem[_1899 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_1899 + 32] * x * y) + (mem[_1899 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_1899 + 32] * x * y) + (mem[_1899 + 64] * x * y):
                    revert with 0, 17
                if (mem[_1899 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_1899 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _1892 = mem[96]
                idx = idx + 1
                s = s + ((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_1899 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_1899] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            x = 10
            y = 1
            w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
            while w > 1:
                if x > -1 / x:
                    revert with 0, 17
                _1892 = mem[96]
                if not bool(w):
                    x = x * x
                    y = y
                    w = uint255(w) * 0.5
                    continue 
                x = x * x
                y = x * y
                w = uint255(w) * 0.5
                continue 
            if y > -1 / x:
                revert with 0, 17
            if mem[_1899] and x * y > -1 / mem[_1899]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                revert with 0, 50
            if mem[_1899] * x * y and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_1899] * x * y:
                revert with 0, 17
            if mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                revert with 0, 17
            if mem[_1899 + 32] > !mem[_1899 + 64]:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_1899 + 32] + mem[_1899 + 64] and 1 > -1 / mem[_1899 + 32] + mem[_1899 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_1899 + 32] + mem[_1899 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_1899 + 32] + mem[_1899 + 64]:
                    revert with 0, 17
                if (mem[_1899 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_1899 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _1892 = mem[96]
                idx = idx + 1
                s = s + ((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_1899 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                if mem[_1899 + 32] + mem[_1899 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_1899 + 32] + mem[_1899 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                    revert with 0, 17
                if (mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _1892 = mem[96]
                idx = idx + 1
                s = s + ((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_1899 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            z = 10
            a = 1
            w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
            while w > 1:
                if z > -1 / z:
                    revert with 0, 17
                _1892 = mem[96]
                if not bool(w):
                    z = z * z
                    a = a
                    w = uint255(w) * 0.5
                    continue 
                z = z * z
                a = z * a
                w = uint255(w) * 0.5
                continue 
            if a > -1 / z:
                revert with 0, 17
            if mem[_1899 + 32] + mem[_1899 + 64] and z * a > -1 / mem[_1899 + 32] + mem[_1899 + 64]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                revert with 0, 50
            if (mem[_1899 + 32] * z * a) + (mem[_1899 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_1899 + 32] * z * a) + (mem[_1899 + 64] * z * a):
                revert with 0, 17
            if (mem[_1899 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                revert with 0, 17
            if v > !((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if u > !((mem[_1899 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if (mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if s > !((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if (mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _1892 = mem[96]
            idx = idx + 1
            s = s + ((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
            t = t + ((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
            u = u + ((mem[_1899 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_1899 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
            v = v + ((mem[_1899] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
            continue 
        mem[ceil32(32 * ('cd', 36).length) + 289] = v
        if u > !cd[100]:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 321] = u + cd[100]
        if not v:
            if 10^18 < cd[68]:
                revert with 0, 17
            if v and -cd[68] + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (cd[68] * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 36).length) + 129]
            mem[mem[64] + 64] = mem[ceil32(32 * ('cd', 36).length) + 161]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 36).length) + 193]
            mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
            mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + cd[100]
            mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
            return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
                   mem[mem[64] + 32 len 160],
                   v,
                   u + cd[100],
                   mem[mem[64] + 256]
        if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 161] = 10000 * t / v
        if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 193] = 10000 * s / v
        if u + cd[100] > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 129] = (10000 * u) + (10000 * cd[100]) / v
        if 10^18 < cd[68]:
            revert with 0, 17
        if v and -cd[68] + 10^18 > -1 / v:
            revert with 0, 17
        if (10^18 * v) - (cd[68] * v) > -500000000000000001:
            revert with 0, 17
        if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64] + 32] = (10000 * u) + (10000 * cd[100]) / v
        mem[mem[64] + 64] = 10000 * t / v
        mem[mem[64] + 96] = 10000 * s / v
        mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
        mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
        mem[mem[64] + 192] = v
        mem[mem[64] + 224] = u + cd[100]
        mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
        return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
               (10000 * u) + (10000 * cd[100]) / v,
               10000 * t / v,
               10000 * s / v,
               mem[mem[64] + 128 len 64],
               v,
               u + cd[100],
               mem[mem[64] + 256]
    mem[64] = _1152 + (32 * ('cd', 36).length) + 320
    mem[_1152 + (32 * ('cd', 36).length) + 32] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 64] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 96] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 128] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 160] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 192] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 224] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 256] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 288] = 0
    mem[var67002] = var67001
    if not var67003 - 1:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2408 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2414 = mem[_2408]
            _2415 = mem[_2408 + 32]
            _2416 = mem[_2408 + 64]
            _2419 = mem[_2408 + 160]
            require mem[_2408 + 160] == bool(mem[_2408 + 160])
            _2439 = mem[_2408 + 192]
            require mem[_2408 + 192] == bool(mem[_2408 + 192])
            require mem[_2408 + 224] == bool(mem[_2408 + 224])
            _2463 = mem[_2408 + 256]
            require mem[_2408 + 256] == bool(mem[_2408 + 256])
            require mem[_2408 + 288] == bool(mem[_2408 + 288])
            if idx >= mem[_1152]:
                revert with 0, 50
            _2480 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _2484 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _2486 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _2489 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _2493 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _2499 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 192] = bool(mem[_2408 + 288])
            mem[_2499 + 160] = bool(_2463)
            mem[_2493 + 128] = bool(_2439)
            mem[_2489 + 96] = bool(_2419)
            mem[_2486 + 64] = _2416
            mem[_2484 + 32] = _2415
            mem[_2480] = _2414
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2521 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _2537 = mem[_2521 + 32]
            _2538 = mem[_2521 + 64]
            require mem[_2521 + 288] == mem[_2521 + 315 len 5]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 224] = mem[_2521]
            if _2537 > !_2538:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 256] = _2537 + _2538
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _2812 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _2812:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2821 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_2821 + 224] == mem[_2821 + 251 len 5]
            require mem[_2821 + 256] == bool(mem[_2821 + 256])
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_2821] and 1 > -1 / mem[_2821]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_2821] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_2821]:
                    revert with 0, 17
                if mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_2821 + 32] > !mem[_2821 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_2821 + 32] + mem[_2821 + 64] and 1 > -1 / mem[_2821 + 32] + mem[_2821 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_2821 + 32] + mem[_2821 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_2821 + 32] + mem[_2821 + 64]:
                        revert with 0, 17
                    if (mem[_2821 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_2821 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2812 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_2821 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                    if mem[_2821 + 32] + mem[_2821 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_2821 + 32] + mem[_2821 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2812 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _2812 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_2821 + 32] + mem[_2821 + 64] and x * y > -1 / mem[_2821 + 32] + mem[_2821 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_2821 + 32] * x * y) + (mem[_2821 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_2821 + 32] * x * y) + (mem[_2821 + 64] * x * y):
                    revert with 0, 17
                if (mem[_2821 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_2821 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2812 = mem[96]
                idx = idx + 1
                s = s + ((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_2821 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_2821] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                if mem[_2821] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_2821]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18):
                    revert with 0, 17
                if mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_2821 + 32] > !mem[_2821 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_2821 + 32] + mem[_2821 + 64] and 1 > -1 / mem[_2821 + 32] + mem[_2821 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_2821 + 32] + mem[_2821 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_2821 + 32] + mem[_2821 + 64]:
                        revert with 0, 17
                    if (mem[_2821 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_2821 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2812 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_2821 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                    if mem[_2821 + 32] + mem[_2821 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_2821 + 32] + mem[_2821 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _2812 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _2812 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_2821 + 32] + mem[_2821 + 64] and x * y > -1 / mem[_2821 + 32] + mem[_2821 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_2821 + 32] * x * y) + (mem[_2821 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_2821 + 32] * x * y) + (mem[_2821 + 64] * x * y):
                    revert with 0, 17
                if (mem[_2821 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_2821 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2812 = mem[96]
                idx = idx + 1
                s = s + ((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_2821 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_2821] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            x = 10
            y = 1
            w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
            while w > 1:
                if x > -1 / x:
                    revert with 0, 17
                _2812 = mem[96]
                if not bool(w):
                    x = x * x
                    y = y
                    w = uint255(w) * 0.5
                    continue 
                x = x * x
                y = x * y
                w = uint255(w) * 0.5
                continue 
            if y > -1 / x:
                revert with 0, 17
            if mem[_2821] and x * y > -1 / mem[_2821]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                revert with 0, 50
            if mem[_2821] * x * y and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_2821] * x * y:
                revert with 0, 17
            if mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                revert with 0, 17
            if mem[_2821 + 32] > !mem[_2821 + 64]:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_2821 + 32] + mem[_2821 + 64] and 1 > -1 / mem[_2821 + 32] + mem[_2821 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_2821 + 32] + mem[_2821 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_2821 + 32] + mem[_2821 + 64]:
                    revert with 0, 17
                if (mem[_2821 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_2821 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2812 = mem[96]
                idx = idx + 1
                s = s + ((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_2821 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                if mem[_2821 + 32] + mem[_2821 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_2821 + 32] + mem[_2821 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                    revert with 0, 17
                if (mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _2812 = mem[96]
                idx = idx + 1
                s = s + ((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_2821 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            z = 10
            a = 1
            w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
            while w > 1:
                if z > -1 / z:
                    revert with 0, 17
                _2812 = mem[96]
                if not bool(w):
                    z = z * z
                    a = a
                    w = uint255(w) * 0.5
                    continue 
                z = z * z
                a = z * a
                w = uint255(w) * 0.5
                continue 
            if a > -1 / z:
                revert with 0, 17
            if mem[_2821 + 32] + mem[_2821 + 64] and z * a > -1 / mem[_2821 + 32] + mem[_2821 + 64]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                revert with 0, 50
            if (mem[_2821 + 32] * z * a) + (mem[_2821 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_2821 + 32] * z * a) + (mem[_2821 + 64] * z * a):
                revert with 0, 17
            if (mem[_2821 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                revert with 0, 17
            if v > !((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if u > !((mem[_2821 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if (mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if s > !((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if (mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _2812 = mem[96]
            idx = idx + 1
            s = s + ((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
            t = t + ((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
            u = u + ((mem[_2821 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_2821 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
            v = v + ((mem[_2821] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
            continue 
        mem[ceil32(32 * ('cd', 36).length) + 289] = v
        if u > !cd[100]:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 321] = u + cd[100]
        if not v:
            if 10^18 < cd[68]:
                revert with 0, 17
            if v and -cd[68] + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (cd[68] * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 36).length) + 129]
            mem[mem[64] + 64] = mem[ceil32(32 * ('cd', 36).length) + 161]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 36).length) + 193]
            mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
            mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + cd[100]
            mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
            return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
                   mem[mem[64] + 32 len 160],
                   v,
                   u + cd[100],
                   mem[mem[64] + 256]
        if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 161] = 10000 * t / v
        if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 193] = 10000 * s / v
        if u + cd[100] > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 129] = (10000 * u) + (10000 * cd[100]) / v
        if 10^18 < cd[68]:
            revert with 0, 17
        if v and -cd[68] + 10^18 > -1 / v:
            revert with 0, 17
        if (10^18 * v) - (cd[68] * v) > -500000000000000001:
            revert with 0, 17
        if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64] + 32] = (10000 * u) + (10000 * cd[100]) / v
        mem[mem[64] + 64] = 10000 * t / v
        mem[mem[64] + 96] = 10000 * s / v
        mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
        mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
        mem[mem[64] + 192] = v
        mem[mem[64] + 224] = u + cd[100]
        mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
        return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
               (10000 * u) + (10000 * cd[100]) / v,
               10000 * t / v,
               10000 * s / v,
               mem[mem[64] + 128 len 64],
               v,
               u + cd[100],
               mem[mem[64] + 256]
    mem[64] = _1152 + (32 * ('cd', 36).length) + 608
    mem[_1152 + (32 * ('cd', 36).length) + 320] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 352] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 384] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 416] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 448] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 480] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 512] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 544] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 576] = 0
    mem[var71002] = var71001
    if not var71003 - 1:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3336 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _3342 = mem[_3336]
            _3343 = mem[_3336 + 32]
            _3344 = mem[_3336 + 64]
            _3347 = mem[_3336 + 160]
            require mem[_3336 + 160] == bool(mem[_3336 + 160])
            _3364 = mem[_3336 + 192]
            require mem[_3336 + 192] == bool(mem[_3336 + 192])
            require mem[_3336 + 224] == bool(mem[_3336 + 224])
            _3391 = mem[_3336 + 256]
            require mem[_3336 + 256] == bool(mem[_3336 + 256])
            require mem[_3336 + 288] == bool(mem[_3336 + 288])
            if idx >= mem[_1152]:
                revert with 0, 50
            _3408 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _3412 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _3414 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _3417 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _3421 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _3427 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 192] = bool(mem[_3336 + 288])
            mem[_3427 + 160] = bool(_3391)
            mem[_3421 + 128] = bool(_3364)
            mem[_3417 + 96] = bool(_3347)
            mem[_3414 + 64] = _3344
            mem[_3412 + 32] = _3343
            mem[_3408] = _3342
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3447 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _3463 = mem[_3447 + 32]
            _3464 = mem[_3447 + 64]
            require mem[_3447 + 288] == mem[_3447 + 315 len 5]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 224] = mem[_3447]
            if _3463 > !_3464:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 256] = _3463 + _3464
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _3740 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _3740:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3749 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_3749 + 224] == mem[_3749 + 251 len 5]
            require mem[_3749 + 256] == bool(mem[_3749 + 256])
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_3749] and 1 > -1 / mem[_3749]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_3749] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_3749]:
                    revert with 0, 17
                if mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_3749 + 32] > !mem[_3749 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_3749 + 32] + mem[_3749 + 64] and 1 > -1 / mem[_3749 + 32] + mem[_3749 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_3749 + 32] + mem[_3749 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_3749 + 32] + mem[_3749 + 64]:
                        revert with 0, 17
                    if (mem[_3749 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3749 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3740 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_3749 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                    if mem[_3749 + 32] + mem[_3749 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_3749 + 32] + mem[_3749 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3740 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _3740 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_3749 + 32] + mem[_3749 + 64] and x * y > -1 / mem[_3749 + 32] + mem[_3749 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_3749 + 32] * x * y) + (mem[_3749 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_3749 + 32] * x * y) + (mem[_3749 + 64] * x * y):
                    revert with 0, 17
                if (mem[_3749 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_3749 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3740 = mem[96]
                idx = idx + 1
                s = s + ((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_3749 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_3749] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                if mem[_3749] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_3749]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18):
                    revert with 0, 17
                if mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_3749 + 32] > !mem[_3749 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_3749 + 32] + mem[_3749 + 64] and 1 > -1 / mem[_3749 + 32] + mem[_3749 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_3749 + 32] + mem[_3749 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_3749 + 32] + mem[_3749 + 64]:
                        revert with 0, 17
                    if (mem[_3749 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3749 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3740 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_3749 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                    if mem[_3749 + 32] + mem[_3749 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_3749 + 32] + mem[_3749 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3740 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _3740 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_3749 + 32] + mem[_3749 + 64] and x * y > -1 / mem[_3749 + 32] + mem[_3749 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_3749 + 32] * x * y) + (mem[_3749 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_3749 + 32] * x * y) + (mem[_3749 + 64] * x * y):
                    revert with 0, 17
                if (mem[_3749 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_3749 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3740 = mem[96]
                idx = idx + 1
                s = s + ((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_3749 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_3749] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            x = 10
            y = 1
            w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
            while w > 1:
                if x > -1 / x:
                    revert with 0, 17
                _3740 = mem[96]
                if not bool(w):
                    x = x * x
                    y = y
                    w = uint255(w) * 0.5
                    continue 
                x = x * x
                y = x * y
                w = uint255(w) * 0.5
                continue 
            if y > -1 / x:
                revert with 0, 17
            if mem[_3749] and x * y > -1 / mem[_3749]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                revert with 0, 50
            if mem[_3749] * x * y and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_3749] * x * y:
                revert with 0, 17
            if mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                revert with 0, 17
            if mem[_3749 + 32] > !mem[_3749 + 64]:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_3749 + 32] + mem[_3749 + 64] and 1 > -1 / mem[_3749 + 32] + mem[_3749 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_3749 + 32] + mem[_3749 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_3749 + 32] + mem[_3749 + 64]:
                    revert with 0, 17
                if (mem[_3749 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_3749 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3740 = mem[96]
                idx = idx + 1
                s = s + ((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_3749 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                if mem[_3749 + 32] + mem[_3749 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_3749 + 32] + mem[_3749 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                    revert with 0, 17
                if (mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3740 = mem[96]
                idx = idx + 1
                s = s + ((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_3749 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            z = 10
            a = 1
            w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
            while w > 1:
                if z > -1 / z:
                    revert with 0, 17
                _3740 = mem[96]
                if not bool(w):
                    z = z * z
                    a = a
                    w = uint255(w) * 0.5
                    continue 
                z = z * z
                a = z * a
                w = uint255(w) * 0.5
                continue 
            if a > -1 / z:
                revert with 0, 17
            if mem[_3749 + 32] + mem[_3749 + 64] and z * a > -1 / mem[_3749 + 32] + mem[_3749 + 64]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                revert with 0, 50
            if (mem[_3749 + 32] * z * a) + (mem[_3749 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_3749 + 32] * z * a) + (mem[_3749 + 64] * z * a):
                revert with 0, 17
            if (mem[_3749 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                revert with 0, 17
            if v > !((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if u > !((mem[_3749 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if (mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if s > !((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if (mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _3740 = mem[96]
            idx = idx + 1
            s = s + ((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
            t = t + ((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
            u = u + ((mem[_3749 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_3749 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
            v = v + ((mem[_3749] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
            continue 
        mem[ceil32(32 * ('cd', 36).length) + 289] = v
        if u > !cd[100]:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 321] = u + cd[100]
        if not v:
            if 10^18 < cd[68]:
                revert with 0, 17
            if v and -cd[68] + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (cd[68] * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 36).length) + 129]
            mem[mem[64] + 64] = mem[ceil32(32 * ('cd', 36).length) + 161]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 36).length) + 193]
            mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
            mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + cd[100]
            mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
            return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
                   mem[mem[64] + 32 len 160],
                   v,
                   u + cd[100],
                   mem[mem[64] + 256]
        if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 161] = 10000 * t / v
        if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 193] = 10000 * s / v
        if u + cd[100] > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 129] = (10000 * u) + (10000 * cd[100]) / v
        if 10^18 < cd[68]:
            revert with 0, 17
        if v and -cd[68] + 10^18 > -1 / v:
            revert with 0, 17
        if (10^18 * v) - (cd[68] * v) > -500000000000000001:
            revert with 0, 17
        if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64] + 32] = (10000 * u) + (10000 * cd[100]) / v
        mem[mem[64] + 64] = 10000 * t / v
        mem[mem[64] + 96] = 10000 * s / v
        mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
        mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
        mem[mem[64] + 192] = v
        mem[mem[64] + 224] = u + cd[100]
        mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
        return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
               (10000 * u) + (10000 * cd[100]) / v,
               10000 * t / v,
               10000 * s / v,
               mem[mem[64] + 128 len 64],
               v,
               u + cd[100],
               mem[mem[64] + 256]
    mem[64] = _1152 + (32 * ('cd', 36).length) + 896
    mem[_1152 + (32 * ('cd', 36).length) + 608] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 640] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 672] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 704] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 736] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 768] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 800] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 832] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 864] = 0
    mem[var75002] = var75001
    if not var75003 - 1:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4264 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _4270 = mem[_4264]
            _4271 = mem[_4264 + 32]
            _4272 = mem[_4264 + 64]
            _4275 = mem[_4264 + 160]
            require mem[_4264 + 160] == bool(mem[_4264 + 160])
            _4292 = mem[_4264 + 192]
            require mem[_4264 + 192] == bool(mem[_4264 + 192])
            require mem[_4264 + 224] == bool(mem[_4264 + 224])
            _4319 = mem[_4264 + 256]
            require mem[_4264 + 256] == bool(mem[_4264 + 256])
            require mem[_4264 + 288] == bool(mem[_4264 + 288])
            if idx >= mem[_1152]:
                revert with 0, 50
            _4336 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _4340 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _4342 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _4345 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _4349 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _4355 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 192] = bool(mem[_4264 + 288])
            mem[_4355 + 160] = bool(_4319)
            mem[_4349 + 128] = bool(_4292)
            mem[_4345 + 96] = bool(_4275)
            mem[_4342 + 64] = _4272
            mem[_4340 + 32] = _4271
            mem[_4336] = _4270
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4375 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _4391 = mem[_4375 + 32]
            _4392 = mem[_4375 + 64]
            require mem[_4375 + 288] == mem[_4375 + 315 len 5]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 224] = mem[_4375]
            if _4391 > !_4392:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 256] = _4391 + _4392
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _4668 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _4668:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _4677 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_4677 + 224] == mem[_4677 + 251 len 5]
            require mem[_4677 + 256] == bool(mem[_4677 + 256])
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_4677] and 1 > -1 / mem[_4677]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_4677] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_4677]:
                    revert with 0, 17
                if mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_4677 + 32] > !mem[_4677 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_4677 + 32] + mem[_4677 + 64] and 1 > -1 / mem[_4677 + 32] + mem[_4677 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_4677 + 32] + mem[_4677 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_4677 + 32] + mem[_4677 + 64]:
                        revert with 0, 17
                    if (mem[_4677 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_4677 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _4668 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_4677 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                    if mem[_4677 + 32] + mem[_4677 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_4677 + 32] + mem[_4677 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _4668 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _4668 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_4677 + 32] + mem[_4677 + 64] and x * y > -1 / mem[_4677 + 32] + mem[_4677 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_4677 + 32] * x * y) + (mem[_4677 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_4677 + 32] * x * y) + (mem[_4677 + 64] * x * y):
                    revert with 0, 17
                if (mem[_4677 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_4677 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _4668 = mem[96]
                idx = idx + 1
                s = s + ((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_4677 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_4677] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                if mem[_4677] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_4677]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18):
                    revert with 0, 17
                if mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_4677 + 32] > !mem[_4677 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_4677 + 32] + mem[_4677 + 64] and 1 > -1 / mem[_4677 + 32] + mem[_4677 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_4677 + 32] + mem[_4677 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_4677 + 32] + mem[_4677 + 64]:
                        revert with 0, 17
                    if (mem[_4677 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_4677 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _4668 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_4677 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                    if mem[_4677 + 32] + mem[_4677 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_4677 + 32] + mem[_4677 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _4668 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _4668 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_4677 + 32] + mem[_4677 + 64] and x * y > -1 / mem[_4677 + 32] + mem[_4677 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_4677 + 32] * x * y) + (mem[_4677 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_4677 + 32] * x * y) + (mem[_4677 + 64] * x * y):
                    revert with 0, 17
                if (mem[_4677 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_4677 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _4668 = mem[96]
                idx = idx + 1
                s = s + ((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_4677 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_4677] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            x = 10
            y = 1
            w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
            while w > 1:
                if x > -1 / x:
                    revert with 0, 17
                _4668 = mem[96]
                if not bool(w):
                    x = x * x
                    y = y
                    w = uint255(w) * 0.5
                    continue 
                x = x * x
                y = x * y
                w = uint255(w) * 0.5
                continue 
            if y > -1 / x:
                revert with 0, 17
            if mem[_4677] and x * y > -1 / mem[_4677]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                revert with 0, 50
            if mem[_4677] * x * y and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_4677] * x * y:
                revert with 0, 17
            if mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                revert with 0, 17
            if mem[_4677 + 32] > !mem[_4677 + 64]:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_4677 + 32] + mem[_4677 + 64] and 1 > -1 / mem[_4677 + 32] + mem[_4677 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_4677 + 32] + mem[_4677 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_4677 + 32] + mem[_4677 + 64]:
                    revert with 0, 17
                if (mem[_4677 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_4677 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _4668 = mem[96]
                idx = idx + 1
                s = s + ((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_4677 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                if mem[_4677 + 32] + mem[_4677 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_4677 + 32] + mem[_4677 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                    revert with 0, 17
                if (mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _4668 = mem[96]
                idx = idx + 1
                s = s + ((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_4677 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            z = 10
            a = 1
            w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
            while w > 1:
                if z > -1 / z:
                    revert with 0, 17
                _4668 = mem[96]
                if not bool(w):
                    z = z * z
                    a = a
                    w = uint255(w) * 0.5
                    continue 
                z = z * z
                a = z * a
                w = uint255(w) * 0.5
                continue 
            if a > -1 / z:
                revert with 0, 17
            if mem[_4677 + 32] + mem[_4677 + 64] and z * a > -1 / mem[_4677 + 32] + mem[_4677 + 64]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                revert with 0, 50
            if (mem[_4677 + 32] * z * a) + (mem[_4677 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_4677 + 32] * z * a) + (mem[_4677 + 64] * z * a):
                revert with 0, 17
            if (mem[_4677 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                revert with 0, 17
            if v > !((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if u > !((mem[_4677 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if (mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if s > !((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if (mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _4668 = mem[96]
            idx = idx + 1
            s = s + ((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
            t = t + ((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
            u = u + ((mem[_4677 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_4677 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
            v = v + ((mem[_4677] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
            continue 
        mem[ceil32(32 * ('cd', 36).length) + 289] = v
        if u > !cd[100]:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 321] = u + cd[100]
        if not v:
            if 10^18 < cd[68]:
                revert with 0, 17
            if v and -cd[68] + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (cd[68] * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 36).length) + 129]
            mem[mem[64] + 64] = mem[ceil32(32 * ('cd', 36).length) + 161]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 36).length) + 193]
            mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
            mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + cd[100]
            mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
            return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
                   mem[mem[64] + 32 len 160],
                   v,
                   u + cd[100],
                   mem[mem[64] + 256]
        if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 161] = 10000 * t / v
        if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 193] = 10000 * s / v
        if u + cd[100] > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 129] = (10000 * u) + (10000 * cd[100]) / v
        if 10^18 < cd[68]:
            revert with 0, 17
        if v and -cd[68] + 10^18 > -1 / v:
            revert with 0, 17
        if (10^18 * v) - (cd[68] * v) > -500000000000000001:
            revert with 0, 17
        if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64] + 32] = (10000 * u) + (10000 * cd[100]) / v
        mem[mem[64] + 64] = 10000 * t / v
        mem[mem[64] + 96] = 10000 * s / v
        mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
        mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
        mem[mem[64] + 192] = v
        mem[mem[64] + 224] = u + cd[100]
        mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
        return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
               (10000 * u) + (10000 * cd[100]) / v,
               10000 * t / v,
               10000 * s / v,
               mem[mem[64] + 128 len 64],
               v,
               u + cd[100],
               mem[mem[64] + 256]
    mem[64] = _1152 + (32 * ('cd', 36).length) + 1184
    mem[_1152 + (32 * ('cd', 36).length) + 896] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 928] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 960] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 992] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1024] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1056] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1088] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1120] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1152] = 0
    mem[var79002] = var79001
    if not var79003 - 1:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5192 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _5198 = mem[_5192]
            _5199 = mem[_5192 + 32]
            _5200 = mem[_5192 + 64]
            _5203 = mem[_5192 + 160]
            require mem[_5192 + 160] == bool(mem[_5192 + 160])
            _5220 = mem[_5192 + 192]
            require mem[_5192 + 192] == bool(mem[_5192 + 192])
            require mem[_5192 + 224] == bool(mem[_5192 + 224])
            _5247 = mem[_5192 + 256]
            require mem[_5192 + 256] == bool(mem[_5192 + 256])
            require mem[_5192 + 288] == bool(mem[_5192 + 288])
            if idx >= mem[_1152]:
                revert with 0, 50
            _5264 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _5268 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _5270 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _5273 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _5277 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _5283 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 192] = bool(mem[_5192 + 288])
            mem[_5283 + 160] = bool(_5247)
            mem[_5277 + 128] = bool(_5220)
            mem[_5273 + 96] = bool(_5203)
            mem[_5270 + 64] = _5200
            mem[_5268 + 32] = _5199
            mem[_5264] = _5198
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5303 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _5319 = mem[_5303 + 32]
            _5320 = mem[_5303 + 64]
            require mem[_5303 + 288] == mem[_5303 + 315 len 5]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 224] = mem[_5303]
            if _5319 > !_5320:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 256] = _5319 + _5320
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _5596 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _5596:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _5605 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_5605 + 224] == mem[_5605 + 251 len 5]
            require mem[_5605 + 256] == bool(mem[_5605 + 256])
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_5605] and 1 > -1 / mem[_5605]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_5605] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_5605]:
                    revert with 0, 17
                if mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_5605 + 32] > !mem[_5605 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_5605 + 32] + mem[_5605 + 64] and 1 > -1 / mem[_5605 + 32] + mem[_5605 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_5605 + 32] + mem[_5605 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_5605 + 32] + mem[_5605 + 64]:
                        revert with 0, 17
                    if (mem[_5605 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5605 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5596 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_5605 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                    if mem[_5605 + 32] + mem[_5605 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_5605 + 32] + mem[_5605 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5596 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _5596 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_5605 + 32] + mem[_5605 + 64] and x * y > -1 / mem[_5605 + 32] + mem[_5605 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_5605 + 32] * x * y) + (mem[_5605 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_5605 + 32] * x * y) + (mem[_5605 + 64] * x * y):
                    revert with 0, 17
                if (mem[_5605 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_5605 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5596 = mem[96]
                idx = idx + 1
                s = s + ((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_5605 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_5605] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                if mem[_5605] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_5605]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18):
                    revert with 0, 17
                if mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_5605 + 32] > !mem[_5605 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_5605 + 32] + mem[_5605 + 64] and 1 > -1 / mem[_5605 + 32] + mem[_5605 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_5605 + 32] + mem[_5605 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_5605 + 32] + mem[_5605 + 64]:
                        revert with 0, 17
                    if (mem[_5605 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5605 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5596 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_5605 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                    if mem[_5605 + 32] + mem[_5605 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_5605 + 32] + mem[_5605 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5596 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _5596 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_5605 + 32] + mem[_5605 + 64] and x * y > -1 / mem[_5605 + 32] + mem[_5605 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_5605 + 32] * x * y) + (mem[_5605 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_5605 + 32] * x * y) + (mem[_5605 + 64] * x * y):
                    revert with 0, 17
                if (mem[_5605 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_5605 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5596 = mem[96]
                idx = idx + 1
                s = s + ((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_5605 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_5605] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            x = 10
            y = 1
            w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
            while w > 1:
                if x > -1 / x:
                    revert with 0, 17
                _5596 = mem[96]
                if not bool(w):
                    x = x * x
                    y = y
                    w = uint255(w) * 0.5
                    continue 
                x = x * x
                y = x * y
                w = uint255(w) * 0.5
                continue 
            if y > -1 / x:
                revert with 0, 17
            if mem[_5605] and x * y > -1 / mem[_5605]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                revert with 0, 50
            if mem[_5605] * x * y and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_5605] * x * y:
                revert with 0, 17
            if mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                revert with 0, 17
            if mem[_5605 + 32] > !mem[_5605 + 64]:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_5605 + 32] + mem[_5605 + 64] and 1 > -1 / mem[_5605 + 32] + mem[_5605 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_5605 + 32] + mem[_5605 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_5605 + 32] + mem[_5605 + 64]:
                    revert with 0, 17
                if (mem[_5605 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_5605 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5596 = mem[96]
                idx = idx + 1
                s = s + ((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_5605 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                if mem[_5605 + 32] + mem[_5605 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_5605 + 32] + mem[_5605 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                    revert with 0, 17
                if (mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5596 = mem[96]
                idx = idx + 1
                s = s + ((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_5605 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            z = 10
            a = 1
            w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
            while w > 1:
                if z > -1 / z:
                    revert with 0, 17
                _5596 = mem[96]
                if not bool(w):
                    z = z * z
                    a = a
                    w = uint255(w) * 0.5
                    continue 
                z = z * z
                a = z * a
                w = uint255(w) * 0.5
                continue 
            if a > -1 / z:
                revert with 0, 17
            if mem[_5605 + 32] + mem[_5605 + 64] and z * a > -1 / mem[_5605 + 32] + mem[_5605 + 64]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                revert with 0, 50
            if (mem[_5605 + 32] * z * a) + (mem[_5605 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_5605 + 32] * z * a) + (mem[_5605 + 64] * z * a):
                revert with 0, 17
            if (mem[_5605 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                revert with 0, 17
            if v > !((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if u > !((mem[_5605 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if (mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if s > !((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if (mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _5596 = mem[96]
            idx = idx + 1
            s = s + ((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
            t = t + ((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
            u = u + ((mem[_5605 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_5605 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
            v = v + ((mem[_5605] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
            continue 
        mem[ceil32(32 * ('cd', 36).length) + 289] = v
        if u > !cd[100]:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 321] = u + cd[100]
        if not v:
            if 10^18 < cd[68]:
                revert with 0, 17
            if v and -cd[68] + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (cd[68] * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 36).length) + 129]
            mem[mem[64] + 64] = mem[ceil32(32 * ('cd', 36).length) + 161]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 36).length) + 193]
            mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
            mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + cd[100]
            mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
            return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
                   mem[mem[64] + 32 len 160],
                   v,
                   u + cd[100],
                   mem[mem[64] + 256]
        if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 161] = 10000 * t / v
        if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 193] = 10000 * s / v
        if u + cd[100] > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 129] = (10000 * u) + (10000 * cd[100]) / v
        if 10^18 < cd[68]:
            revert with 0, 17
        if v and -cd[68] + 10^18 > -1 / v:
            revert with 0, 17
        if (10^18 * v) - (cd[68] * v) > -500000000000000001:
            revert with 0, 17
        if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64] + 32] = (10000 * u) + (10000 * cd[100]) / v
        mem[mem[64] + 64] = 10000 * t / v
        mem[mem[64] + 96] = 10000 * s / v
        mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
        mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
        mem[mem[64] + 192] = v
        mem[mem[64] + 224] = u + cd[100]
        mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
        return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
               (10000 * u) + (10000 * cd[100]) / v,
               10000 * t / v,
               10000 * s / v,
               mem[mem[64] + 128 len 64],
               v,
               u + cd[100],
               mem[mem[64] + 256]
    mem[64] = _1152 + (32 * ('cd', 36).length) + 1472
    mem[_1152 + (32 * ('cd', 36).length) + 1184] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1216] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1248] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1280] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1312] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1344] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1376] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1408] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1440] = 0
    mem[var83002] = var83001
    if not var83003 - 1:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6120 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _6126 = mem[_6120]
            _6127 = mem[_6120 + 32]
            _6128 = mem[_6120 + 64]
            _6131 = mem[_6120 + 160]
            require mem[_6120 + 160] == bool(mem[_6120 + 160])
            _6148 = mem[_6120 + 192]
            require mem[_6120 + 192] == bool(mem[_6120 + 192])
            require mem[_6120 + 224] == bool(mem[_6120 + 224])
            _6175 = mem[_6120 + 256]
            require mem[_6120 + 256] == bool(mem[_6120 + 256])
            require mem[_6120 + 288] == bool(mem[_6120 + 288])
            if idx >= mem[_1152]:
                revert with 0, 50
            _6192 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _6196 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _6198 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _6201 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _6205 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _6211 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 192] = bool(mem[_6120 + 288])
            mem[_6211 + 160] = bool(_6175)
            mem[_6205 + 128] = bool(_6148)
            mem[_6201 + 96] = bool(_6131)
            mem[_6198 + 64] = _6128
            mem[_6196 + 32] = _6127
            mem[_6192] = _6126
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6231 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _6247 = mem[_6231 + 32]
            _6248 = mem[_6231 + 64]
            require mem[_6231 + 288] == mem[_6231 + 315 len 5]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 224] = mem[_6231]
            if _6247 > !_6248:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 256] = _6247 + _6248
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _6524 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _6524:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6533 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_6533 + 224] == mem[_6533 + 251 len 5]
            require mem[_6533 + 256] == bool(mem[_6533 + 256])
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_6533] and 1 > -1 / mem[_6533]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_6533] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_6533]:
                    revert with 0, 17
                if mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_6533 + 32] > !mem[_6533 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_6533 + 32] + mem[_6533 + 64] and 1 > -1 / mem[_6533 + 32] + mem[_6533 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_6533 + 32] + mem[_6533 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_6533 + 32] + mem[_6533 + 64]:
                        revert with 0, 17
                    if (mem[_6533 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_6533 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6524 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_6533 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                    if mem[_6533 + 32] + mem[_6533 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_6533 + 32] + mem[_6533 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6524 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _6524 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_6533 + 32] + mem[_6533 + 64] and x * y > -1 / mem[_6533 + 32] + mem[_6533 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_6533 + 32] * x * y) + (mem[_6533 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_6533 + 32] * x * y) + (mem[_6533 + 64] * x * y):
                    revert with 0, 17
                if (mem[_6533 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_6533 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6524 = mem[96]
                idx = idx + 1
                s = s + ((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_6533 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_6533] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                if mem[_6533] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_6533]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18):
                    revert with 0, 17
                if mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_6533 + 32] > !mem[_6533 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_6533 + 32] + mem[_6533 + 64] and 1 > -1 / mem[_6533 + 32] + mem[_6533 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_6533 + 32] + mem[_6533 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_6533 + 32] + mem[_6533 + 64]:
                        revert with 0, 17
                    if (mem[_6533 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_6533 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6524 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_6533 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                    if mem[_6533 + 32] + mem[_6533 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_6533 + 32] + mem[_6533 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _6524 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _6524 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_6533 + 32] + mem[_6533 + 64] and x * y > -1 / mem[_6533 + 32] + mem[_6533 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_6533 + 32] * x * y) + (mem[_6533 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_6533 + 32] * x * y) + (mem[_6533 + 64] * x * y):
                    revert with 0, 17
                if (mem[_6533 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_6533 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6524 = mem[96]
                idx = idx + 1
                s = s + ((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_6533 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_6533] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            x = 10
            y = 1
            w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
            while w > 1:
                if x > -1 / x:
                    revert with 0, 17
                _6524 = mem[96]
                if not bool(w):
                    x = x * x
                    y = y
                    w = uint255(w) * 0.5
                    continue 
                x = x * x
                y = x * y
                w = uint255(w) * 0.5
                continue 
            if y > -1 / x:
                revert with 0, 17
            if mem[_6533] and x * y > -1 / mem[_6533]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                revert with 0, 50
            if mem[_6533] * x * y and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_6533] * x * y:
                revert with 0, 17
            if mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                revert with 0, 17
            if mem[_6533 + 32] > !mem[_6533 + 64]:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_6533 + 32] + mem[_6533 + 64] and 1 > -1 / mem[_6533 + 32] + mem[_6533 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_6533 + 32] + mem[_6533 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_6533 + 32] + mem[_6533 + 64]:
                    revert with 0, 17
                if (mem[_6533 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_6533 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6524 = mem[96]
                idx = idx + 1
                s = s + ((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_6533 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                if mem[_6533 + 32] + mem[_6533 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_6533 + 32] + mem[_6533 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                    revert with 0, 17
                if (mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _6524 = mem[96]
                idx = idx + 1
                s = s + ((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_6533 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            z = 10
            a = 1
            w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
            while w > 1:
                if z > -1 / z:
                    revert with 0, 17
                _6524 = mem[96]
                if not bool(w):
                    z = z * z
                    a = a
                    w = uint255(w) * 0.5
                    continue 
                z = z * z
                a = z * a
                w = uint255(w) * 0.5
                continue 
            if a > -1 / z:
                revert with 0, 17
            if mem[_6533 + 32] + mem[_6533 + 64] and z * a > -1 / mem[_6533 + 32] + mem[_6533 + 64]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                revert with 0, 50
            if (mem[_6533 + 32] * z * a) + (mem[_6533 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_6533 + 32] * z * a) + (mem[_6533 + 64] * z * a):
                revert with 0, 17
            if (mem[_6533 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                revert with 0, 17
            if v > !((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if u > !((mem[_6533 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if (mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if s > !((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if (mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _6524 = mem[96]
            idx = idx + 1
            s = s + ((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
            t = t + ((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
            u = u + ((mem[_6533 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_6533 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
            v = v + ((mem[_6533] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
            continue 
        mem[ceil32(32 * ('cd', 36).length) + 289] = v
        if u > !cd[100]:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 321] = u + cd[100]
        if not v:
            if 10^18 < cd[68]:
                revert with 0, 17
            if v and -cd[68] + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (cd[68] * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 36).length) + 129]
            mem[mem[64] + 64] = mem[ceil32(32 * ('cd', 36).length) + 161]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 36).length) + 193]
            mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
            mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + cd[100]
            mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
            return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
                   mem[mem[64] + 32 len 160],
                   v,
                   u + cd[100],
                   mem[mem[64] + 256]
        if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 161] = 10000 * t / v
        if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 193] = 10000 * s / v
        if u + cd[100] > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 129] = (10000 * u) + (10000 * cd[100]) / v
        if 10^18 < cd[68]:
            revert with 0, 17
        if v and -cd[68] + 10^18 > -1 / v:
            revert with 0, 17
        if (10^18 * v) - (cd[68] * v) > -500000000000000001:
            revert with 0, 17
        if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64] + 32] = (10000 * u) + (10000 * cd[100]) / v
        mem[mem[64] + 64] = 10000 * t / v
        mem[mem[64] + 96] = 10000 * s / v
        mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
        mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
        mem[mem[64] + 192] = v
        mem[mem[64] + 224] = u + cd[100]
        mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
        return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
               (10000 * u) + (10000 * cd[100]) / v,
               10000 * t / v,
               10000 * s / v,
               mem[mem[64] + 128 len 64],
               v,
               u + cd[100],
               mem[mem[64] + 256]
    mem[64] = _1152 + (32 * ('cd', 36).length) + 1760
    mem[_1152 + (32 * ('cd', 36).length) + 1472] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1504] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1536] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1568] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1600] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1632] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1664] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1696] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1728] = 0
    mem[var87002] = var87001
    if not var87003 - 1:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7048 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _7054 = mem[_7048]
            _7055 = mem[_7048 + 32]
            _7056 = mem[_7048 + 64]
            _7059 = mem[_7048 + 160]
            require mem[_7048 + 160] == bool(mem[_7048 + 160])
            _7076 = mem[_7048 + 192]
            require mem[_7048 + 192] == bool(mem[_7048 + 192])
            require mem[_7048 + 224] == bool(mem[_7048 + 224])
            _7103 = mem[_7048 + 256]
            require mem[_7048 + 256] == bool(mem[_7048 + 256])
            require mem[_7048 + 288] == bool(mem[_7048 + 288])
            if idx >= mem[_1152]:
                revert with 0, 50
            _7120 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _7124 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _7126 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _7129 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _7133 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _7139 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 192] = bool(mem[_7048 + 288])
            mem[_7139 + 160] = bool(_7103)
            mem[_7133 + 128] = bool(_7076)
            mem[_7129 + 96] = bool(_7059)
            mem[_7126 + 64] = _7056
            mem[_7124 + 32] = _7055
            mem[_7120] = _7054
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7159 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _7175 = mem[_7159 + 32]
            _7176 = mem[_7159 + 64]
            require mem[_7159 + 288] == mem[_7159 + 315 len 5]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 224] = mem[_7159]
            if _7175 > !_7176:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 256] = _7175 + _7176
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _7452 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _7452:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7461 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_7461 + 224] == mem[_7461 + 251 len 5]
            require mem[_7461 + 256] == bool(mem[_7461 + 256])
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_7461] and 1 > -1 / mem[_7461]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_7461] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_7461]:
                    revert with 0, 17
                if mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_7461 + 32] > !mem[_7461 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_7461 + 32] + mem[_7461 + 64] and 1 > -1 / mem[_7461 + 32] + mem[_7461 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_7461 + 32] + mem[_7461 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_7461 + 32] + mem[_7461 + 64]:
                        revert with 0, 17
                    if (mem[_7461 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_7461 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7452 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_7461 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                    if mem[_7461 + 32] + mem[_7461 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_7461 + 32] + mem[_7461 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7452 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _7452 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_7461 + 32] + mem[_7461 + 64] and x * y > -1 / mem[_7461 + 32] + mem[_7461 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_7461 + 32] * x * y) + (mem[_7461 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_7461 + 32] * x * y) + (mem[_7461 + 64] * x * y):
                    revert with 0, 17
                if (mem[_7461 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_7461 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7452 = mem[96]
                idx = idx + 1
                s = s + ((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_7461 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_7461] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                if mem[_7461] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_7461]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18):
                    revert with 0, 17
                if mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_7461 + 32] > !mem[_7461 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_7461 + 32] + mem[_7461 + 64] and 1 > -1 / mem[_7461 + 32] + mem[_7461 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_7461 + 32] + mem[_7461 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_7461 + 32] + mem[_7461 + 64]:
                        revert with 0, 17
                    if (mem[_7461 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_7461 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7452 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_7461 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                    if mem[_7461 + 32] + mem[_7461 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_7461 + 32] + mem[_7461 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7452 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _7452 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_7461 + 32] + mem[_7461 + 64] and x * y > -1 / mem[_7461 + 32] + mem[_7461 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_7461 + 32] * x * y) + (mem[_7461 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_7461 + 32] * x * y) + (mem[_7461 + 64] * x * y):
                    revert with 0, 17
                if (mem[_7461 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_7461 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7452 = mem[96]
                idx = idx + 1
                s = s + ((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_7461 + 32] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_7461] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            x = 10
            y = 1
            w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
            while w > 1:
                if x > -1 / x:
                    revert with 0, 17
                _7452 = mem[96]
                if not bool(w):
                    x = x * x
                    y = y
                    w = uint255(w) * 0.5
                    continue 
                x = x * x
                y = x * y
                w = uint255(w) * 0.5
                continue 
            if y > -1 / x:
                revert with 0, 17
            if mem[_7461] and x * y > -1 / mem[_7461]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                revert with 0, 50
            if mem[_7461] * x * y and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_7461] * x * y:
                revert with 0, 17
            if mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                revert with 0, 17
            if mem[_7461 + 32] > !mem[_7461 + 64]:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_7461 + 32] + mem[_7461 + 64] and 1 > -1 / mem[_7461 + 32] + mem[_7461 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_7461 + 32] + mem[_7461 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_7461 + 32] + mem[_7461 + 64]:
                    revert with 0, 17
                if (mem[_7461 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_7461 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7452 = mem[96]
                idx = idx + 1
                s = s + ((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_7461 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            if bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32)):
                if mem[_7461 + 32] + mem[_7461 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_7461 + 32] + mem[_7461 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if (mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                    revert with 0, 17
                if (mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if (mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7452 = mem[96]
                idx = idx + 1
                s = s + ((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                t = t + ((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                u = u + ((mem[_7461 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                continue 
            z = 10
            a = 1
            w = -mem[mem[(32 * idx) + _1152 + 32]] + 18
            while w > 1:
                if z > -1 / z:
                    revert with 0, 17
                _7452 = mem[96]
                if not bool(w):
                    z = z * z
                    a = a
                    w = uint255(w) * 0.5
                    continue 
                z = z * z
                a = z * a
                w = uint255(w) * 0.5
                continue 
            if a > -1 / z:
                revert with 0, 17
            if mem[_7461 + 32] + mem[_7461 + 64] and z * a > -1 / mem[_7461 + 32] + mem[_7461 + 64]:
                revert with 0, 17
            if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                revert with 0, 50
            if (mem[_7461 + 32] * z * a) + (mem[_7461 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_7461 + 32] * z * a) + (mem[_7461 + 64] * z * a):
                revert with 0, 17
            if (mem[_7461 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                revert with 0, 17
            if v > !((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if u > !((mem[_7461 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if (mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if s > !((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            if (mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                revert with 0, 17
            if t > !((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            _7452 = mem[96]
            idx = idx + 1
            s = s + ((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
            t = t + ((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
            u = u + ((mem[_7461 + 32] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_7461 + 64] * z * a * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
            v = v + ((mem[_7461] * x * y * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
            continue 
        mem[ceil32(32 * ('cd', 36).length) + 289] = v
        if u > !cd[100]:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 321] = u + cd[100]
        if not v:
            if 10^18 < cd[68]:
                revert with 0, 17
            if v and -cd[68] + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (cd[68] * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 36).length) + 129]
            mem[mem[64] + 64] = mem[ceil32(32 * ('cd', 36).length) + 161]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 36).length) + 193]
            mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
            mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + cd[100]
            mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
            return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
                   mem[mem[64] + 32 len 160],
                   v,
                   u + cd[100],
                   mem[mem[64] + 256]
        if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 161] = 10000 * t / v
        if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 193] = 10000 * s / v
        if u + cd[100] > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 129] = (10000 * u) + (10000 * cd[100]) / v
        if 10^18 < cd[68]:
            revert with 0, 17
        if v and -cd[68] + 10^18 > -1 / v:
            revert with 0, 17
        if (10^18 * v) - (cd[68] * v) > -500000000000000001:
            revert with 0, 17
        if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64] + 32] = (10000 * u) + (10000 * cd[100]) / v
        mem[mem[64] + 64] = 10000 * t / v
        mem[mem[64] + 96] = 10000 * s / v
        mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
        mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
        mem[mem[64] + 192] = v
        mem[mem[64] + 224] = u + cd[100]
        mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
        return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
               (10000 * u) + (10000 * cd[100]) / v,
               10000 * t / v,
               10000 * s / v,
               mem[mem[64] + 128 len 64],
               v,
               u + cd[100],
               mem[mem[64] + 256]
    mem[64] = _1152 + (32 * ('cd', 36).length) + 2048
    mem[_1152 + (32 * ('cd', 36).length) + 1760] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1792] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1824] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1856] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1888] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1920] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1952] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 1984] = 0
    mem[_1152 + (32 * ('cd', 36).length) + 2016] = 0
    mem[var91002] = var91001
    if var91003 - 1:
        # nil
    else:
        idx = 0
        while idx < ('cd', 36).length:
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7976 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _7982 = mem[_7976]
            _7983 = mem[_7976 + 32]
            _7984 = mem[_7976 + 64]
            _7987 = mem[_7976 + 160]
            require mem[_7976 + 160] == bool(mem[_7976 + 160])
            _8004 = mem[_7976 + 192]
            require mem[_7976 + 192] == bool(mem[_7976 + 192])
            require mem[_7976 + 224] == bool(mem[_7976 + 224])
            _8031 = mem[_7976 + 256]
            require mem[_7976 + 256] == bool(mem[_7976 + 256])
            require mem[_7976 + 288] == bool(mem[_7976 + 288])
            if idx >= mem[_1152]:
                revert with 0, 50
            _8048 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _8052 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _8054 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _8057 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _8061 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            _8067 = mem[(32 * idx) + _1152 + 32]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 192] = bool(mem[_7976 + 288])
            mem[_8067 + 160] = bool(_8031)
            mem[_8061 + 128] = bool(_8004)
            mem[_8057 + 96] = bool(_7987)
            mem[_8054 + 64] = _7984
            mem[_8052 + 32] = _7983
            mem[_8048] = _7982
            if idx >= mem[96]:
                revert with 0, 50
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                    gas gas_remaining wei
                   args address(mem[(32 * idx) + 128])
            mem[mem[64] len 320] = ext_call.return_data[0 len 320]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _8087 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 320
            _8103 = mem[_8087 + 32]
            _8104 = mem[_8087 + 64]
            require mem[_8087 + 288] == mem[_8087 + 315 len 5]
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 224] = mem[_8087]
            if _8103 > !_8104:
                revert with 0, 17
            if idx >= mem[_1152]:
                revert with 0, 50
            mem[mem[(32 * idx) + _1152 + 32] + 256] = _8103 + _8104
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _8380 = mem[96]
        idx = 0
        s = 0
        t = 0
        u = 0
        v = 0
        while idx < _8380:
            if idx >= mem[96]:
                revert with 0, 50
            mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
            require ext_code.size(sub_5f9d4d2eAddress)
            staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], address(cd[4])
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _8389 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            require mem[_8389 + 224] == mem[_8389 + 251 len 5]
            require mem[_8389 + 256] == bool(mem[_8389 + 256])
            if idx >= mem[_1152]:
                revert with 0, 50
            if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                revert with 0, 17
            if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                if mem[_8389] and 1 > -1 / mem[_8389]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                    revert with 0, 50
                if mem[_8389] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_8389]:
                    revert with 0, 17
                if mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                    revert with 0, 17
                if mem[_8389 + 32] > !mem[_8389 + 64]:
                    revert with 0, 17
                if idx >= mem[_1152]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                    if mem[_8389 + 32] + mem[_8389 + 64] and 1 > -1 / mem[_8389 + 32] + mem[_8389 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_8389 + 32] + mem[_8389 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_8389 + 32] + mem[_8389 + 64]:
                        revert with 0, 17
                    if (mem[_8389 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_8389 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_8389 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_8389 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _8380 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_8389 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_8389 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
                if not bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78) and not bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32):
                    # nil
                else:
                    if mem[_8389 + 32] + mem[_8389 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_8389 + 32] + mem[_8389 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if (mem[_8389 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_8389 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_8389 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_8389 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_8389 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_8389 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_8389 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_8389 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if (mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _8380 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                    t = t + ((mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                    u = u + ((mem[_8389 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_8389 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_8389] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                    continue 
            else:
                if not bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78) and not bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32):
                    # nil
                else:
                    if mem[_8389] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_8389]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                        revert with 0, 50
                    if mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18):
                        revert with 0, 17
                    if mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -500000000000000001:
                        revert with 0, 17
                    if mem[_8389 + 32] > !mem[_8389 + 64]:
                        revert with 0, 17
                    if idx >= mem[_1152]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _1152 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _1152 + 32]] + 18:
                        if mem[_8389 + 32] + mem[_8389 + 64] and 1 > -1 / mem[_8389 + 32] + mem[_8389 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                            revert with 0, 50
                        if mem[_8389 + 32] + mem[_8389 + 64] and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / mem[_8389 + 32] + mem[_8389 + 64]:
                            revert with 0, 17
                        if (mem[_8389 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_8389 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_8389 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_8389 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_1152]:
                            revert with 0, 50
                        if (mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_1152]:
                            revert with 0, 50
                        if (mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _8380 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                        t = t + ((mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                        u = u + ((mem[_8389 + 32] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_8389 + 64] * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                        continue 
                    if not bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 78) and not bool(-mem[mem[(32 * idx) + _1152 + 32]] + 18 < 32):
                        # nil
                    else:
                        if mem[_8389 + 32] + mem[_8389 + 64] and 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) > -1 / mem[_8389 + 32] + mem[_8389 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 385]:
                            revert with 0, 50
                        if (mem[_8389 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_8389 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417] > -1 / (mem[_8389 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)) + (mem[_8389 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_8389 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_8389 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_8389 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_8389 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_1152]:
                            revert with 0, 50
                        if (mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 64] > -1 / (mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_1152]:
                            revert with 0, 50
                        if (mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _1152 + 32] + 32] > -1 / (mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _8380 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 64] / 10000)
                        t = t + ((mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _1152 + 32] + 32] / 10000)
                        u = u + ((mem[_8389 + 32] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + (mem[_8389 + 64] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_8389] * 10^(-mem[mem[(32 * idx) + _1152 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * ('cd', 36).length) + (2 * ceil32(return_data.size)) + 417]) + 5 * 10^17 / 10^18)
                        continue 
        mem[ceil32(32 * ('cd', 36).length) + 289] = v
        if u > !cd[100]:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 321] = u + cd[100]
        if not v:
            if 10^18 < cd[68]:
                revert with 0, 17
            if v and -cd[68] + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (cd[68] * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 36).length) + 129]
            mem[mem[64] + 64] = mem[ceil32(32 * ('cd', 36).length) + 161]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 36).length) + 193]
            mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
            mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + cd[100]
            mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
            return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
                   mem[mem[64] + 32 len 160],
                   v,
                   u + cd[100],
                   mem[mem[64] + 256]
        if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 161] = 10000 * t / v
        if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 193] = 10000 * s / v
        if u + cd[100] > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
            revert with 0, 17
        if not v:
            revert with 0, 18
        mem[ceil32(32 * ('cd', 36).length) + 129] = (10000 * u) + (10000 * cd[100]) / v
        if 10^18 < cd[68]:
            revert with 0, 17
        if v and -cd[68] + 10^18 > -1 / v:
            revert with 0, 17
        if (10^18 * v) - (cd[68] * v) > -500000000000000001:
            revert with 0, 17
        if s < (10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18:
            revert with 0, 17
        mem[ceil32(32 * ('cd', 36).length) + 97] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64]] = u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18)
        mem[mem[64] + 32] = (10000 * u) + (10000 * cd[100]) / v
        mem[mem[64] + 64] = 10000 * t / v
        mem[mem[64] + 96] = 10000 * s / v
        mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 36).length) + 225]
        mem[mem[64] + 160] = mem[ceil32(32 * ('cd', 36).length) + 257]
        mem[mem[64] + 192] = v
        mem[mem[64] + 224] = u + cd[100]
        mem[mem[64] + 256] = mem[ceil32(32 * ('cd', 36).length) + 353]
        return u + cd[100] < s - ((10^18 * v) + (-1 * cd[68] * v) + 5 * 10^17 / 10^18), 
               (10000 * u) + (10000 * cd[100]) / v,
               10000 * t / v,
               10000 * s / v,
               mem[mem[64] + 128 len 64],
               v,
               u + cd[100],
               mem[mem[64] + 256]
}

function checkLiquidity(address arg1, address[] arg2, uint256 arg3, uint256 arg4, uint256 arg5, bool arg6) payable {
    require calldata.size - 4 >= 192
    require arg1 == arg1
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg2.length) + 97 < 96 or ceil32(32 * arg2.length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg2.length
    require arg2 + (32 * arg2.length) + 36 <= calldata.size
    idx = 0
    s = arg2 + 36
    t = 128
    while idx < arg2.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg6 == arg6
    mem[ceil32(32 * arg2.length) + 129] = 0
    mem[ceil32(32 * arg2.length) + 161] = 0
    mem[ceil32(32 * arg2.length) + 193] = 0
    mem[ceil32(32 * arg2.length) + 289] = 0
    mem[ceil32(32 * arg2.length) + 321] = 0
    mem[ceil32(32 * arg2.length) + 353] = 0
    require ext_code.size(sub_238f9b7aAddress)
    staticcall sub_238f9b7aAddress.getLendingPool() with:
            gas gas_remaining wei
    mem[ceil32(32 * arg2.length) + 385] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(ext_call.return_data[12 len 20])
    staticcall ext_call.return_data[12 len 20].getUserAccountData(address rg1) with:
            gas gas_remaining wei
           args arg1
    mem[ceil32(32 * arg2.length) + ceil32(return_data.size) + 385 len 192] = ext_call.return_data[0 len 192]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 192
    if 1000000000000000000 * 10^18 > !(arg5 / 2):
        revert with 0, 17
    if not arg5:
        revert with 0, 18
    mem[ceil32(32 * arg2.length) + 257] = ext_call.return_data[128]
    mem[ceil32(32 * arg2.length) + 225] = ext_call.return_data[96]
    mem[ceil32(32 * arg2.length) + 97] = ext_call.return_data[160] > (arg5 / 2) + 1000000000000000000 * 10^18 / arg5
    if ext_call.return_data[160] <= (arg5 / 2) + 1000000000000000000 * 10^18 / arg5:
        return ext_call.return_data[160] > (arg5 / 2) + 1000000000000000000 * 10^18 / arg5, 
               0,
               0,
               0,
               ext_call.return_data[96],
               ext_call.return_data[128],
               0,
               0,
               0
    mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = 0
    mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = 0
    mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 0
    mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 0
    mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513] = 0
    mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545] = 0
    mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = 0
    mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = 0
    mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641] = 0
    require ext_code.size(sub_238f9b7aAddress)
    staticcall sub_238f9b7aAddress.getPriceOracle() with:
            gas gas_remaining wei
    mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 673] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673] = 0x9d23d9f200000000000000000000000000000000000000000000000000000000
    mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 677] = 32
    mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 709] = arg2.length
    idx = 0
    s = 128
    t = ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 741
    while idx < arg2.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).getAssetsPrices(address[] rg1) with:
            gas gas_remaining wei
           args Array(len=arg2.length, data=mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 741 len 32 * arg2.length])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673
    require return_data.size >= 32
    if arg6:
        _1306 = mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0
        require mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0 <= test266151307()
        require ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + return_data.size + 673 > ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0 + 704
        _1308 = mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0 + 673]
        if mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0 + 673] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0 + 673]) + 1 < 0 or ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0 + 673]) + 674 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0 + 673]) + 674
        mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673] = _1308
        require _1306 + (32 * _1308) + 32 <= return_data.size
        mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705 len 32 * _1308] = mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + _1306 + 705 len 32 * _1308]
        if arg2.length > test266151307():
            revert with 0, 65
        _2060 = mem[64]
        mem[mem[64]] = arg2.length
        mem[64] = mem[64] + (32 * arg2.length) + 32
        if not arg2.length:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2818 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _2830 = mem[_2818]
                _2831 = mem[_2818 + 32]
                _2832 = mem[_2818 + 64]
                _2835 = mem[_2818 + 160]
                require mem[_2818 + 160] == bool(mem[_2818 + 160])
                _2863 = mem[_2818 + 192]
                require mem[_2818 + 192] == bool(mem[_2818 + 192])
                require mem[_2818 + 224] == bool(mem[_2818 + 224])
                _2918 = mem[_2818 + 256]
                require mem[_2818 + 256] == bool(mem[_2818 + 256])
                require mem[_2818 + 288] == bool(mem[_2818 + 288])
                if idx >= mem[_2060]:
                    revert with 0, 50
                _2954 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _2960 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _2966 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _2970 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _2976 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _2984 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 192] = bool(mem[_2818 + 288])
                mem[_2984 + 160] = bool(_2918)
                mem[_2976 + 128] = bool(_2863)
                mem[_2970 + 96] = bool(_2835)
                mem[_2966 + 64] = _2832
                mem[_2960 + 32] = _2831
                mem[_2954] = _2830
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3028 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _3042 = mem[_3028 + 32]
                _3043 = mem[_3028 + 64]
                require mem[_3028 + 288] == mem[_3028 + 315 len 5]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 224] = mem[_3028]
                if _3042 > !_3043:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 256] = _3042 + _3043
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _3540 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _3540:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3554 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_3554 + 224] == mem[_3554 + 251 len 5]
                require mem[_3554 + 256] == bool(mem[_3554 + 256])
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_3554] and 1 > -1 / mem[_3554]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_3554] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_3554]:
                        revert with 0, 17
                    if mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_3554 + 32] > !mem[_3554 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_3554 + 32] + mem[_3554 + 64] and 1 > -1 / mem[_3554 + 32] + mem[_3554 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_3554 + 32] + mem[_3554 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_3554 + 32] + mem[_3554 + 64]:
                            revert with 0, 17
                        if (mem[_3554 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_3554 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3540 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_3554 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                        if mem[_3554 + 32] + mem[_3554 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_3554 + 32] + mem[_3554 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3540 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _3540 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_3554 + 32] + mem[_3554 + 64] and x * y > -1 / mem[_3554 + 32] + mem[_3554 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_3554 + 32] * x * y) + (mem[_3554 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_3554 + 32] * x * y) + (mem[_3554 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_3554 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3554 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3540 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_3554 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3554] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                    if mem[_3554] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_3554]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18):
                        revert with 0, 17
                    if mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_3554 + 32] > !mem[_3554 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_3554 + 32] + mem[_3554 + 64] and 1 > -1 / mem[_3554 + 32] + mem[_3554 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_3554 + 32] + mem[_3554 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_3554 + 32] + mem[_3554 + 64]:
                            revert with 0, 17
                        if (mem[_3554 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_3554 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3540 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_3554 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                        if mem[_3554 + 32] + mem[_3554 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_3554 + 32] + mem[_3554 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3540 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _3540 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_3554 + 32] + mem[_3554 + 64] and x * y > -1 / mem[_3554 + 32] + mem[_3554 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_3554 + 32] * x * y) + (mem[_3554 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_3554 + 32] * x * y) + (mem[_3554 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_3554 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3554 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3540 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_3554 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3554] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _3540 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_3554] and x * y > -1 / mem[_3554]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if mem[_3554] * x * y and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_3554] * x * y:
                    revert with 0, 17
                if mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                    revert with 0, 17
                if mem[_3554 + 32] > !mem[_3554 + 64]:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_3554 + 32] + mem[_3554 + 64] and 1 > -1 / mem[_3554 + 32] + mem[_3554 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_3554 + 32] + mem[_3554 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_3554 + 32] + mem[_3554 + 64]:
                        revert with 0, 17
                    if (mem[_3554 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3554 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3540 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_3554 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                    if mem[_3554 + 32] + mem[_3554 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_3554 + 32] + mem[_3554 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3540 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_3554 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                z = 10
                a = 1
                w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                while w > 1:
                    if z > -1 / z:
                        revert with 0, 17
                    _3540 = mem[96]
                    if not bool(w):
                        z = z * z
                        a = a
                        w = uint255(w) * 0.5
                        continue 
                    z = z * z
                    a = z * a
                    w = uint255(w) * 0.5
                    continue 
                if a > -1 / z:
                    revert with 0, 17
                if mem[_3554 + 32] + mem[_3554 + 64] and z * a > -1 / mem[_3554 + 32] + mem[_3554 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if (mem[_3554 + 32] * z * a) + (mem[_3554 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_3554 + 32] * z * a) + (mem[_3554 + 64] * z * a):
                    revert with 0, 17
                if (mem[_3554 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_3554 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if (mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if (mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3540 = mem[96]
                idx = idx + 1
                s = s + ((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                t = t + ((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                u = u + ((mem[_3554 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3554 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_3554] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg3:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg3
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg3
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg3,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg3 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg3) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg3) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg3
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg3) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg3,
                   mem[mem[64] + 256]
        mem[64] = _2060 + (32 * arg2.length) + 320
        mem[_2060 + (32 * arg2.length) + 32] = 0
        mem[_2060 + (32 * arg2.length) + 64] = 0
        mem[_2060 + (32 * arg2.length) + 96] = 0
        mem[_2060 + (32 * arg2.length) + 128] = 0
        mem[_2060 + (32 * arg2.length) + 160] = 0
        mem[_2060 + (32 * arg2.length) + 192] = 0
        mem[_2060 + (32 * arg2.length) + 224] = 0
        mem[_2060 + (32 * arg2.length) + 256] = 0
        mem[_2060 + (32 * arg2.length) + 288] = 0
        mem[var108002] = var108001
        if not var108003 - 1:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4569 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _4582 = mem[_4569]
                _4583 = mem[_4569 + 32]
                _4584 = mem[_4569 + 64]
                _4587 = mem[_4569 + 160]
                require mem[_4569 + 160] == bool(mem[_4569 + 160])
                _4623 = mem[_4569 + 192]
                require mem[_4569 + 192] == bool(mem[_4569 + 192])
                require mem[_4569 + 224] == bool(mem[_4569 + 224])
                _4681 = mem[_4569 + 256]
                require mem[_4569 + 256] == bool(mem[_4569 + 256])
                require mem[_4569 + 288] == bool(mem[_4569 + 288])
                if idx >= mem[_2060]:
                    revert with 0, 50
                _4716 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _4722 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _4728 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _4733 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _4740 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _4750 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 192] = bool(mem[_4569 + 288])
                mem[_4750 + 160] = bool(_4681)
                mem[_4740 + 128] = bool(_4623)
                mem[_4733 + 96] = bool(_4587)
                mem[_4728 + 64] = _4584
                mem[_4722 + 32] = _4583
                mem[_4716] = _4582
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4794 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _4823 = mem[_4794 + 32]
                _4824 = mem[_4794 + 64]
                require mem[_4794 + 288] == mem[_4794 + 315 len 5]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 224] = mem[_4794]
                if _4823 > !_4824:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 256] = _4823 + _4824
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _5380 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _5380:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5396 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_5396 + 224] == mem[_5396 + 251 len 5]
                require mem[_5396 + 256] == bool(mem[_5396 + 256])
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_5396] and 1 > -1 / mem[_5396]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_5396] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_5396]:
                        revert with 0, 17
                    if mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_5396 + 32] > !mem[_5396 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_5396 + 32] + mem[_5396 + 64] and 1 > -1 / mem[_5396 + 32] + mem[_5396 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_5396 + 32] + mem[_5396 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_5396 + 32] + mem[_5396 + 64]:
                            revert with 0, 17
                        if (mem[_5396 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_5396 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _5380 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_5396 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                        if mem[_5396 + 32] + mem[_5396 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_5396 + 32] + mem[_5396 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _5380 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _5380 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_5396 + 32] + mem[_5396 + 64] and x * y > -1 / mem[_5396 + 32] + mem[_5396 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_5396 + 32] * x * y) + (mem[_5396 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_5396 + 32] * x * y) + (mem[_5396 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_5396 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5396 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5380 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_5396 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5396] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                    if mem[_5396] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_5396]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18):
                        revert with 0, 17
                    if mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_5396 + 32] > !mem[_5396 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_5396 + 32] + mem[_5396 + 64] and 1 > -1 / mem[_5396 + 32] + mem[_5396 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_5396 + 32] + mem[_5396 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_5396 + 32] + mem[_5396 + 64]:
                            revert with 0, 17
                        if (mem[_5396 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_5396 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _5380 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_5396 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                        if mem[_5396 + 32] + mem[_5396 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_5396 + 32] + mem[_5396 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _5380 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _5380 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_5396 + 32] + mem[_5396 + 64] and x * y > -1 / mem[_5396 + 32] + mem[_5396 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_5396 + 32] * x * y) + (mem[_5396 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_5396 + 32] * x * y) + (mem[_5396 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_5396 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5396 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5380 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_5396 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5396] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _5380 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_5396] and x * y > -1 / mem[_5396]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if mem[_5396] * x * y and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_5396] * x * y:
                    revert with 0, 17
                if mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                    revert with 0, 17
                if mem[_5396 + 32] > !mem[_5396 + 64]:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_5396 + 32] + mem[_5396 + 64] and 1 > -1 / mem[_5396 + 32] + mem[_5396 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_5396 + 32] + mem[_5396 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_5396 + 32] + mem[_5396 + 64]:
                        revert with 0, 17
                    if (mem[_5396 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5396 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5380 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_5396 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                    if mem[_5396 + 32] + mem[_5396 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_5396 + 32] + mem[_5396 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5380 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_5396 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                z = 10
                a = 1
                w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                while w > 1:
                    if z > -1 / z:
                        revert with 0, 17
                    _5380 = mem[96]
                    if not bool(w):
                        z = z * z
                        a = a
                        w = uint255(w) * 0.5
                        continue 
                    z = z * z
                    a = z * a
                    w = uint255(w) * 0.5
                    continue 
                if a > -1 / z:
                    revert with 0, 17
                if mem[_5396 + 32] + mem[_5396 + 64] and z * a > -1 / mem[_5396 + 32] + mem[_5396 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if (mem[_5396 + 32] * z * a) + (mem[_5396 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_5396 + 32] * z * a) + (mem[_5396 + 64] * z * a):
                    revert with 0, 17
                if (mem[_5396 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_5396 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if (mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if (mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5380 = mem[96]
                idx = idx + 1
                s = s + ((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                t = t + ((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                u = u + ((mem[_5396 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5396 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_5396] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg3:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg3
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg3
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg3,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg3 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg3) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg3) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg3
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg3) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg3,
                   mem[mem[64] + 256]
        mem[64] = _2060 + (32 * arg2.length) + 608
        mem[_2060 + (32 * arg2.length) + 320] = 0
        mem[_2060 + (32 * arg2.length) + 352] = 0
        mem[_2060 + (32 * arg2.length) + 384] = 0
        mem[_2060 + (32 * arg2.length) + 416] = 0
        mem[_2060 + (32 * arg2.length) + 448] = 0
        mem[_2060 + (32 * arg2.length) + 480] = 0
        mem[_2060 + (32 * arg2.length) + 512] = 0
        mem[_2060 + (32 * arg2.length) + 544] = 0
        mem[_2060 + (32 * arg2.length) + 576] = 0
        mem[var112002] = var112001
        if not var112003 - 1:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6425 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _6438 = mem[_6425]
                _6439 = mem[_6425 + 32]
                _6440 = mem[_6425 + 64]
                _6443 = mem[_6425 + 160]
                require mem[_6425 + 160] == bool(mem[_6425 + 160])
                _6476 = mem[_6425 + 192]
                require mem[_6425 + 192] == bool(mem[_6425 + 192])
                require mem[_6425 + 224] == bool(mem[_6425 + 224])
                _6537 = mem[_6425 + 256]
                require mem[_6425 + 256] == bool(mem[_6425 + 256])
                require mem[_6425 + 288] == bool(mem[_6425 + 288])
                if idx >= mem[_2060]:
                    revert with 0, 50
                _6572 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _6578 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _6584 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _6589 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _6596 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _6606 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 192] = bool(mem[_6425 + 288])
                mem[_6606 + 160] = bool(_6537)
                mem[_6596 + 128] = bool(_6476)
                mem[_6589 + 96] = bool(_6443)
                mem[_6584 + 64] = _6440
                mem[_6578 + 32] = _6439
                mem[_6572] = _6438
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6648 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _6677 = mem[_6648 + 32]
                _6678 = mem[_6648 + 64]
                require mem[_6648 + 288] == mem[_6648 + 315 len 5]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 224] = mem[_6648]
                if _6677 > !_6678:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 256] = _6677 + _6678
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _7236 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _7236:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7252 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_7252 + 224] == mem[_7252 + 251 len 5]
                require mem[_7252 + 256] == bool(mem[_7252 + 256])
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_7252] and 1 > -1 / mem[_7252]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_7252] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_7252]:
                        revert with 0, 17
                    if mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_7252 + 32] > !mem[_7252 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_7252 + 32] + mem[_7252 + 64] and 1 > -1 / mem[_7252 + 32] + mem[_7252 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_7252 + 32] + mem[_7252 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_7252 + 32] + mem[_7252 + 64]:
                            revert with 0, 17
                        if (mem[_7252 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_7252 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _7236 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_7252 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                        if mem[_7252 + 32] + mem[_7252 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_7252 + 32] + mem[_7252 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _7236 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _7236 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_7252 + 32] + mem[_7252 + 64] and x * y > -1 / mem[_7252 + 32] + mem[_7252 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_7252 + 32] * x * y) + (mem[_7252 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_7252 + 32] * x * y) + (mem[_7252 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_7252 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_7252 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7236 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_7252 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_7252] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                    if mem[_7252] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_7252]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18):
                        revert with 0, 17
                    if mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_7252 + 32] > !mem[_7252 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_7252 + 32] + mem[_7252 + 64] and 1 > -1 / mem[_7252 + 32] + mem[_7252 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_7252 + 32] + mem[_7252 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_7252 + 32] + mem[_7252 + 64]:
                            revert with 0, 17
                        if (mem[_7252 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_7252 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _7236 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_7252 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                        if mem[_7252 + 32] + mem[_7252 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_7252 + 32] + mem[_7252 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _7236 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _7236 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_7252 + 32] + mem[_7252 + 64] and x * y > -1 / mem[_7252 + 32] + mem[_7252 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_7252 + 32] * x * y) + (mem[_7252 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_7252 + 32] * x * y) + (mem[_7252 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_7252 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_7252 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7236 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_7252 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_7252] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _7236 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_7252] and x * y > -1 / mem[_7252]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if mem[_7252] * x * y and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_7252] * x * y:
                    revert with 0, 17
                if mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                    revert with 0, 17
                if mem[_7252 + 32] > !mem[_7252 + 64]:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_7252 + 32] + mem[_7252 + 64] and 1 > -1 / mem[_7252 + 32] + mem[_7252 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_7252 + 32] + mem[_7252 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_7252 + 32] + mem[_7252 + 64]:
                        revert with 0, 17
                    if (mem[_7252 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_7252 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7236 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_7252 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                    if mem[_7252 + 32] + mem[_7252 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_7252 + 32] + mem[_7252 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7236 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_7252 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                z = 10
                a = 1
                w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                while w > 1:
                    if z > -1 / z:
                        revert with 0, 17
                    _7236 = mem[96]
                    if not bool(w):
                        z = z * z
                        a = a
                        w = uint255(w) * 0.5
                        continue 
                    z = z * z
                    a = z * a
                    w = uint255(w) * 0.5
                    continue 
                if a > -1 / z:
                    revert with 0, 17
                if mem[_7252 + 32] + mem[_7252 + 64] and z * a > -1 / mem[_7252 + 32] + mem[_7252 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if (mem[_7252 + 32] * z * a) + (mem[_7252 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_7252 + 32] * z * a) + (mem[_7252 + 64] * z * a):
                    revert with 0, 17
                if (mem[_7252 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_7252 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if (mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if (mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7236 = mem[96]
                idx = idx + 1
                s = s + ((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                t = t + ((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                u = u + ((mem[_7252 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7252 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_7252] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg3:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg3
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg3
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg3,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg3 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg3) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg3) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg3
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg3) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg3,
                   mem[mem[64] + 256]
        mem[64] = _2060 + (32 * arg2.length) + 896
        mem[_2060 + (32 * arg2.length) + 608] = 0
        mem[_2060 + (32 * arg2.length) + 640] = 0
        mem[_2060 + (32 * arg2.length) + 672] = 0
        mem[_2060 + (32 * arg2.length) + 704] = 0
        mem[_2060 + (32 * arg2.length) + 736] = 0
        mem[_2060 + (32 * arg2.length) + 768] = 0
        mem[_2060 + (32 * arg2.length) + 800] = 0
        mem[_2060 + (32 * arg2.length) + 832] = 0
        mem[_2060 + (32 * arg2.length) + 864] = 0
        mem[var116002] = var116001
        if not var116003 - 1:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8281 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _8294 = mem[_8281]
                _8295 = mem[_8281 + 32]
                _8296 = mem[_8281 + 64]
                _8299 = mem[_8281 + 160]
                require mem[_8281 + 160] == bool(mem[_8281 + 160])
                _8332 = mem[_8281 + 192]
                require mem[_8281 + 192] == bool(mem[_8281 + 192])
                require mem[_8281 + 224] == bool(mem[_8281 + 224])
                _8393 = mem[_8281 + 256]
                require mem[_8281 + 256] == bool(mem[_8281 + 256])
                require mem[_8281 + 288] == bool(mem[_8281 + 288])
                if idx >= mem[_2060]:
                    revert with 0, 50
                _8428 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _8434 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _8440 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _8445 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _8452 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _8462 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 192] = bool(mem[_8281 + 288])
                mem[_8462 + 160] = bool(_8393)
                mem[_8452 + 128] = bool(_8332)
                mem[_8445 + 96] = bool(_8299)
                mem[_8440 + 64] = _8296
                mem[_8434 + 32] = _8295
                mem[_8428] = _8294
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8504 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _8533 = mem[_8504 + 32]
                _8534 = mem[_8504 + 64]
                require mem[_8504 + 288] == mem[_8504 + 315 len 5]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 224] = mem[_8504]
                if _8533 > !_8534:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 256] = _8533 + _8534
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _9092 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _9092:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9108 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_9108 + 224] == mem[_9108 + 251 len 5]
                require mem[_9108 + 256] == bool(mem[_9108 + 256])
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_9108] and 1 > -1 / mem[_9108]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_9108] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_9108]:
                        revert with 0, 17
                    if mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_9108 + 32] > !mem[_9108 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_9108 + 32] + mem[_9108 + 64] and 1 > -1 / mem[_9108 + 32] + mem[_9108 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_9108 + 32] + mem[_9108 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_9108 + 32] + mem[_9108 + 64]:
                            revert with 0, 17
                        if (mem[_9108 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_9108 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _9092 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_9108 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                        if mem[_9108 + 32] + mem[_9108 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_9108 + 32] + mem[_9108 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _9092 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _9092 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_9108 + 32] + mem[_9108 + 64] and x * y > -1 / mem[_9108 + 32] + mem[_9108 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_9108 + 32] * x * y) + (mem[_9108 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_9108 + 32] * x * y) + (mem[_9108 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_9108 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_9108 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _9092 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_9108 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_9108] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                    if mem[_9108] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_9108]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18):
                        revert with 0, 17
                    if mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_9108 + 32] > !mem[_9108 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_9108 + 32] + mem[_9108 + 64] and 1 > -1 / mem[_9108 + 32] + mem[_9108 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_9108 + 32] + mem[_9108 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_9108 + 32] + mem[_9108 + 64]:
                            revert with 0, 17
                        if (mem[_9108 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_9108 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _9092 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_9108 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                        if mem[_9108 + 32] + mem[_9108 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_9108 + 32] + mem[_9108 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _9092 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _9092 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_9108 + 32] + mem[_9108 + 64] and x * y > -1 / mem[_9108 + 32] + mem[_9108 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_9108 + 32] * x * y) + (mem[_9108 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_9108 + 32] * x * y) + (mem[_9108 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_9108 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_9108 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _9092 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_9108 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_9108] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _9092 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_9108] and x * y > -1 / mem[_9108]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if mem[_9108] * x * y and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_9108] * x * y:
                    revert with 0, 17
                if mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                    revert with 0, 17
                if mem[_9108 + 32] > !mem[_9108 + 64]:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_9108 + 32] + mem[_9108 + 64] and 1 > -1 / mem[_9108 + 32] + mem[_9108 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_9108 + 32] + mem[_9108 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_9108 + 32] + mem[_9108 + 64]:
                        revert with 0, 17
                    if (mem[_9108 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_9108 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _9092 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_9108 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                    if mem[_9108 + 32] + mem[_9108 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_9108 + 32] + mem[_9108 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _9092 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_9108 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                z = 10
                a = 1
                w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                while w > 1:
                    if z > -1 / z:
                        revert with 0, 17
                    _9092 = mem[96]
                    if not bool(w):
                        z = z * z
                        a = a
                        w = uint255(w) * 0.5
                        continue 
                    z = z * z
                    a = z * a
                    w = uint255(w) * 0.5
                    continue 
                if a > -1 / z:
                    revert with 0, 17
                if mem[_9108 + 32] + mem[_9108 + 64] and z * a > -1 / mem[_9108 + 32] + mem[_9108 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if (mem[_9108 + 32] * z * a) + (mem[_9108 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_9108 + 32] * z * a) + (mem[_9108 + 64] * z * a):
                    revert with 0, 17
                if (mem[_9108 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_9108 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if (mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if (mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _9092 = mem[96]
                idx = idx + 1
                s = s + ((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                t = t + ((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                u = u + ((mem[_9108 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9108 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_9108] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg3:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg3
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg3
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg3,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg3 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg3) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg3) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg3
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg3) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg3,
                   mem[mem[64] + 256]
        mem[64] = _2060 + (32 * arg2.length) + 1184
        mem[_2060 + (32 * arg2.length) + 896] = 0
        mem[_2060 + (32 * arg2.length) + 928] = 0
        mem[_2060 + (32 * arg2.length) + 960] = 0
        mem[_2060 + (32 * arg2.length) + 992] = 0
        mem[_2060 + (32 * arg2.length) + 1024] = 0
        mem[_2060 + (32 * arg2.length) + 1056] = 0
        mem[_2060 + (32 * arg2.length) + 1088] = 0
        mem[_2060 + (32 * arg2.length) + 1120] = 0
        mem[_2060 + (32 * arg2.length) + 1152] = 0
        mem[var120002] = var120001
        if not var120003 - 1:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10137 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _10150 = mem[_10137]
                _10151 = mem[_10137 + 32]
                _10152 = mem[_10137 + 64]
                _10155 = mem[_10137 + 160]
                require mem[_10137 + 160] == bool(mem[_10137 + 160])
                _10188 = mem[_10137 + 192]
                require mem[_10137 + 192] == bool(mem[_10137 + 192])
                require mem[_10137 + 224] == bool(mem[_10137 + 224])
                _10249 = mem[_10137 + 256]
                require mem[_10137 + 256] == bool(mem[_10137 + 256])
                require mem[_10137 + 288] == bool(mem[_10137 + 288])
                if idx >= mem[_2060]:
                    revert with 0, 50
                _10284 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _10290 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _10296 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _10301 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _10308 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _10318 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 192] = bool(mem[_10137 + 288])
                mem[_10318 + 160] = bool(_10249)
                mem[_10308 + 128] = bool(_10188)
                mem[_10301 + 96] = bool(_10155)
                mem[_10296 + 64] = _10152
                mem[_10290 + 32] = _10151
                mem[_10284] = _10150
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10360 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _10389 = mem[_10360 + 32]
                _10390 = mem[_10360 + 64]
                require mem[_10360 + 288] == mem[_10360 + 315 len 5]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 224] = mem[_10360]
                if _10389 > !_10390:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 256] = _10389 + _10390
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _10948 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _10948:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10964 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_10964 + 224] == mem[_10964 + 251 len 5]
                require mem[_10964 + 256] == bool(mem[_10964 + 256])
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_10964] and 1 > -1 / mem[_10964]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_10964] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_10964]:
                        revert with 0, 17
                    if mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_10964 + 32] > !mem[_10964 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_10964 + 32] + mem[_10964 + 64] and 1 > -1 / mem[_10964 + 32] + mem[_10964 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_10964 + 32] + mem[_10964 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_10964 + 32] + mem[_10964 + 64]:
                            revert with 0, 17
                        if (mem[_10964 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_10964 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _10948 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_10964 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                        if mem[_10964 + 32] + mem[_10964 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_10964 + 32] + mem[_10964 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _10948 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _10948 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_10964 + 32] + mem[_10964 + 64] and x * y > -1 / mem[_10964 + 32] + mem[_10964 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_10964 + 32] * x * y) + (mem[_10964 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_10964 + 32] * x * y) + (mem[_10964 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_10964 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_10964 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _10948 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_10964 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_10964] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                    if mem[_10964] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_10964]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18):
                        revert with 0, 17
                    if mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_10964 + 32] > !mem[_10964 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_10964 + 32] + mem[_10964 + 64] and 1 > -1 / mem[_10964 + 32] + mem[_10964 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_10964 + 32] + mem[_10964 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_10964 + 32] + mem[_10964 + 64]:
                            revert with 0, 17
                        if (mem[_10964 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_10964 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _10948 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_10964 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                        if mem[_10964 + 32] + mem[_10964 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_10964 + 32] + mem[_10964 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _10948 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _10948 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_10964 + 32] + mem[_10964 + 64] and x * y > -1 / mem[_10964 + 32] + mem[_10964 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_10964 + 32] * x * y) + (mem[_10964 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_10964 + 32] * x * y) + (mem[_10964 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_10964 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_10964 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _10948 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_10964 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_10964] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _10948 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_10964] and x * y > -1 / mem[_10964]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if mem[_10964] * x * y and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_10964] * x * y:
                    revert with 0, 17
                if mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                    revert with 0, 17
                if mem[_10964 + 32] > !mem[_10964 + 64]:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_10964 + 32] + mem[_10964 + 64] and 1 > -1 / mem[_10964 + 32] + mem[_10964 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_10964 + 32] + mem[_10964 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_10964 + 32] + mem[_10964 + 64]:
                        revert with 0, 17
                    if (mem[_10964 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_10964 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _10948 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_10964 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                    if mem[_10964 + 32] + mem[_10964 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_10964 + 32] + mem[_10964 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _10948 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_10964 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                z = 10
                a = 1
                w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                while w > 1:
                    if z > -1 / z:
                        revert with 0, 17
                    _10948 = mem[96]
                    if not bool(w):
                        z = z * z
                        a = a
                        w = uint255(w) * 0.5
                        continue 
                    z = z * z
                    a = z * a
                    w = uint255(w) * 0.5
                    continue 
                if a > -1 / z:
                    revert with 0, 17
                if mem[_10964 + 32] + mem[_10964 + 64] and z * a > -1 / mem[_10964 + 32] + mem[_10964 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if (mem[_10964 + 32] * z * a) + (mem[_10964 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_10964 + 32] * z * a) + (mem[_10964 + 64] * z * a):
                    revert with 0, 17
                if (mem[_10964 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_10964 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if (mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if (mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _10948 = mem[96]
                idx = idx + 1
                s = s + ((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                t = t + ((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                u = u + ((mem[_10964 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10964 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_10964] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg3:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg3
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg3
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg3,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg3 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg3) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg3) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg3
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg3) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg3,
                   mem[mem[64] + 256]
        mem[64] = _2060 + (32 * arg2.length) + 1472
        mem[_2060 + (32 * arg2.length) + 1184] = 0
        mem[_2060 + (32 * arg2.length) + 1216] = 0
        mem[_2060 + (32 * arg2.length) + 1248] = 0
        mem[_2060 + (32 * arg2.length) + 1280] = 0
        mem[_2060 + (32 * arg2.length) + 1312] = 0
        mem[_2060 + (32 * arg2.length) + 1344] = 0
        mem[_2060 + (32 * arg2.length) + 1376] = 0
        mem[_2060 + (32 * arg2.length) + 1408] = 0
        mem[_2060 + (32 * arg2.length) + 1440] = 0
        mem[var124002] = var124001
        if not var124003 - 1:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _11993 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _12006 = mem[_11993]
                _12007 = mem[_11993 + 32]
                _12008 = mem[_11993 + 64]
                _12011 = mem[_11993 + 160]
                require mem[_11993 + 160] == bool(mem[_11993 + 160])
                _12044 = mem[_11993 + 192]
                require mem[_11993 + 192] == bool(mem[_11993 + 192])
                require mem[_11993 + 224] == bool(mem[_11993 + 224])
                _12105 = mem[_11993 + 256]
                require mem[_11993 + 256] == bool(mem[_11993 + 256])
                require mem[_11993 + 288] == bool(mem[_11993 + 288])
                if idx >= mem[_2060]:
                    revert with 0, 50
                _12140 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _12146 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _12152 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _12157 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _12164 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _12174 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 192] = bool(mem[_11993 + 288])
                mem[_12174 + 160] = bool(_12105)
                mem[_12164 + 128] = bool(_12044)
                mem[_12157 + 96] = bool(_12011)
                mem[_12152 + 64] = _12008
                mem[_12146 + 32] = _12007
                mem[_12140] = _12006
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _12216 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _12245 = mem[_12216 + 32]
                _12246 = mem[_12216 + 64]
                require mem[_12216 + 288] == mem[_12216 + 315 len 5]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 224] = mem[_12216]
                if _12245 > !_12246:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 256] = _12245 + _12246
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _12804 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _12804:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _12820 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_12820 + 224] == mem[_12820 + 251 len 5]
                require mem[_12820 + 256] == bool(mem[_12820 + 256])
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_12820] and 1 > -1 / mem[_12820]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_12820] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_12820]:
                        revert with 0, 17
                    if mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_12820 + 32] > !mem[_12820 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_12820 + 32] + mem[_12820 + 64] and 1 > -1 / mem[_12820 + 32] + mem[_12820 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_12820 + 32] + mem[_12820 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_12820 + 32] + mem[_12820 + 64]:
                            revert with 0, 17
                        if (mem[_12820 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_12820 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _12804 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_12820 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                        if mem[_12820 + 32] + mem[_12820 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_12820 + 32] + mem[_12820 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _12804 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _12804 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_12820 + 32] + mem[_12820 + 64] and x * y > -1 / mem[_12820 + 32] + mem[_12820 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_12820 + 32] * x * y) + (mem[_12820 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_12820 + 32] * x * y) + (mem[_12820 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_12820 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_12820 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _12804 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_12820 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_12820] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                    if mem[_12820] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_12820]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18):
                        revert with 0, 17
                    if mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_12820 + 32] > !mem[_12820 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_12820 + 32] + mem[_12820 + 64] and 1 > -1 / mem[_12820 + 32] + mem[_12820 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_12820 + 32] + mem[_12820 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_12820 + 32] + mem[_12820 + 64]:
                            revert with 0, 17
                        if (mem[_12820 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_12820 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _12804 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_12820 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                        if mem[_12820 + 32] + mem[_12820 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_12820 + 32] + mem[_12820 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _12804 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _12804 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_12820 + 32] + mem[_12820 + 64] and x * y > -1 / mem[_12820 + 32] + mem[_12820 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_12820 + 32] * x * y) + (mem[_12820 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_12820 + 32] * x * y) + (mem[_12820 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_12820 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_12820 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _12804 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_12820 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_12820] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _12804 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_12820] and x * y > -1 / mem[_12820]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if mem[_12820] * x * y and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_12820] * x * y:
                    revert with 0, 17
                if mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                    revert with 0, 17
                if mem[_12820 + 32] > !mem[_12820 + 64]:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_12820 + 32] + mem[_12820 + 64] and 1 > -1 / mem[_12820 + 32] + mem[_12820 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_12820 + 32] + mem[_12820 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_12820 + 32] + mem[_12820 + 64]:
                        revert with 0, 17
                    if (mem[_12820 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_12820 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _12804 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_12820 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                    if mem[_12820 + 32] + mem[_12820 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_12820 + 32] + mem[_12820 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _12804 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_12820 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                z = 10
                a = 1
                w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                while w > 1:
                    if z > -1 / z:
                        revert with 0, 17
                    _12804 = mem[96]
                    if not bool(w):
                        z = z * z
                        a = a
                        w = uint255(w) * 0.5
                        continue 
                    z = z * z
                    a = z * a
                    w = uint255(w) * 0.5
                    continue 
                if a > -1 / z:
                    revert with 0, 17
                if mem[_12820 + 32] + mem[_12820 + 64] and z * a > -1 / mem[_12820 + 32] + mem[_12820 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if (mem[_12820 + 32] * z * a) + (mem[_12820 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_12820 + 32] * z * a) + (mem[_12820 + 64] * z * a):
                    revert with 0, 17
                if (mem[_12820 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_12820 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if (mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if (mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _12804 = mem[96]
                idx = idx + 1
                s = s + ((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                t = t + ((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                u = u + ((mem[_12820 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12820 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_12820] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg3:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg3
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg3
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg3,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg3 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg3) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg3) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg3
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg3) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg3,
                   mem[mem[64] + 256]
        mem[64] = _2060 + (32 * arg2.length) + 1760
        mem[_2060 + (32 * arg2.length) + 1472] = 0
        mem[_2060 + (32 * arg2.length) + 1504] = 0
        mem[_2060 + (32 * arg2.length) + 1536] = 0
        mem[_2060 + (32 * arg2.length) + 1568] = 0
        mem[_2060 + (32 * arg2.length) + 1600] = 0
        mem[_2060 + (32 * arg2.length) + 1632] = 0
        mem[_2060 + (32 * arg2.length) + 1664] = 0
        mem[_2060 + (32 * arg2.length) + 1696] = 0
        mem[_2060 + (32 * arg2.length) + 1728] = 0
        mem[var128002] = var128001
        if not var128003 - 1:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _13849 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _13862 = mem[_13849]
                _13863 = mem[_13849 + 32]
                _13864 = mem[_13849 + 64]
                _13867 = mem[_13849 + 160]
                require mem[_13849 + 160] == bool(mem[_13849 + 160])
                _13900 = mem[_13849 + 192]
                require mem[_13849 + 192] == bool(mem[_13849 + 192])
                require mem[_13849 + 224] == bool(mem[_13849 + 224])
                _13961 = mem[_13849 + 256]
                require mem[_13849 + 256] == bool(mem[_13849 + 256])
                require mem[_13849 + 288] == bool(mem[_13849 + 288])
                if idx >= mem[_2060]:
                    revert with 0, 50
                _13996 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _14002 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _14008 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _14013 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _14020 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _14030 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 192] = bool(mem[_13849 + 288])
                mem[_14030 + 160] = bool(_13961)
                mem[_14020 + 128] = bool(_13900)
                mem[_14013 + 96] = bool(_13867)
                mem[_14008 + 64] = _13864
                mem[_14002 + 32] = _13863
                mem[_13996] = _13862
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _14072 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _14101 = mem[_14072 + 32]
                _14102 = mem[_14072 + 64]
                require mem[_14072 + 288] == mem[_14072 + 315 len 5]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 224] = mem[_14072]
                if _14101 > !_14102:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 256] = _14101 + _14102
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _14660 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _14660:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _14676 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_14676 + 224] == mem[_14676 + 251 len 5]
                require mem[_14676 + 256] == bool(mem[_14676 + 256])
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_14676] and 1 > -1 / mem[_14676]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_14676] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_14676]:
                        revert with 0, 17
                    if mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_14676 + 32] > !mem[_14676 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_14676 + 32] + mem[_14676 + 64] and 1 > -1 / mem[_14676 + 32] + mem[_14676 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_14676 + 32] + mem[_14676 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_14676 + 32] + mem[_14676 + 64]:
                            revert with 0, 17
                        if (mem[_14676 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_14676 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _14660 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_14676 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                        if mem[_14676 + 32] + mem[_14676 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_14676 + 32] + mem[_14676 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _14660 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _14660 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_14676 + 32] + mem[_14676 + 64] and x * y > -1 / mem[_14676 + 32] + mem[_14676 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_14676 + 32] * x * y) + (mem[_14676 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_14676 + 32] * x * y) + (mem[_14676 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_14676 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_14676 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _14660 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_14676 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_14676] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                    if mem[_14676] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_14676]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18):
                        revert with 0, 17
                    if mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_14676 + 32] > !mem[_14676 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_14676 + 32] + mem[_14676 + 64] and 1 > -1 / mem[_14676 + 32] + mem[_14676 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_14676 + 32] + mem[_14676 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_14676 + 32] + mem[_14676 + 64]:
                            revert with 0, 17
                        if (mem[_14676 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_14676 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _14660 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_14676 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                        if mem[_14676 + 32] + mem[_14676 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_14676 + 32] + mem[_14676 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _14660 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _14660 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_14676 + 32] + mem[_14676 + 64] and x * y > -1 / mem[_14676 + 32] + mem[_14676 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_14676 + 32] * x * y) + (mem[_14676 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_14676 + 32] * x * y) + (mem[_14676 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_14676 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_14676 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _14660 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_14676 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_14676] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _14660 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_14676] and x * y > -1 / mem[_14676]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if mem[_14676] * x * y and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_14676] * x * y:
                    revert with 0, 17
                if mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                    revert with 0, 17
                if mem[_14676 + 32] > !mem[_14676 + 64]:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_14676 + 32] + mem[_14676 + 64] and 1 > -1 / mem[_14676 + 32] + mem[_14676 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_14676 + 32] + mem[_14676 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_14676 + 32] + mem[_14676 + 64]:
                        revert with 0, 17
                    if (mem[_14676 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_14676 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _14660 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_14676 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32)):
                    if mem[_14676 + 32] + mem[_14676 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_14676 + 32] + mem[_14676 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if (mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _14660 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                    t = t + ((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                    u = u + ((mem[_14676 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                z = 10
                a = 1
                w = -mem[mem[(32 * idx) + _2060 + 32]] + 18
                while w > 1:
                    if z > -1 / z:
                        revert with 0, 17
                    _14660 = mem[96]
                    if not bool(w):
                        z = z * z
                        a = a
                        w = uint255(w) * 0.5
                        continue 
                    z = z * z
                    a = z * a
                    w = uint255(w) * 0.5
                    continue 
                if a > -1 / z:
                    revert with 0, 17
                if mem[_14676 + 32] + mem[_14676 + 64] and z * a > -1 / mem[_14676 + 32] + mem[_14676 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if (mem[_14676 + 32] * z * a) + (mem[_14676 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_14676 + 32] * z * a) + (mem[_14676 + 64] * z * a):
                    revert with 0, 17
                if (mem[_14676 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_14676 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if (mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                if (mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _14660 = mem[96]
                idx = idx + 1
                s = s + ((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                t = t + ((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                u = u + ((mem[_14676 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14676 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_14676] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg3:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg3
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg3
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg3,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg3 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg3) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg3) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg3
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg3) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg3,
                   mem[mem[64] + 256]
        mem[64] = _2060 + (32 * arg2.length) + 2048
        mem[_2060 + (32 * arg2.length) + 1760] = 0
        mem[_2060 + (32 * arg2.length) + 1792] = 0
        mem[_2060 + (32 * arg2.length) + 1824] = 0
        mem[_2060 + (32 * arg2.length) + 1856] = 0
        mem[_2060 + (32 * arg2.length) + 1888] = 0
        mem[_2060 + (32 * arg2.length) + 1920] = 0
        mem[_2060 + (32 * arg2.length) + 1952] = 0
        mem[_2060 + (32 * arg2.length) + 1984] = 0
        mem[_2060 + (32 * arg2.length) + 2016] = 0
        mem[var132002] = var132001
        if var132003 - 1:
            # nil
        else:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _15705 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _15718 = mem[_15705]
                _15719 = mem[_15705 + 32]
                _15720 = mem[_15705 + 64]
                _15723 = mem[_15705 + 160]
                require mem[_15705 + 160] == bool(mem[_15705 + 160])
                _15756 = mem[_15705 + 192]
                require mem[_15705 + 192] == bool(mem[_15705 + 192])
                require mem[_15705 + 224] == bool(mem[_15705 + 224])
                _15817 = mem[_15705 + 256]
                require mem[_15705 + 256] == bool(mem[_15705 + 256])
                require mem[_15705 + 288] == bool(mem[_15705 + 288])
                if idx >= mem[_2060]:
                    revert with 0, 50
                _15852 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _15858 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _15864 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _15869 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _15876 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                _15886 = mem[(32 * idx) + _2060 + 32]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 192] = bool(mem[_15705 + 288])
                mem[_15886 + 160] = bool(_15817)
                mem[_15876 + 128] = bool(_15756)
                mem[_15869 + 96] = bool(_15723)
                mem[_15864 + 64] = _15720
                mem[_15858 + 32] = _15719
                mem[_15852] = _15718
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _15928 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _15957 = mem[_15928 + 32]
                _15958 = mem[_15928 + 64]
                require mem[_15928 + 288] == mem[_15928 + 315 len 5]
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 224] = mem[_15928]
                if _15957 > !_15958:
                    revert with 0, 17
                if idx >= mem[_2060]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2060 + 32] + 256] = _15957 + _15958
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _16516 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _16516:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _16532 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_16532 + 224] == mem[_16532 + 251 len 5]
                require mem[_16532 + 256] == bool(mem[_16532 + 256])
                if idx >= mem[_2060]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                    if mem[_16532] and 1 > -1 / mem[_16532]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_16532] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_16532]:
                        revert with 0, 17
                    if mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_16532 + 32] > !mem[_16532 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2060]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                        if mem[_16532 + 32] + mem[_16532 + 64] and 1 > -1 / mem[_16532 + 32] + mem[_16532 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_16532 + 32] + mem[_16532 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_16532 + 32] + mem[_16532 + 64]:
                            revert with 0, 17
                        if (mem[_16532 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16532 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_16532 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16532 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _16516 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_16532 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16532 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if not bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78) and not bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32):
                        # nil
                    else:
                        if mem[_16532 + 32] + mem[_16532 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_16532 + 32] + mem[_16532 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_16532 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_16532 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_16532 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_16532 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_16532 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16532 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_16532 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16532 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if (mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _16516 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                        t = t + ((mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                        u = u + ((mem[_16532 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16532 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_16532] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                else:
                    if not bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78) and not bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32):
                        # nil
                    else:
                        if mem[_16532] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_16532]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18):
                            revert with 0, 17
                        if mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                            revert with 0, 17
                        if mem[_16532 + 32] > !mem[_16532 + 64]:
                            revert with 0, 17
                        if idx >= mem[_2060]:
                            revert with 0, 50
                        if 18 < mem[mem[(32 * idx) + _2060 + 32]]:
                            revert with 0, 17
                        if not -mem[mem[(32 * idx) + _2060 + 32]] + 18:
                            if mem[_16532 + 32] + mem[_16532 + 64] and 1 > -1 / mem[_16532 + 32] + mem[_16532 + 64]:
                                revert with 0, 17
                            if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                                revert with 0, 50
                            if mem[_16532 + 32] + mem[_16532 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_16532 + 32] + mem[_16532 + 64]:
                                revert with 0, 17
                            if (mem[_16532 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16532 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                                revert with 0, 17
                            if v > !((mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                                revert with 0, 17
                            if u > !((mem[_16532 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16532 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                                revert with 0, 17
                            if idx >= mem[_2060]:
                                revert with 0, 50
                            if (mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                                revert with 0, 17
                            if s > !((mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                                revert with 0, 17
                            if idx >= mem[_2060]:
                                revert with 0, 50
                            if (mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                                revert with 0, 17
                            if t > !((mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            _16516 = mem[96]
                            idx = idx + 1
                            s = s + ((mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                            t = t + ((mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                            u = u + ((mem[_16532 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16532 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                            v = v + ((mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                            continue 
                        if not bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 78) and not bool(-mem[mem[(32 * idx) + _2060 + 32]] + 18 < 32):
                            # nil
                        else:
                            if mem[_16532 + 32] + mem[_16532 + 64] and 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) > -1 / mem[_16532 + 32] + mem[_16532 + 64]:
                                revert with 0, 17
                            if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                                revert with 0, 50
                            if (mem[_16532 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_16532 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_16532 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)) + (mem[_16532 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18)):
                                revert with 0, 17
                            if (mem[_16532 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16532 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                                revert with 0, 17
                            if v > !((mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                                revert with 0, 17
                            if u > !((mem[_16532 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16532 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                                revert with 0, 17
                            if idx >= mem[_2060]:
                                revert with 0, 50
                            if (mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 64] > -1 / (mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                                revert with 0, 17
                            if s > !((mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000):
                                revert with 0, 17
                            if idx >= mem[_2060]:
                                revert with 0, 50
                            if (mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2060 + 32] + 32] > -1 / (mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                                revert with 0, 17
                            if t > !((mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            _16516 = mem[96]
                            idx = idx + 1
                            s = s + ((mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 64] / 10000)
                            t = t + ((mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2060 + 32] + 32] / 10000)
                            u = u + ((mem[_16532 + 32] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16532 + 64] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                            v = v + ((mem[_16532] * 10^(-mem[mem[(32 * idx) + _2060 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                            continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg3:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg3
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg3
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg3,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg3 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg3) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg3) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg3
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg3 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg3) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg3,
                   mem[mem[64] + 256]
    else:
        _1307 = mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0
        require mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0 <= test266151307()
        require ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + return_data.size + 673 > ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0 + 704
        _1309 = mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0 + 673]
        if mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0 + 673] > test266151307():
            revert with 0, 65
        if ceil32(32 * mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0 + 673]) + 1 < 0 or ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0 + 673]) + 674 > test266151307():
            revert with 0, 65
        mem[64] = ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + ceil32(32 * mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + 673 len 4], 0 + 673]) + 674
        mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673] = _1309
        require _1307 + (32 * _1309) + 32 <= return_data.size
        mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705 len 32 * _1309] = mem[ceil32(32 * arg2.length) + (4 * ceil32(return_data.size)) + _1307 + 705 len 32 * _1309]
        if arg2.length > test266151307():
            revert with 0, 65
        _2061 = mem[64]
        mem[mem[64]] = arg2.length
        mem[64] = mem[64] + (32 * arg2.length) + 32
        if not arg2.length:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2822 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _2838 = mem[_2822]
                _2839 = mem[_2822 + 32]
                _2840 = mem[_2822 + 64]
                _2843 = mem[_2822 + 160]
                require mem[_2822 + 160] == bool(mem[_2822 + 160])
                _2872 = mem[_2822 + 192]
                require mem[_2822 + 192] == bool(mem[_2822 + 192])
                require mem[_2822 + 224] == bool(mem[_2822 + 224])
                _2920 = mem[_2822 + 256]
                require mem[_2822 + 256] == bool(mem[_2822 + 256])
                require mem[_2822 + 288] == bool(mem[_2822 + 288])
                if idx >= mem[_2061]:
                    revert with 0, 50
                _2956 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _2964 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _2968 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _2973 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _2980 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _2990 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 192] = bool(mem[_2822 + 288])
                mem[_2990 + 160] = bool(_2920)
                mem[_2980 + 128] = bool(_2872)
                mem[_2973 + 96] = bool(_2843)
                mem[_2968 + 64] = _2840
                mem[_2964 + 32] = _2839
                mem[_2956] = _2838
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3031 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _3055 = mem[_3031 + 32]
                _3056 = mem[_3031 + 64]
                require mem[_3031 + 288] == mem[_3031 + 315 len 5]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 224] = mem[_3031]
                if _3055 > !_3056:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 256] = _3055 + _3056
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _3541 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _3541:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3557 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_3557 + 224] == mem[_3557 + 251 len 5]
                require mem[_3557 + 256] == bool(mem[_3557 + 256])
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_3557] and 1 > -1 / mem[_3557]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_3557] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_3557]:
                        revert with 0, 17
                    if mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_3557 + 32] > !mem[_3557 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_3557 + 32] + mem[_3557 + 64] and 1 > -1 / mem[_3557 + 32] + mem[_3557 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_3557 + 32] + mem[_3557 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_3557 + 32] + mem[_3557 + 64]:
                            revert with 0, 17
                        if (mem[_3557 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_3557 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3541 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_3557 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                        if mem[_3557 + 32] + mem[_3557 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_3557 + 32] + mem[_3557 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3541 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _3541 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_3557 + 32] + mem[_3557 + 64] and x * y > -1 / mem[_3557 + 32] + mem[_3557 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_3557 + 32] * x * y) + (mem[_3557 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_3557 + 32] * x * y) + (mem[_3557 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_3557 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3557 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3541 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_3557 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3557] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                    if mem[_3557] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_3557]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18):
                        revert with 0, 17
                    if mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_3557 + 32] > !mem[_3557 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_3557 + 32] + mem[_3557 + 64] and 1 > -1 / mem[_3557 + 32] + mem[_3557 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_3557 + 32] + mem[_3557 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_3557 + 32] + mem[_3557 + 64]:
                            revert with 0, 17
                        if (mem[_3557 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_3557 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3541 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_3557 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                        if mem[_3557 + 32] + mem[_3557 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_3557 + 32] + mem[_3557 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _3541 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _3541 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_3557 + 32] + mem[_3557 + 64] and x * y > -1 / mem[_3557 + 32] + mem[_3557 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_3557 + 32] * x * y) + (mem[_3557 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_3557 + 32] * x * y) + (mem[_3557 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_3557 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3557 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3541 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_3557 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3557] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _3541 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_3557] and x * y > -1 / mem[_3557]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if mem[_3557] * x * y and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_3557] * x * y:
                    revert with 0, 17
                if mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                    revert with 0, 17
                if mem[_3557 + 32] > !mem[_3557 + 64]:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_3557 + 32] + mem[_3557 + 64] and 1 > -1 / mem[_3557 + 32] + mem[_3557 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_3557 + 32] + mem[_3557 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_3557 + 32] + mem[_3557 + 64]:
                        revert with 0, 17
                    if (mem[_3557 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3557 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3541 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_3557 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                    if mem[_3557 + 32] + mem[_3557 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_3557 + 32] + mem[_3557 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _3541 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_3557 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                z = 10
                a = 1
                w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                while w > 1:
                    if z > -1 / z:
                        revert with 0, 17
                    _3541 = mem[96]
                    if not bool(w):
                        z = z * z
                        a = a
                        w = uint255(w) * 0.5
                        continue 
                    z = z * z
                    a = z * a
                    w = uint255(w) * 0.5
                    continue 
                if a > -1 / z:
                    revert with 0, 17
                if mem[_3557 + 32] + mem[_3557 + 64] and z * a > -1 / mem[_3557 + 32] + mem[_3557 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if (mem[_3557 + 32] * z * a) + (mem[_3557 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_3557 + 32] * z * a) + (mem[_3557 + 64] * z * a):
                    revert with 0, 17
                if (mem[_3557 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_3557 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if (mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if (mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _3541 = mem[96]
                idx = idx + 1
                s = s + ((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                t = t + ((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                u = u + ((mem[_3557 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_3557 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_3557] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg4:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg4
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg4
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg4,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg4 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg4) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg4) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg4
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg4) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg4,
                   mem[mem[64] + 256]
        mem[64] = _2061 + (32 * arg2.length) + 320
        mem[_2061 + (32 * arg2.length) + 32] = 0
        mem[_2061 + (32 * arg2.length) + 64] = 0
        mem[_2061 + (32 * arg2.length) + 96] = 0
        mem[_2061 + (32 * arg2.length) + 128] = 0
        mem[_2061 + (32 * arg2.length) + 160] = 0
        mem[_2061 + (32 * arg2.length) + 192] = 0
        mem[_2061 + (32 * arg2.length) + 224] = 0
        mem[_2061 + (32 * arg2.length) + 256] = 0
        mem[_2061 + (32 * arg2.length) + 288] = 0
        mem[var108002] = var108001
        if not var108003 - 1:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4573 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _4590 = mem[_4573]
                _4591 = mem[_4573 + 32]
                _4592 = mem[_4573 + 64]
                _4595 = mem[_4573 + 160]
                require mem[_4573 + 160] == bool(mem[_4573 + 160])
                _4635 = mem[_4573 + 192]
                require mem[_4573 + 192] == bool(mem[_4573 + 192])
                require mem[_4573 + 224] == bool(mem[_4573 + 224])
                _4683 = mem[_4573 + 256]
                require mem[_4573 + 256] == bool(mem[_4573 + 256])
                require mem[_4573 + 288] == bool(mem[_4573 + 288])
                if idx >= mem[_2061]:
                    revert with 0, 50
                _4718 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _4726 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _4730 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _4736 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _4744 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _4756 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 192] = bool(mem[_4573 + 288])
                mem[_4756 + 160] = bool(_4683)
                mem[_4744 + 128] = bool(_4635)
                mem[_4736 + 96] = bool(_4595)
                mem[_4730 + 64] = _4592
                mem[_4726 + 32] = _4591
                mem[_4718] = _4590
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4799 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _4838 = mem[_4799 + 32]
                _4839 = mem[_4799 + 64]
                require mem[_4799 + 288] == mem[_4799 + 315 len 5]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 224] = mem[_4799]
                if _4838 > !_4839:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 256] = _4838 + _4839
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _5381 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _5381:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5399 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_5399 + 224] == mem[_5399 + 251 len 5]
                require mem[_5399 + 256] == bool(mem[_5399 + 256])
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_5399] and 1 > -1 / mem[_5399]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_5399] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_5399]:
                        revert with 0, 17
                    if mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_5399 + 32] > !mem[_5399 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_5399 + 32] + mem[_5399 + 64] and 1 > -1 / mem[_5399 + 32] + mem[_5399 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_5399 + 32] + mem[_5399 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_5399 + 32] + mem[_5399 + 64]:
                            revert with 0, 17
                        if (mem[_5399 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_5399 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _5381 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_5399 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                        if mem[_5399 + 32] + mem[_5399 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_5399 + 32] + mem[_5399 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _5381 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _5381 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_5399 + 32] + mem[_5399 + 64] and x * y > -1 / mem[_5399 + 32] + mem[_5399 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_5399 + 32] * x * y) + (mem[_5399 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_5399 + 32] * x * y) + (mem[_5399 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_5399 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5399 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5381 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_5399 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5399] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                    if mem[_5399] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_5399]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18):
                        revert with 0, 17
                    if mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_5399 + 32] > !mem[_5399 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_5399 + 32] + mem[_5399 + 64] and 1 > -1 / mem[_5399 + 32] + mem[_5399 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_5399 + 32] + mem[_5399 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_5399 + 32] + mem[_5399 + 64]:
                            revert with 0, 17
                        if (mem[_5399 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_5399 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _5381 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_5399 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                        if mem[_5399 + 32] + mem[_5399 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_5399 + 32] + mem[_5399 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _5381 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _5381 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_5399 + 32] + mem[_5399 + 64] and x * y > -1 / mem[_5399 + 32] + mem[_5399 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_5399 + 32] * x * y) + (mem[_5399 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_5399 + 32] * x * y) + (mem[_5399 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_5399 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5399 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5381 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_5399 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5399] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _5381 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_5399] and x * y > -1 / mem[_5399]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if mem[_5399] * x * y and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_5399] * x * y:
                    revert with 0, 17
                if mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                    revert with 0, 17
                if mem[_5399 + 32] > !mem[_5399 + 64]:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_5399 + 32] + mem[_5399 + 64] and 1 > -1 / mem[_5399 + 32] + mem[_5399 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_5399 + 32] + mem[_5399 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_5399 + 32] + mem[_5399 + 64]:
                        revert with 0, 17
                    if (mem[_5399 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5399 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5381 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_5399 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                    if mem[_5399 + 32] + mem[_5399 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_5399 + 32] + mem[_5399 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _5381 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_5399 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                z = 10
                a = 1
                w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                while w > 1:
                    if z > -1 / z:
                        revert with 0, 17
                    _5381 = mem[96]
                    if not bool(w):
                        z = z * z
                        a = a
                        w = uint255(w) * 0.5
                        continue 
                    z = z * z
                    a = z * a
                    w = uint255(w) * 0.5
                    continue 
                if a > -1 / z:
                    revert with 0, 17
                if mem[_5399 + 32] + mem[_5399 + 64] and z * a > -1 / mem[_5399 + 32] + mem[_5399 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if (mem[_5399 + 32] * z * a) + (mem[_5399 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_5399 + 32] * z * a) + (mem[_5399 + 64] * z * a):
                    revert with 0, 17
                if (mem[_5399 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_5399 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if (mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if (mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _5381 = mem[96]
                idx = idx + 1
                s = s + ((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                t = t + ((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                u = u + ((mem[_5399 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_5399 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_5399] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg4:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg4
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg4
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg4,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg4 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg4) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg4) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg4
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg4) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg4,
                   mem[mem[64] + 256]
        mem[64] = _2061 + (32 * arg2.length) + 608
        mem[_2061 + (32 * arg2.length) + 320] = 0
        mem[_2061 + (32 * arg2.length) + 352] = 0
        mem[_2061 + (32 * arg2.length) + 384] = 0
        mem[_2061 + (32 * arg2.length) + 416] = 0
        mem[_2061 + (32 * arg2.length) + 448] = 0
        mem[_2061 + (32 * arg2.length) + 480] = 0
        mem[_2061 + (32 * arg2.length) + 512] = 0
        mem[_2061 + (32 * arg2.length) + 544] = 0
        mem[_2061 + (32 * arg2.length) + 576] = 0
        mem[var112002] = var112001
        if not var112003 - 1:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6429 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _6446 = mem[_6429]
                _6447 = mem[_6429 + 32]
                _6448 = mem[_6429 + 64]
                _6451 = mem[_6429 + 160]
                require mem[_6429 + 160] == bool(mem[_6429 + 160])
                _6488 = mem[_6429 + 192]
                require mem[_6429 + 192] == bool(mem[_6429 + 192])
                require mem[_6429 + 224] == bool(mem[_6429 + 224])
                _6539 = mem[_6429 + 256]
                require mem[_6429 + 256] == bool(mem[_6429 + 256])
                require mem[_6429 + 288] == bool(mem[_6429 + 288])
                if idx >= mem[_2061]:
                    revert with 0, 50
                _6574 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _6582 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _6586 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _6592 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _6600 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _6612 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 192] = bool(mem[_6429 + 288])
                mem[_6612 + 160] = bool(_6539)
                mem[_6600 + 128] = bool(_6488)
                mem[_6592 + 96] = bool(_6451)
                mem[_6586 + 64] = _6448
                mem[_6582 + 32] = _6447
                mem[_6574] = _6446
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6653 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _6692 = mem[_6653 + 32]
                _6693 = mem[_6653 + 64]
                require mem[_6653 + 288] == mem[_6653 + 315 len 5]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 224] = mem[_6653]
                if _6692 > !_6693:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 256] = _6692 + _6693
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _7237 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _7237:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7255 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_7255 + 224] == mem[_7255 + 251 len 5]
                require mem[_7255 + 256] == bool(mem[_7255 + 256])
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_7255] and 1 > -1 / mem[_7255]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_7255] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_7255]:
                        revert with 0, 17
                    if mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_7255 + 32] > !mem[_7255 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_7255 + 32] + mem[_7255 + 64] and 1 > -1 / mem[_7255 + 32] + mem[_7255 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_7255 + 32] + mem[_7255 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_7255 + 32] + mem[_7255 + 64]:
                            revert with 0, 17
                        if (mem[_7255 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_7255 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _7237 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_7255 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                        if mem[_7255 + 32] + mem[_7255 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_7255 + 32] + mem[_7255 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _7237 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _7237 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_7255 + 32] + mem[_7255 + 64] and x * y > -1 / mem[_7255 + 32] + mem[_7255 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_7255 + 32] * x * y) + (mem[_7255 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_7255 + 32] * x * y) + (mem[_7255 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_7255 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_7255 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7237 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_7255 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_7255] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                    if mem[_7255] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_7255]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18):
                        revert with 0, 17
                    if mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_7255 + 32] > !mem[_7255 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_7255 + 32] + mem[_7255 + 64] and 1 > -1 / mem[_7255 + 32] + mem[_7255 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_7255 + 32] + mem[_7255 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_7255 + 32] + mem[_7255 + 64]:
                            revert with 0, 17
                        if (mem[_7255 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_7255 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _7237 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_7255 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                        if mem[_7255 + 32] + mem[_7255 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_7255 + 32] + mem[_7255 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _7237 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _7237 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_7255 + 32] + mem[_7255 + 64] and x * y > -1 / mem[_7255 + 32] + mem[_7255 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_7255 + 32] * x * y) + (mem[_7255 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_7255 + 32] * x * y) + (mem[_7255 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_7255 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_7255 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7237 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_7255 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_7255] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _7237 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_7255] and x * y > -1 / mem[_7255]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if mem[_7255] * x * y and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_7255] * x * y:
                    revert with 0, 17
                if mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                    revert with 0, 17
                if mem[_7255 + 32] > !mem[_7255 + 64]:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_7255 + 32] + mem[_7255 + 64] and 1 > -1 / mem[_7255 + 32] + mem[_7255 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_7255 + 32] + mem[_7255 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_7255 + 32] + mem[_7255 + 64]:
                        revert with 0, 17
                    if (mem[_7255 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_7255 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7237 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_7255 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                    if mem[_7255 + 32] + mem[_7255 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_7255 + 32] + mem[_7255 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _7237 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_7255 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                z = 10
                a = 1
                w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                while w > 1:
                    if z > -1 / z:
                        revert with 0, 17
                    _7237 = mem[96]
                    if not bool(w):
                        z = z * z
                        a = a
                        w = uint255(w) * 0.5
                        continue 
                    z = z * z
                    a = z * a
                    w = uint255(w) * 0.5
                    continue 
                if a > -1 / z:
                    revert with 0, 17
                if mem[_7255 + 32] + mem[_7255 + 64] and z * a > -1 / mem[_7255 + 32] + mem[_7255 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if (mem[_7255 + 32] * z * a) + (mem[_7255 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_7255 + 32] * z * a) + (mem[_7255 + 64] * z * a):
                    revert with 0, 17
                if (mem[_7255 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_7255 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if (mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if (mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _7237 = mem[96]
                idx = idx + 1
                s = s + ((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                t = t + ((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                u = u + ((mem[_7255 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_7255 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_7255] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg4:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg4
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg4
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg4,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg4 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg4) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg4) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg4
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg4) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg4,
                   mem[mem[64] + 256]
        mem[64] = _2061 + (32 * arg2.length) + 896
        mem[_2061 + (32 * arg2.length) + 608] = 0
        mem[_2061 + (32 * arg2.length) + 640] = 0
        mem[_2061 + (32 * arg2.length) + 672] = 0
        mem[_2061 + (32 * arg2.length) + 704] = 0
        mem[_2061 + (32 * arg2.length) + 736] = 0
        mem[_2061 + (32 * arg2.length) + 768] = 0
        mem[_2061 + (32 * arg2.length) + 800] = 0
        mem[_2061 + (32 * arg2.length) + 832] = 0
        mem[_2061 + (32 * arg2.length) + 864] = 0
        mem[var116002] = var116001
        if not var116003 - 1:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8285 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _8302 = mem[_8285]
                _8303 = mem[_8285 + 32]
                _8304 = mem[_8285 + 64]
                _8307 = mem[_8285 + 160]
                require mem[_8285 + 160] == bool(mem[_8285 + 160])
                _8344 = mem[_8285 + 192]
                require mem[_8285 + 192] == bool(mem[_8285 + 192])
                require mem[_8285 + 224] == bool(mem[_8285 + 224])
                _8395 = mem[_8285 + 256]
                require mem[_8285 + 256] == bool(mem[_8285 + 256])
                require mem[_8285 + 288] == bool(mem[_8285 + 288])
                if idx >= mem[_2061]:
                    revert with 0, 50
                _8430 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _8438 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _8442 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _8448 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _8456 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _8468 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 192] = bool(mem[_8285 + 288])
                mem[_8468 + 160] = bool(_8395)
                mem[_8456 + 128] = bool(_8344)
                mem[_8448 + 96] = bool(_8307)
                mem[_8442 + 64] = _8304
                mem[_8438 + 32] = _8303
                mem[_8430] = _8302
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _8509 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _8548 = mem[_8509 + 32]
                _8549 = mem[_8509 + 64]
                require mem[_8509 + 288] == mem[_8509 + 315 len 5]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 224] = mem[_8509]
                if _8548 > !_8549:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 256] = _8548 + _8549
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _9093 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _9093:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _9111 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_9111 + 224] == mem[_9111 + 251 len 5]
                require mem[_9111 + 256] == bool(mem[_9111 + 256])
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_9111] and 1 > -1 / mem[_9111]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_9111] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_9111]:
                        revert with 0, 17
                    if mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_9111 + 32] > !mem[_9111 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_9111 + 32] + mem[_9111 + 64] and 1 > -1 / mem[_9111 + 32] + mem[_9111 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_9111 + 32] + mem[_9111 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_9111 + 32] + mem[_9111 + 64]:
                            revert with 0, 17
                        if (mem[_9111 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_9111 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _9093 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_9111 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                        if mem[_9111 + 32] + mem[_9111 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_9111 + 32] + mem[_9111 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _9093 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _9093 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_9111 + 32] + mem[_9111 + 64] and x * y > -1 / mem[_9111 + 32] + mem[_9111 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_9111 + 32] * x * y) + (mem[_9111 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_9111 + 32] * x * y) + (mem[_9111 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_9111 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_9111 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _9093 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_9111 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_9111] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                    if mem[_9111] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_9111]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18):
                        revert with 0, 17
                    if mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_9111 + 32] > !mem[_9111 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_9111 + 32] + mem[_9111 + 64] and 1 > -1 / mem[_9111 + 32] + mem[_9111 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_9111 + 32] + mem[_9111 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_9111 + 32] + mem[_9111 + 64]:
                            revert with 0, 17
                        if (mem[_9111 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_9111 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _9093 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_9111 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                        if mem[_9111 + 32] + mem[_9111 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_9111 + 32] + mem[_9111 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _9093 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _9093 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_9111 + 32] + mem[_9111 + 64] and x * y > -1 / mem[_9111 + 32] + mem[_9111 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_9111 + 32] * x * y) + (mem[_9111 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_9111 + 32] * x * y) + (mem[_9111 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_9111 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_9111 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _9093 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_9111 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_9111] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _9093 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_9111] and x * y > -1 / mem[_9111]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if mem[_9111] * x * y and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_9111] * x * y:
                    revert with 0, 17
                if mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                    revert with 0, 17
                if mem[_9111 + 32] > !mem[_9111 + 64]:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_9111 + 32] + mem[_9111 + 64] and 1 > -1 / mem[_9111 + 32] + mem[_9111 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_9111 + 32] + mem[_9111 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_9111 + 32] + mem[_9111 + 64]:
                        revert with 0, 17
                    if (mem[_9111 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_9111 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _9093 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_9111 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                    if mem[_9111 + 32] + mem[_9111 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_9111 + 32] + mem[_9111 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _9093 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_9111 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                z = 10
                a = 1
                w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                while w > 1:
                    if z > -1 / z:
                        revert with 0, 17
                    _9093 = mem[96]
                    if not bool(w):
                        z = z * z
                        a = a
                        w = uint255(w) * 0.5
                        continue 
                    z = z * z
                    a = z * a
                    w = uint255(w) * 0.5
                    continue 
                if a > -1 / z:
                    revert with 0, 17
                if mem[_9111 + 32] + mem[_9111 + 64] and z * a > -1 / mem[_9111 + 32] + mem[_9111 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if (mem[_9111 + 32] * z * a) + (mem[_9111 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_9111 + 32] * z * a) + (mem[_9111 + 64] * z * a):
                    revert with 0, 17
                if (mem[_9111 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_9111 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if (mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if (mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _9093 = mem[96]
                idx = idx + 1
                s = s + ((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                t = t + ((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                u = u + ((mem[_9111 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_9111 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_9111] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg4:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg4
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg4
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg4,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg4 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg4) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg4) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg4
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg4) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg4,
                   mem[mem[64] + 256]
        mem[64] = _2061 + (32 * arg2.length) + 1184
        mem[_2061 + (32 * arg2.length) + 896] = 0
        mem[_2061 + (32 * arg2.length) + 928] = 0
        mem[_2061 + (32 * arg2.length) + 960] = 0
        mem[_2061 + (32 * arg2.length) + 992] = 0
        mem[_2061 + (32 * arg2.length) + 1024] = 0
        mem[_2061 + (32 * arg2.length) + 1056] = 0
        mem[_2061 + (32 * arg2.length) + 1088] = 0
        mem[_2061 + (32 * arg2.length) + 1120] = 0
        mem[_2061 + (32 * arg2.length) + 1152] = 0
        mem[var120002] = var120001
        if not var120003 - 1:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10141 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _10158 = mem[_10141]
                _10159 = mem[_10141 + 32]
                _10160 = mem[_10141 + 64]
                _10163 = mem[_10141 + 160]
                require mem[_10141 + 160] == bool(mem[_10141 + 160])
                _10200 = mem[_10141 + 192]
                require mem[_10141 + 192] == bool(mem[_10141 + 192])
                require mem[_10141 + 224] == bool(mem[_10141 + 224])
                _10251 = mem[_10141 + 256]
                require mem[_10141 + 256] == bool(mem[_10141 + 256])
                require mem[_10141 + 288] == bool(mem[_10141 + 288])
                if idx >= mem[_2061]:
                    revert with 0, 50
                _10286 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _10294 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _10298 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _10304 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _10312 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _10324 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 192] = bool(mem[_10141 + 288])
                mem[_10324 + 160] = bool(_10251)
                mem[_10312 + 128] = bool(_10200)
                mem[_10304 + 96] = bool(_10163)
                mem[_10298 + 64] = _10160
                mem[_10294 + 32] = _10159
                mem[_10286] = _10158
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10365 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _10404 = mem[_10365 + 32]
                _10405 = mem[_10365 + 64]
                require mem[_10365 + 288] == mem[_10365 + 315 len 5]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 224] = mem[_10365]
                if _10404 > !_10405:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 256] = _10404 + _10405
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _10949 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _10949:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _10967 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_10967 + 224] == mem[_10967 + 251 len 5]
                require mem[_10967 + 256] == bool(mem[_10967 + 256])
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_10967] and 1 > -1 / mem[_10967]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_10967] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_10967]:
                        revert with 0, 17
                    if mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_10967 + 32] > !mem[_10967 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_10967 + 32] + mem[_10967 + 64] and 1 > -1 / mem[_10967 + 32] + mem[_10967 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_10967 + 32] + mem[_10967 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_10967 + 32] + mem[_10967 + 64]:
                            revert with 0, 17
                        if (mem[_10967 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_10967 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _10949 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_10967 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                        if mem[_10967 + 32] + mem[_10967 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_10967 + 32] + mem[_10967 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _10949 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _10949 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_10967 + 32] + mem[_10967 + 64] and x * y > -1 / mem[_10967 + 32] + mem[_10967 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_10967 + 32] * x * y) + (mem[_10967 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_10967 + 32] * x * y) + (mem[_10967 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_10967 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_10967 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _10949 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_10967 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_10967] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                    if mem[_10967] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_10967]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18):
                        revert with 0, 17
                    if mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_10967 + 32] > !mem[_10967 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_10967 + 32] + mem[_10967 + 64] and 1 > -1 / mem[_10967 + 32] + mem[_10967 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_10967 + 32] + mem[_10967 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_10967 + 32] + mem[_10967 + 64]:
                            revert with 0, 17
                        if (mem[_10967 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_10967 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _10949 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_10967 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                        if mem[_10967 + 32] + mem[_10967 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_10967 + 32] + mem[_10967 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _10949 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _10949 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_10967 + 32] + mem[_10967 + 64] and x * y > -1 / mem[_10967 + 32] + mem[_10967 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_10967 + 32] * x * y) + (mem[_10967 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_10967 + 32] * x * y) + (mem[_10967 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_10967 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_10967 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _10949 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_10967 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_10967] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _10949 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_10967] and x * y > -1 / mem[_10967]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if mem[_10967] * x * y and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_10967] * x * y:
                    revert with 0, 17
                if mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                    revert with 0, 17
                if mem[_10967 + 32] > !mem[_10967 + 64]:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_10967 + 32] + mem[_10967 + 64] and 1 > -1 / mem[_10967 + 32] + mem[_10967 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_10967 + 32] + mem[_10967 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_10967 + 32] + mem[_10967 + 64]:
                        revert with 0, 17
                    if (mem[_10967 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_10967 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _10949 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_10967 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                    if mem[_10967 + 32] + mem[_10967 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_10967 + 32] + mem[_10967 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _10949 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_10967 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                z = 10
                a = 1
                w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                while w > 1:
                    if z > -1 / z:
                        revert with 0, 17
                    _10949 = mem[96]
                    if not bool(w):
                        z = z * z
                        a = a
                        w = uint255(w) * 0.5
                        continue 
                    z = z * z
                    a = z * a
                    w = uint255(w) * 0.5
                    continue 
                if a > -1 / z:
                    revert with 0, 17
                if mem[_10967 + 32] + mem[_10967 + 64] and z * a > -1 / mem[_10967 + 32] + mem[_10967 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if (mem[_10967 + 32] * z * a) + (mem[_10967 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_10967 + 32] * z * a) + (mem[_10967 + 64] * z * a):
                    revert with 0, 17
                if (mem[_10967 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_10967 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if (mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if (mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _10949 = mem[96]
                idx = idx + 1
                s = s + ((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                t = t + ((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                u = u + ((mem[_10967 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_10967 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_10967] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg4:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg4
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg4
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg4,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg4 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg4) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg4) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg4
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg4) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg4,
                   mem[mem[64] + 256]
        mem[64] = _2061 + (32 * arg2.length) + 1472
        mem[_2061 + (32 * arg2.length) + 1184] = 0
        mem[_2061 + (32 * arg2.length) + 1216] = 0
        mem[_2061 + (32 * arg2.length) + 1248] = 0
        mem[_2061 + (32 * arg2.length) + 1280] = 0
        mem[_2061 + (32 * arg2.length) + 1312] = 0
        mem[_2061 + (32 * arg2.length) + 1344] = 0
        mem[_2061 + (32 * arg2.length) + 1376] = 0
        mem[_2061 + (32 * arg2.length) + 1408] = 0
        mem[_2061 + (32 * arg2.length) + 1440] = 0
        mem[var124002] = var124001
        if not var124003 - 1:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _11997 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _12014 = mem[_11997]
                _12015 = mem[_11997 + 32]
                _12016 = mem[_11997 + 64]
                _12019 = mem[_11997 + 160]
                require mem[_11997 + 160] == bool(mem[_11997 + 160])
                _12056 = mem[_11997 + 192]
                require mem[_11997 + 192] == bool(mem[_11997 + 192])
                require mem[_11997 + 224] == bool(mem[_11997 + 224])
                _12107 = mem[_11997 + 256]
                require mem[_11997 + 256] == bool(mem[_11997 + 256])
                require mem[_11997 + 288] == bool(mem[_11997 + 288])
                if idx >= mem[_2061]:
                    revert with 0, 50
                _12142 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _12150 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _12154 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _12160 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _12168 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _12180 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 192] = bool(mem[_11997 + 288])
                mem[_12180 + 160] = bool(_12107)
                mem[_12168 + 128] = bool(_12056)
                mem[_12160 + 96] = bool(_12019)
                mem[_12154 + 64] = _12016
                mem[_12150 + 32] = _12015
                mem[_12142] = _12014
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _12221 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _12260 = mem[_12221 + 32]
                _12261 = mem[_12221 + 64]
                require mem[_12221 + 288] == mem[_12221 + 315 len 5]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 224] = mem[_12221]
                if _12260 > !_12261:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 256] = _12260 + _12261
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _12805 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _12805:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _12823 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_12823 + 224] == mem[_12823 + 251 len 5]
                require mem[_12823 + 256] == bool(mem[_12823 + 256])
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_12823] and 1 > -1 / mem[_12823]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_12823] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_12823]:
                        revert with 0, 17
                    if mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_12823 + 32] > !mem[_12823 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_12823 + 32] + mem[_12823 + 64] and 1 > -1 / mem[_12823 + 32] + mem[_12823 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_12823 + 32] + mem[_12823 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_12823 + 32] + mem[_12823 + 64]:
                            revert with 0, 17
                        if (mem[_12823 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_12823 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _12805 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_12823 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                        if mem[_12823 + 32] + mem[_12823 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_12823 + 32] + mem[_12823 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _12805 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _12805 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_12823 + 32] + mem[_12823 + 64] and x * y > -1 / mem[_12823 + 32] + mem[_12823 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_12823 + 32] * x * y) + (mem[_12823 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_12823 + 32] * x * y) + (mem[_12823 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_12823 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_12823 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _12805 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_12823 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_12823] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                    if mem[_12823] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_12823]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18):
                        revert with 0, 17
                    if mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_12823 + 32] > !mem[_12823 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_12823 + 32] + mem[_12823 + 64] and 1 > -1 / mem[_12823 + 32] + mem[_12823 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_12823 + 32] + mem[_12823 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_12823 + 32] + mem[_12823 + 64]:
                            revert with 0, 17
                        if (mem[_12823 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_12823 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _12805 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_12823 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                        if mem[_12823 + 32] + mem[_12823 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_12823 + 32] + mem[_12823 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _12805 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _12805 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_12823 + 32] + mem[_12823 + 64] and x * y > -1 / mem[_12823 + 32] + mem[_12823 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_12823 + 32] * x * y) + (mem[_12823 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_12823 + 32] * x * y) + (mem[_12823 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_12823 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_12823 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _12805 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_12823 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_12823] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _12805 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_12823] and x * y > -1 / mem[_12823]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if mem[_12823] * x * y and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_12823] * x * y:
                    revert with 0, 17
                if mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                    revert with 0, 17
                if mem[_12823 + 32] > !mem[_12823 + 64]:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_12823 + 32] + mem[_12823 + 64] and 1 > -1 / mem[_12823 + 32] + mem[_12823 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_12823 + 32] + mem[_12823 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_12823 + 32] + mem[_12823 + 64]:
                        revert with 0, 17
                    if (mem[_12823 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_12823 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _12805 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_12823 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                    if mem[_12823 + 32] + mem[_12823 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_12823 + 32] + mem[_12823 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _12805 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_12823 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                z = 10
                a = 1
                w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                while w > 1:
                    if z > -1 / z:
                        revert with 0, 17
                    _12805 = mem[96]
                    if not bool(w):
                        z = z * z
                        a = a
                        w = uint255(w) * 0.5
                        continue 
                    z = z * z
                    a = z * a
                    w = uint255(w) * 0.5
                    continue 
                if a > -1 / z:
                    revert with 0, 17
                if mem[_12823 + 32] + mem[_12823 + 64] and z * a > -1 / mem[_12823 + 32] + mem[_12823 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if (mem[_12823 + 32] * z * a) + (mem[_12823 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_12823 + 32] * z * a) + (mem[_12823 + 64] * z * a):
                    revert with 0, 17
                if (mem[_12823 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_12823 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if (mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if (mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _12805 = mem[96]
                idx = idx + 1
                s = s + ((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                t = t + ((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                u = u + ((mem[_12823 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_12823 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_12823] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg4:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg4
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg4
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg4,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg4 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg4) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg4) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg4
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg4) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg4,
                   mem[mem[64] + 256]
        mem[64] = _2061 + (32 * arg2.length) + 1760
        mem[_2061 + (32 * arg2.length) + 1472] = 0
        mem[_2061 + (32 * arg2.length) + 1504] = 0
        mem[_2061 + (32 * arg2.length) + 1536] = 0
        mem[_2061 + (32 * arg2.length) + 1568] = 0
        mem[_2061 + (32 * arg2.length) + 1600] = 0
        mem[_2061 + (32 * arg2.length) + 1632] = 0
        mem[_2061 + (32 * arg2.length) + 1664] = 0
        mem[_2061 + (32 * arg2.length) + 1696] = 0
        mem[_2061 + (32 * arg2.length) + 1728] = 0
        mem[var128002] = var128001
        if not var128003 - 1:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _13853 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _13870 = mem[_13853]
                _13871 = mem[_13853 + 32]
                _13872 = mem[_13853 + 64]
                _13875 = mem[_13853 + 160]
                require mem[_13853 + 160] == bool(mem[_13853 + 160])
                _13912 = mem[_13853 + 192]
                require mem[_13853 + 192] == bool(mem[_13853 + 192])
                require mem[_13853 + 224] == bool(mem[_13853 + 224])
                _13963 = mem[_13853 + 256]
                require mem[_13853 + 256] == bool(mem[_13853 + 256])
                require mem[_13853 + 288] == bool(mem[_13853 + 288])
                if idx >= mem[_2061]:
                    revert with 0, 50
                _13998 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _14006 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _14010 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _14016 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _14024 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _14036 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 192] = bool(mem[_13853 + 288])
                mem[_14036 + 160] = bool(_13963)
                mem[_14024 + 128] = bool(_13912)
                mem[_14016 + 96] = bool(_13875)
                mem[_14010 + 64] = _13872
                mem[_14006 + 32] = _13871
                mem[_13998] = _13870
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _14077 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _14116 = mem[_14077 + 32]
                _14117 = mem[_14077 + 64]
                require mem[_14077 + 288] == mem[_14077 + 315 len 5]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 224] = mem[_14077]
                if _14116 > !_14117:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 256] = _14116 + _14117
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _14661 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _14661:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _14679 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_14679 + 224] == mem[_14679 + 251 len 5]
                require mem[_14679 + 256] == bool(mem[_14679 + 256])
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_14679] and 1 > -1 / mem[_14679]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_14679] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_14679]:
                        revert with 0, 17
                    if mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_14679 + 32] > !mem[_14679 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_14679 + 32] + mem[_14679 + 64] and 1 > -1 / mem[_14679 + 32] + mem[_14679 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_14679 + 32] + mem[_14679 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_14679 + 32] + mem[_14679 + 64]:
                            revert with 0, 17
                        if (mem[_14679 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_14679 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _14661 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_14679 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                        if mem[_14679 + 32] + mem[_14679 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_14679 + 32] + mem[_14679 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _14661 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _14661 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_14679 + 32] + mem[_14679 + 64] and x * y > -1 / mem[_14679 + 32] + mem[_14679 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_14679 + 32] * x * y) + (mem[_14679 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_14679 + 32] * x * y) + (mem[_14679 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_14679 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_14679 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _14661 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_14679 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_14679] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                    if mem[_14679] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_14679]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18):
                        revert with 0, 17
                    if mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_14679 + 32] > !mem[_14679 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_14679 + 32] + mem[_14679 + 64] and 1 > -1 / mem[_14679 + 32] + mem[_14679 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_14679 + 32] + mem[_14679 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_14679 + 32] + mem[_14679 + 64]:
                            revert with 0, 17
                        if (mem[_14679 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_14679 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _14661 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_14679 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                        if mem[_14679 + 32] + mem[_14679 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_14679 + 32] + mem[_14679 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _14661 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    x = 10
                    y = 1
                    w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                    while w > 1:
                        if x > -1 / x:
                            revert with 0, 17
                        _14661 = mem[96]
                        if not bool(w):
                            x = x * x
                            y = y
                            w = uint255(w) * 0.5
                            continue 
                        x = x * x
                        y = x * y
                        w = uint255(w) * 0.5
                        continue 
                    if y > -1 / x:
                        revert with 0, 17
                    if mem[_14679 + 32] + mem[_14679 + 64] and x * y > -1 / mem[_14679 + 32] + mem[_14679 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_14679 + 32] * x * y) + (mem[_14679 + 64] * x * y) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_14679 + 32] * x * y) + (mem[_14679 + 64] * x * y):
                        revert with 0, 17
                    if (mem[_14679 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_14679 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _14661 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_14679 + 32] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_14679] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                x = 10
                y = 1
                w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                while w > 1:
                    if x > -1 / x:
                        revert with 0, 17
                    _14661 = mem[96]
                    if not bool(w):
                        x = x * x
                        y = y
                        w = uint255(w) * 0.5
                        continue 
                    x = x * x
                    y = x * y
                    w = uint255(w) * 0.5
                    continue 
                if y > -1 / x:
                    revert with 0, 17
                if mem[_14679] and x * y > -1 / mem[_14679]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if mem[_14679] * x * y and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_14679] * x * y:
                    revert with 0, 17
                if mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                    revert with 0, 17
                if mem[_14679 + 32] > !mem[_14679 + 64]:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_14679 + 32] + mem[_14679 + 64] and 1 > -1 / mem[_14679 + 32] + mem[_14679 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_14679 + 32] + mem[_14679 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_14679 + 32] + mem[_14679 + 64]:
                        revert with 0, 17
                    if (mem[_14679 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_14679 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _14661 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_14679 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                if bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78)) or bool(bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32)):
                    if mem[_14679 + 32] + mem[_14679 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_14679 + 32] + mem[_14679 + 64]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if (mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                        revert with 0, 17
                    if (mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                        revert with 0, 17
                    if v > !((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if u > !((mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if s > !((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if (mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                        revert with 0, 17
                    if t > !((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    _14661 = mem[96]
                    idx = idx + 1
                    s = s + ((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                    t = t + ((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                    u = u + ((mem[_14679 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    v = v + ((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                    continue 
                z = 10
                a = 1
                w = -mem[mem[(32 * idx) + _2061 + 32]] + 18
                while w > 1:
                    if z > -1 / z:
                        revert with 0, 17
                    _14661 = mem[96]
                    if not bool(w):
                        z = z * z
                        a = a
                        w = uint255(w) * 0.5
                        continue 
                    z = z * z
                    a = z * a
                    w = uint255(w) * 0.5
                    continue 
                if a > -1 / z:
                    revert with 0, 17
                if mem[_14679 + 32] + mem[_14679 + 64] and z * a > -1 / mem[_14679 + 32] + mem[_14679 + 64]:
                    revert with 0, 17
                if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                    revert with 0, 50
                if (mem[_14679 + 32] * z * a) + (mem[_14679 + 64] * z * a) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_14679 + 32] * z * a) + (mem[_14679 + 64] * z * a):
                    revert with 0, 17
                if (mem[_14679 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                    revert with 0, 17
                if v > !((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if u > !((mem[_14679 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if (mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if s > !((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                if (mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                if t > !((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                _14661 = mem[96]
                idx = idx + 1
                s = s + ((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                t = t + ((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                u = u + ((mem[_14679 + 32] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_14679 + 64] * z * a * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                v = v + ((mem[_14679] * x * y * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg4:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg4
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg4
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg4,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg4 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg4) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg4) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg4
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg4) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg4,
                   mem[mem[64] + 256]
        mem[64] = _2061 + (32 * arg2.length) + 2048
        mem[_2061 + (32 * arg2.length) + 1760] = 0
        mem[_2061 + (32 * arg2.length) + 1792] = 0
        mem[_2061 + (32 * arg2.length) + 1824] = 0
        mem[_2061 + (32 * arg2.length) + 1856] = 0
        mem[_2061 + (32 * arg2.length) + 1888] = 0
        mem[_2061 + (32 * arg2.length) + 1920] = 0
        mem[_2061 + (32 * arg2.length) + 1952] = 0
        mem[_2061 + (32 * arg2.length) + 1984] = 0
        mem[_2061 + (32 * arg2.length) + 2016] = 0
        mem[var132002] = var132001
        if var132003 - 1:
            # nil
        else:
            idx = 0
            while idx < arg2.length:
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveConfigurationData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _15709 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _15726 = mem[_15709]
                _15727 = mem[_15709 + 32]
                _15728 = mem[_15709 + 64]
                _15731 = mem[_15709 + 160]
                require mem[_15709 + 160] == bool(mem[_15709 + 160])
                _15768 = mem[_15709 + 192]
                require mem[_15709 + 192] == bool(mem[_15709 + 192])
                require mem[_15709 + 224] == bool(mem[_15709 + 224])
                _15819 = mem[_15709 + 256]
                require mem[_15709 + 256] == bool(mem[_15709 + 256])
                require mem[_15709 + 288] == bool(mem[_15709 + 288])
                if idx >= mem[_2061]:
                    revert with 0, 50
                _15854 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _15862 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _15866 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _15872 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _15880 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                _15892 = mem[(32 * idx) + _2061 + 32]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 192] = bool(mem[_15709 + 288])
                mem[_15892 + 160] = bool(_15819)
                mem[_15880 + 128] = bool(_15768)
                mem[_15872 + 96] = bool(_15731)
                mem[_15866 + 64] = _15728
                mem[_15862 + 32] = _15727
                mem[_15854] = _15726
                if idx >= mem[96]:
                    revert with 0, 50
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getReserveData(address rg1) with:
                        gas gas_remaining wei
                       args address(mem[(32 * idx) + 128])
                mem[mem[64] len 320] = ext_call.return_data[0 len 320]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _15933 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 320
                _15972 = mem[_15933 + 32]
                _15973 = mem[_15933 + 64]
                require mem[_15933 + 288] == mem[_15933 + 315 len 5]
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 224] = mem[_15933]
                if _15972 > !_15973:
                    revert with 0, 17
                if idx >= mem[_2061]:
                    revert with 0, 50
                mem[mem[(32 * idx) + _2061 + 32] + 256] = _15972 + _15973
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _16517 = mem[96]
            idx = 0
            s = 0
            t = 0
            u = 0
            v = 0
            while idx < _16517:
                if idx >= mem[96]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * idx) + 140 len 20]
                require ext_code.size(sub_5f9d4d2eAddress)
                staticcall sub_5f9d4d2eAddress.getUserReserveData(address rg1, address rg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(arg1)
                mem[mem[64] len 288] = ext_call.return_data[0 len 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _16535 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 288
                require mem[_16535 + 224] == mem[_16535 + 251 len 5]
                require mem[_16535 + 256] == bool(mem[_16535 + 256])
                if idx >= mem[_2061]:
                    revert with 0, 50
                if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                    revert with 0, 17
                if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                    if mem[_16535] and 1 > -1 / mem[_16535]:
                        revert with 0, 17
                    if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                        revert with 0, 50
                    if mem[_16535] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_16535]:
                        revert with 0, 17
                    if mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                        revert with 0, 17
                    if mem[_16535 + 32] > !mem[_16535 + 64]:
                        revert with 0, 17
                    if idx >= mem[_2061]:
                        revert with 0, 50
                    if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                        revert with 0, 17
                    if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                        if mem[_16535 + 32] + mem[_16535 + 64] and 1 > -1 / mem[_16535 + 32] + mem[_16535 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_16535 + 32] + mem[_16535 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_16535 + 32] + mem[_16535 + 64]:
                            revert with 0, 17
                        if (mem[_16535 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16535 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_16535 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16535 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _16517 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_16535 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16535 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                    if not bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78) and not bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32):
                        # nil
                    else:
                        if mem[_16535 + 32] + mem[_16535 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_16535 + 32] + mem[_16535 + 64]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if (mem[_16535 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_16535 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_16535 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_16535 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                            revert with 0, 17
                        if (mem[_16535 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16535 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                            revert with 0, 17
                        if v > !((mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if u > !((mem[_16535 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16535 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if s > !((mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if (mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                            revert with 0, 17
                        if t > !((mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        _16517 = mem[96]
                        idx = idx + 1
                        s = s + ((mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                        t = t + ((mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                        u = u + ((mem[_16535 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16535 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        v = v + ((mem[_16535] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                        continue 
                else:
                    if not bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78) and not bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32):
                        # nil
                    else:
                        if mem[_16535] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_16535]:
                            revert with 0, 17
                        if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                            revert with 0, 50
                        if mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18):
                            revert with 0, 17
                        if mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -500000000000000001:
                            revert with 0, 17
                        if mem[_16535 + 32] > !mem[_16535 + 64]:
                            revert with 0, 17
                        if idx >= mem[_2061]:
                            revert with 0, 50
                        if 18 < mem[mem[(32 * idx) + _2061 + 32]]:
                            revert with 0, 17
                        if not -mem[mem[(32 * idx) + _2061 + 32]] + 18:
                            if mem[_16535 + 32] + mem[_16535 + 64] and 1 > -1 / mem[_16535 + 32] + mem[_16535 + 64]:
                                revert with 0, 17
                            if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                                revert with 0, 50
                            if mem[_16535 + 32] + mem[_16535 + 64] and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / mem[_16535 + 32] + mem[_16535 + 64]:
                                revert with 0, 17
                            if (mem[_16535 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16535 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                                revert with 0, 17
                            if v > !((mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                                revert with 0, 17
                            if u > !((mem[_16535 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16535 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                                revert with 0, 17
                            if idx >= mem[_2061]:
                                revert with 0, 50
                            if (mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                                revert with 0, 17
                            if s > !((mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                                revert with 0, 17
                            if idx >= mem[_2061]:
                                revert with 0, 50
                            if (mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                                revert with 0, 17
                            if t > !((mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            _16517 = mem[96]
                            idx = idx + 1
                            s = s + ((mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                            t = t + ((mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                            u = u + ((mem[_16535 + 32] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16535 + 64] * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                            v = v + ((mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                            continue 
                        if not bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 78) and not bool(-mem[mem[(32 * idx) + _2061 + 32]] + 18 < 32):
                            # nil
                        else:
                            if mem[_16535 + 32] + mem[_16535 + 64] and 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) > -1 / mem[_16535 + 32] + mem[_16535 + 64]:
                                revert with 0, 17
                            if idx >= mem[ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 673]:
                                revert with 0, 50
                            if (mem[_16535 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_16535 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) and mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705] > -1 / (mem[_16535 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)) + (mem[_16535 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18)):
                                revert with 0, 17
                            if (mem[_16535 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16535 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) > -500000000000000001:
                                revert with 0, 17
                            if v > !((mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                                revert with 0, 17
                            if u > !((mem[_16535 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16535 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18):
                                revert with 0, 17
                            if idx >= mem[_2061]:
                                revert with 0, 50
                            if (mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 64] > -1 / (mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                                revert with 0, 17
                            if s > !((mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000):
                                revert with 0, 17
                            if idx >= mem[_2061]:
                                revert with 0, 50
                            if (mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 and mem[mem[(32 * idx) + _2061 + 32] + 32] > -1 / (mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18:
                                revert with 0, 17
                            if t > !((mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000):
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            _16517 = mem[96]
                            idx = idx + 1
                            s = s + ((mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 64] / 10000)
                            t = t + ((mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18 * mem[mem[(32 * idx) + _2061 + 32] + 32] / 10000)
                            u = u + ((mem[_16535 + 32] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + (mem[_16535 + 64] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                            v = v + ((mem[_16535] * 10^(-mem[mem[(32 * idx) + _2061 + 32]] + 18) * mem[(32 * idx) + ceil32(32 * arg2.length) + (6 * ceil32(return_data.size)) + 705]) + 5 * 10^17 / 10^18)
                            continue 
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 577] = v
            if u > !arg4:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 609] = u + arg4
            if not v:
                if 10^18 < arg5:
                    revert with 0, 17
                if v and -arg5 + 10^18 > -1 / v:
                    revert with 0, 17
                if (10^18 * v) - (arg5 * v) > -500000000000000001:
                    revert with 0, 17
                if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                    revert with 0, 17
                mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
                mem[mem[64] + 32] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417]
                mem[mem[64] + 64] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449]
                mem[mem[64] + 96] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481]
                mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
                mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
                mem[mem[64] + 192] = v
                mem[mem[64] + 224] = u + arg4
                mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
                return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                       mem[mem[64] + 32 len 160],
                       v,
                       u + arg4,
                       mem[mem[64] + 256]
            if t > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 449] = 10000 * t / v
            if s > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 481] = 10000 * s / v
            if u + arg4 > 0x68db8bac710cb295e9e1b089a027525460aa64c2f837b4a2339c0ebedfa43:
                revert with 0, 17
            if not v:
                revert with 0, 18
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 417] = (10000 * u) + (10000 * arg4) / v
            if 10^18 < arg5:
                revert with 0, 17
            if v and -arg5 + 10^18 > -1 / v:
                revert with 0, 17
            if (10^18 * v) - (arg5 * v) > -500000000000000001:
                revert with 0, 17
            if s < (10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18:
                revert with 0, 17
            mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 385] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64]] = u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18)
            mem[mem[64] + 32] = (10000 * u) + (10000 * arg4) / v
            mem[mem[64] + 64] = 10000 * t / v
            mem[mem[64] + 96] = 10000 * s / v
            mem[mem[64] + 128] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 513]
            mem[mem[64] + 160] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 545]
            mem[mem[64] + 192] = v
            mem[mem[64] + 224] = u + arg4
            mem[mem[64] + 256] = mem[ceil32(32 * arg2.length) + (2 * ceil32(return_data.size)) + 641]
            return u + arg4 < s - ((10^18 * v) + (-1 * arg5 * v) + 5 * 10^17 / 10^18), 
                   (10000 * u) + (10000 * arg4) / v,
                   10000 * t / v,
                   10000 * s / v,
                   mem[mem[64] + 128 len 64],
                   v,
                   u + arg4,
                   mem[mem[64] + 256]
}



}

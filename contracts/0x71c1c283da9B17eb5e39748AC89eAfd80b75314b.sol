contract main {




// =====================  Runtime code  =====================


#
#  - withdraw(uint256 arg1, uint256 arg2)
#  - emergencyWithdraw(uint256 arg1)
#  - deposit(uint256 arg1, uint256 arg2)
#
address owner;
address stor1;
address stor2;
uint32 stor3; offset 224
uint128 stor3;
uint128 stor3; offset 112
uint256 sub_28949ab7;
uint256 sub_5fff87ab;
uint256 stor6;
uint256 totalValueLocked;
uint8 stor8;
uint8 stor8; offset 8
uint8 stor8; offset 16
uint8 stor8; offset 24
uint8 stor8; offset 32
uint8 stor8; offset 40
uint8 stor8; offset 48
uint8 stor8; offset 56
uint8 stor8; offset 64
uint8 stor8; offset 72
uint8 stor8; offset 80
address badAddress; offset 96
uint256 stor8; offset 80
uint256 stor8; offset 72
uint256 stor8; offset 64
uint256 stor8; offset 56
uint256 stor8; offset 48
uint256 stor8; offset 40
uint256 stor8; offset 32
uint256 stor8; offset 24
uint256 stor8; offset 16
uint256 stor8; offset 8
address devAddr;
address treasuryAddr;
address investorAddr;
address sub_0c418998Address;
address sub_9b8e09d0Address;
uint256 sub_4a7d91a1;
uint256 devPercent;
uint256 treasuryPercent;
uint256 investorPercent;
mapping of uint256 depositTime;
array of struct poolInfo;
array of struct stor20;
mapping of uint256 stor21;
mapping of struct userInfo;
uint256 totalAllocPoint;
uint256 startTimestamp;

function treasuryPercent() payable {
    return treasuryPercent
}

function investorPercent() payable {
    return investorPercent
}

function poolLength() payable {
    return poolInfo.length
}

function sub_0c418998(?) payable {
    return sub_0c418998Address
}

function poolInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require arg1 < poolInfo.length
    return poolInfo[arg1].field_0, 
           poolInfo[arg1].field_256,
           poolInfo[arg1].field_512,
           poolInfo[arg1].field_768,
           poolInfo[arg1].field_1024
}

function totalAllocPoint() payable {
    return totalAllocPoint
}

function sub_28949ab7(?) payable {
    return sub_28949ab7
}

function treasuryAddr() payable {
    return treasuryAddr
}

function depositTime(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return depositTime[arg1]
}

function sub_4a7d91a1(?) payable {
    return sub_4a7d91a1
}

function sub_4ca193d3(?) payable {
    return bool(uint8(stor8.field_8))
}

function sub_5fff87ab(?) payable {
    return sub_5fff87ab
}

function owner() payable {
    return owner
}

function userInfo(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return userInfo[arg1][arg2].field_0, userInfo[arg1][arg2].field_256
}

function sub_9b8e09d0(?) payable {
    return sub_9b8e09d0Address
}

function bad() payable {
    return badAddress
}

function investorAddr() payable {
    return investorAddr
}

function devAddr() payable {
    return devAddr
}

function startTimestamp() payable {
    return startTimestamp
}

function totalValueLocked() payable {
    return totalValueLocked
}

function devPercent() payable {
    return devPercent
}

function _fallback() payable {
    revert
}

function sub_61a72da7(?) payable {
    return (100 * stor6 / 3)
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setInvestorAddr(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if investorAddr != msg.sender:
        revert with 0, 'setInvestorAddr: wut?'
    investorAddr = arg1
}

function setTreasuryAddr(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if treasuryAddr != msg.sender:
        revert with 0, 'setTreasuryAddr: wut?'
    treasuryAddr = arg1
}

function dev(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if devAddr != msg.sender:
        revert with 0, 'dev: wut?'
    devAddr = arg1
    emit SetDevAddress(msg.sender, arg1);
}

function sub_522b64f0(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == bool(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    Mask(248, 0, stor8.field_8) = Mask(248, 0, bool(arg1))
}

function sub_1725025d(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if depositTime[address(msg.sender)] > block.timestamp:
        return 0, depositTime[address(msg.sender)]
    if not userInfo[arg1][address(msg.sender)].field_0:
        return 0, depositTime[address(msg.sender)]
    return 1, depositTime[address(msg.sender)]
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_86ec567d(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require arg1 < poolInfo.length
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    return ext_call.return_data[0]
}

function sub_529a2d8d(?) payable {
    require ext_code.size(stor1)
    staticcall stor1.latestRoundData() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 160
    require ext_call.return_data[0] == ext_call.return_data[22 len 10]
    require ext_call.return_data[32] == ext_call.return_data[32]
    require ext_call.return_data[64] == ext_call.return_data[64]
    require ext_call.return_data[96] == ext_call.return_data[96]
    require ext_call.return_data[128] == ext_call.return_data[150 len 10]
    return (ext_call.return_data[32] / 100 * 10^6)
}

function setDevPercent(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if 0 > arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'setDevPercent: invalid percent value'
    if arg1 > 1000:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'setDevPercent: invalid percent value'
    if treasuryPercent + arg1 + investorPercent > 1000:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'setDevPercent: total percent over max'
    devPercent = arg1
}

function setInvestorPercent(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if 0 > arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'setInvestorPercent: invalid percent value'
    if arg1 > 1000:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'setInvestorPercent: invalid percent value'
    if devPercent + arg1 + treasuryPercent > 1000:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'setInvestorPercent: total percent over max'
    investorPercent = arg1
}

function setTreasuryPercent(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if 0 > arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'setTreasuryPercent: invalid percent value'
    if arg1 > 1000:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'setTreasuryPercent: invalid percent value'
    if devPercent + arg1 + investorPercent > 1000:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'setTreasuryPercent: total percent over max'
    treasuryPercent = arg1
}

function setLPTokenAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor2 = arg1
    require ext_code.size(stor2)
    staticcall stor2.getReserves() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    uint32(stor3.field_224) = ext_call.return_data[92 len 4]
    Mask(112, 0, stor3.field_112) = ext_call.return_data[50 len 14]
    Mask(112, 0, stor3.field_0) = ext_call.return_data[18 len 14]
    if Mask(112, 0, stor3.field_0) > Mask(112, 0, stor3.field_112):
        uint8(stor8.field_0) = 0
}

function sub_53b63393(?) payable {
    require ext_code.size(stor2)
    staticcall stor2.getReserves() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    uint32(stor3.field_224) = ext_call.return_data[92 len 4]
    Mask(112, 0, stor3.field_112) = ext_call.return_data[50 len 14]
    Mask(112, 0, stor3.field_0) = ext_call.return_data[18 len 14]
    require ext_code.size(stor1)
    staticcall stor1.latestRoundData() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 160
    require ext_call.return_data[0] == ext_call.return_data[22 len 10]
    require ext_call.return_data[32] == ext_call.return_data[32]
    require ext_call.return_data[64] == ext_call.return_data[64]
    require ext_call.return_data[96] == ext_call.return_data[96]
    require ext_call.return_data[128] == ext_call.return_data[150 len 10]
    require ext_code.size(stor2)
    staticcall stor2.0x18160ddd with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    require ext_call.return_data[0]
    if not uint8(stor8.field_0):
        sub_28949ab7 = 2 * 10^18 * Mask(112, 0, stor3.field_112) * ext_call.return_data[32] / 100 * 10^6 / ext_call.return_data[0]
        require Mask(112, 0, Mask(112, 0, stor3.field_0) / 10^18)
        sub_5fff87ab = Mask(112, 0, Mask(112, 0, stor3.field_112) / Mask(112, 0, Mask(112, 0, stor3.field_0) / 10^18)) * ext_call.return_data[32] / 100 * 10^6
    else:
        sub_28949ab7 = 2 * 10^18 * Mask(112, 0, stor3.field_0) * ext_call.return_data[32] / 100 * 10^6 / ext_call.return_data[0]
        require Mask(112, 0, Mask(112, 0, stor3.field_112) / 10^18)
        sub_5fff87ab = Mask(112, 0, Mask(112, 0, stor3.field_0) / Mask(112, 0, Mask(112, 0, stor3.field_112) / 10^18)) * ext_call.return_data[32] / 100 * 10^6
    return sub_28949ab7, sub_5fff87ab
}

function sub_4a02893c(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require arg1 < poolInfo.length
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if bool(uint8(stor8.field_8)) == 1:
        require ext_code.size(stor2)
        staticcall stor2.getReserves() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        uint32(stor3.field_224) = ext_call.return_data[92 len 4]
        Mask(112, 0, stor3.field_112) = ext_call.return_data[50 len 14]
        Mask(112, 0, stor3.field_0) = ext_call.return_data[18 len 14]
        require ext_code.size(stor1)
        staticcall stor1.latestRoundData() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 160
        require ext_call.return_data[0] == ext_call.return_data[22 len 10]
        require ext_call.return_data[32] == ext_call.return_data[32]
        require ext_call.return_data[64] == ext_call.return_data[64]
        require ext_call.return_data[96] == ext_call.return_data[96]
        require ext_call.return_data[128] == ext_call.return_data[150 len 10]
        require ext_code.size(stor2)
        staticcall stor2.0x18160ddd with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        require ext_call.return_data[0]
        if not uint8(stor8.field_0):
            sub_28949ab7 = 2 * 10^18 * Mask(112, 0, stor3.field_112) * ext_call.return_data[32] / 100 * 10^6 / ext_call.return_data[0]
            require Mask(112, 0, Mask(112, 0, stor3.field_0) / 10^18)
            sub_5fff87ab = Mask(112, 0, Mask(112, 0, stor3.field_112) / Mask(112, 0, Mask(112, 0, stor3.field_0) / 10^18)) * ext_call.return_data[32] / 100 * 10^6
        else:
            sub_28949ab7 = 2 * 10^18 * Mask(112, 0, stor3.field_0) * ext_call.return_data[32] / 100 * 10^6 / ext_call.return_data[0]
            require Mask(112, 0, Mask(112, 0, stor3.field_112) / 10^18)
            sub_5fff87ab = Mask(112, 0, Mask(112, 0, stor3.field_0) / Mask(112, 0, Mask(112, 0, stor3.field_112) / 10^18)) * ext_call.return_data[32] / 100 * 10^6
        totalValueLocked = ext_call.return_data[0] * sub_28949ab7 / 10^18
        if totalValueLocked >= 200000 * 10^18:
            Mask(240, 0, stor8.field_16) = 1
            if totalValueLocked >= 400000 * 10^18:
                Mask(232, 0, stor8.field_24) = 1
                if totalValueLocked >= 800000 * 10^18:
                    Mask(224, 0, stor8.field_32) = 1
                    if totalValueLocked >= 1600000 * 10^18:
                        Mask(216, 0, stor8.field_40) = 1
                        if totalValueLocked >= 3200000 * 10^18:
                            Mask(208, 0, stor8.field_48) = 1
                            if totalValueLocked >= 6400000 * 10^18:
                                Mask(200, 0, stor8.field_56) = 1
                                if totalValueLocked >= 12800000 * 10^18:
                                    Mask(192, 0, stor8.field_64) = 1
                                    if totalValueLocked >= 25600000 * 10^18:
                                        Mask(184, 0, stor8.field_72) = 1
                                        if totalValueLocked >= 51200000 * 10^18:
                                            Mask(176, 0, stor8.field_80) = 1
        if bool(uint8(stor8.field_16)) == 1:
            stor6 = 6
        if bool(uint8(stor8.field_24)) == 1:
            stor6 = 12
        if bool(uint8(stor8.field_32)) == 1:
            stor6 = 24
        if bool(uint8(stor8.field_40)) == 1:
            stor6 = 48
        if bool(uint8(stor8.field_48)) == 1:
            stor6 = 96
        if bool(uint8(stor8.field_56)) == 1:
            stor6 = 192
        if bool(uint8(stor8.field_64)) == 1:
            stor6 = 384
        if bool(uint8(stor8.field_72)) == 1:
            stor6 = 768
        if bool(uint8(stor8.field_80)) == 1:
            stor6 = 1536
        require sub_5fff87ab
        sub_4a7d91a1 = 10^18 * totalValueLocked / sub_5fff87ab * stor6 / 8760 * 24 * 3600
}

function rewarderBonusTokenInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require arg1 < poolInfo.length
    mem[0] = 19
    if not poolInfo[arg1].field_1024:
        return 0, 64, 0
    require ext_code.size(poolInfo[arg1].field_1024)
    staticcall poolInfo[arg1].field_1024.rewardToken() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(poolInfo[arg1].field_1024)
    staticcall poolInfo[arg1].field_1024.rewardToken() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[(2 * ceil32(return_data.size)) + 96] = 4
    mem[(2 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
    mem[(2 * ceil32(return_data.size)) + 132] = 0, mem[(2 * ceil32(return_data.size)) + 132 len 28]
    mem[(2 * ceil32(return_data.size)) + 136] = 0
    staticcall address(ext_call.return_data[0]).mem[(2 * ceil32(return_data.size)) + 132 len 4] with:
            gas gas_remaining wei
    if not return_data.size:
        if not ext_call.success:
            return address(ext_call.return_data[0]), 64, 3, '???', 0
        if ext_call.return_data[0] < 64:
            if ext_call.return_data[0] != 32:
                return address(ext_call.return_data[0]), 64, 3, '???', 0
            require 0 < ext_call.return_data[0]
            require 0 < ext_call.return_data[0]
            return address(ext_call.return_data[0]), 64, 0, None
        require ext_call.return_data[0] >= 32
        _215 = mem[128]
        require mem[128] <= test266151307()
        require mem[128] + 159 < ext_call.return_data[0] + 128
        _227 = mem[mem[128] + 128]
        require mem[mem[128] + 128] <= test266151307()
        require (2 * ceil32(return_data.size)) + ceil32(mem[mem[128] + 128]) + 164 <= test266151307() and ceil32(mem[mem[128] + 128]) + 164 >= 132
        mem[64] = (2 * ceil32(return_data.size)) + ceil32(mem[mem[128] + 128]) + 164
        mem[(2 * ceil32(return_data.size)) + 132] = mem[mem[128] + 128]
        require _215 + _227 + 160 <= ext_call.return_data[0] + 128
        mem[(2 * ceil32(return_data.size)) + 164 len ceil32(_227)] = mem[_215 + 160 len ceil32(_227)]
        if ceil32(_227) <= _227:
            mem[mem[64]] = address(ext_call.return_data[0])
            mem[mem[64] + 32] = 64
            _395 = mem[(2 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 64] = mem[(2 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 96 len ceil32(_395)] = mem[(2 * ceil32(return_data.size)) + 164 len ceil32(_395)]
            if ceil32(_395) > _395:
                mem[mem[64] + _395 + 96] = 0
            return address(ext_call.return_data[0]), 64, mem[mem[64] + 64 len ceil32(_395) + 32]
        mem[(2 * ceil32(return_data.size)) + _227 + 164] = 0
        mem[mem[64]] = address(ext_call.return_data[0])
        mem[mem[64] + 32] = 64
        _399 = mem[(2 * ceil32(return_data.size)) + 132]
        mem[mem[64] + 64] = mem[(2 * ceil32(return_data.size)) + 132]
        mem[mem[64] + 96 len ceil32(_399)] = mem[(2 * ceil32(return_data.size)) + 164 len ceil32(_399)]
        if ceil32(_399) > _399:
            mem[mem[64] + _399 + 96] = 0
        return address(ext_call.return_data[0]), 64, mem[mem[64] + 64 len ceil32(_399) + 32]
    mem[(2 * ceil32(return_data.size)) + 132] = return_data.size
    mem[(2 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
    if not ext_call.success:
        return address(ext_call.return_data[0]), 64, 3, '???', 0
    if return_data.size < 64:
        if 32 != return_data.size:
            return address(ext_call.return_data[0]), 64, 3, '???', 0
        require 0 < return_data.size
        require 0 < return_data.size
        mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = address(ext_call.return_data[0])
        mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = 64
        mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
        mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 261 len ceil32(mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
        if ceil32(mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
            mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 261] = 0
        return address(ext_call.return_data[0]), 
               Array(len=mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 261 len ceil32(mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])])
    require return_data.size >= 32
    _217 = mem[(2 * ceil32(return_data.size)) + 164]
    require mem[(2 * ceil32(return_data.size)) + 164] <= test266151307()
    require (2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 164] + 195 < (2 * ceil32(return_data.size)) + return_data.size + 164
    _228 = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 164] + 164]
    require mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
    require (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
    mem[64] = (2 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 164] + 164]) + 165
    mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(2 * ceil32(return_data.size)) + mem[(2 * ceil32(return_data.size)) + 164] + 164]
    require _217 + _228 + 64 <= return_data.size + 32
    mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_228)] = mem[(2 * ceil32(return_data.size)) + _217 + 196 len ceil32(_228)]
    if ceil32(_228) > _228:
        mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + _228 + 165] = 0
    mem[mem[64]] = address(ext_call.return_data[0])
    mem[mem[64] + 32] = 64
    mem[mem[64] + 64] = _228
    mem[mem[64] + 96 len ceil32(_228)] = mem[(2 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_228)]
    if ceil32(_228) > _228:
        mem[mem[64] + _228 + 96] = 0
    return address(ext_call.return_data[0]), Array(len=_228, data=mem[mem[64] + 96 len ceil32(_228)])
}

function updatePool(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require arg1 < poolInfo.length
    if block.timestamp > poolInfo[arg1].field_512:
        require ext_code.size(poolInfo[arg1].field_0)
        staticcall poolInfo[arg1].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        if not ext_call.return_data[0]:
            poolInfo[arg1].field_512 = block.timestamp
        else:
            if poolInfo[arg1].field_512 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.timestamp - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    require ext_code.size(badAddress)
                    call badAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devAddr, 0
                else:
                    require 0 / totalAllocPoint
                    if 0 / totalAllocPoint * devPercent / 0 / totalAllocPoint != devPercent:
                        revert with 0, 'SafeMath: multiplication overflow'
                    require ext_code.size(badAddress)
                    call badAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devAddr, 0 / totalAllocPoint * devPercent / 1000
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    require ext_code.size(badAddress)
                    call badAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args treasuryAddr, 0
                else:
                    require 0 / totalAllocPoint
                    if 0 / totalAllocPoint * treasuryPercent / 0 / totalAllocPoint != treasuryPercent:
                        revert with 0, 'SafeMath: multiplication overflow'
                    require ext_code.size(badAddress)
                    call badAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args treasuryAddr, 0 / totalAllocPoint * treasuryPercent / 1000
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    require ext_code.size(badAddress)
                    call badAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args investorAddr, 0
                else:
                    require 0 / totalAllocPoint
                    if 0 / totalAllocPoint * investorPercent / 0 / totalAllocPoint != investorPercent:
                        revert with 0, 'SafeMath: multiplication overflow'
                    require ext_code.size(badAddress)
                    call badAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args investorAddr, 0 / totalAllocPoint * investorPercent / 1000
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    require ext_code.size(badAddress)
                    call badAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0
                else:
                    require 0 / totalAllocPoint
                    if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                        revert with 0, 'SafeMath: multiplication overflow'
                    require ext_code.size(badAddress)
                    call badAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if not 0 / ext_call.return_data[0]:
                        if poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        require 0 / ext_call.return_data[0]
                        if (1000 * 0 / ext_call.return_data[0]) - (devPercent * 0 / ext_call.return_data[0]) - (treasuryPercent * 0 / ext_call.return_data[0]) - (investorPercent * 0 / ext_call.return_data[0]) / 0 / ext_call.return_data[0] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if poolInfo[arg1].field_768 + ((1000 * 0 / ext_call.return_data[0]) - (devPercent * 0 / ext_call.return_data[0]) - (treasuryPercent * 0 / ext_call.return_data[0]) - (investorPercent * 0 / ext_call.return_data[0]) / 1000) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[arg1].field_768 += (1000 * 0 / ext_call.return_data[0]) - (devPercent * 0 / ext_call.return_data[0]) - (treasuryPercent * 0 / ext_call.return_data[0]) - (investorPercent * 0 / ext_call.return_data[0]) / 1000
                else:
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if not 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]:
                        if poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        require 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        if (1000 * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (devPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (investorPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) / 10^12 * 0 / totalAllocPoint / ext_call.return_data[0] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if poolInfo[arg1].field_768 + ((1000 * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (devPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (investorPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) / 1000) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[arg1].field_768 += (1000 * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (devPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (investorPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) / 1000
            else:
                require block.timestamp - poolInfo[arg1].field_512
                if (block.timestamp * sub_4a7d91a1) - (poolInfo[arg1].field_512 * sub_4a7d91a1) / block.timestamp - poolInfo[arg1].field_512 != sub_4a7d91a1:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (block.timestamp * sub_4a7d91a1) - (poolInfo[arg1].field_512 * sub_4a7d91a1):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devAddr, 0
                    else:
                        require 0 / totalAllocPoint
                        if 0 / totalAllocPoint * devPercent / 0 / totalAllocPoint != devPercent:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devAddr, 0 / totalAllocPoint * devPercent / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args treasuryAddr, 0
                    else:
                        require 0 / totalAllocPoint
                        if 0 / totalAllocPoint * treasuryPercent / 0 / totalAllocPoint != treasuryPercent:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args treasuryAddr, 0 / totalAllocPoint * treasuryPercent / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args investorAddr, 0
                    else:
                        require 0 / totalAllocPoint
                        if 0 / totalAllocPoint * investorPercent / 0 / totalAllocPoint != investorPercent:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args investorAddr, 0 / totalAllocPoint * investorPercent / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0
                    else:
                        require 0 / totalAllocPoint
                        if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if not 0 / ext_call.return_data[0]:
                            if poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            require 0 / ext_call.return_data[0]
                            if (1000 * 0 / ext_call.return_data[0]) - (devPercent * 0 / ext_call.return_data[0]) - (treasuryPercent * 0 / ext_call.return_data[0]) - (investorPercent * 0 / ext_call.return_data[0]) / 0 / ext_call.return_data[0] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if poolInfo[arg1].field_768 + ((1000 * 0 / ext_call.return_data[0]) - (devPercent * 0 / ext_call.return_data[0]) - (treasuryPercent * 0 / ext_call.return_data[0]) - (investorPercent * 0 / ext_call.return_data[0]) / 1000) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += (1000 * 0 / ext_call.return_data[0]) - (devPercent * 0 / ext_call.return_data[0]) - (treasuryPercent * 0 / ext_call.return_data[0]) - (investorPercent * 0 / ext_call.return_data[0]) / 1000
                    else:
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if not 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]:
                            if poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            require 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            if (1000 * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (devPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (investorPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) / 10^12 * 0 / totalAllocPoint / ext_call.return_data[0] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if poolInfo[arg1].field_768 + ((1000 * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (devPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (investorPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) / 1000) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += (1000 * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (devPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) - (investorPercent * 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) / 1000
                else:
                    require (block.timestamp * sub_4a7d91a1) - (poolInfo[arg1].field_512 * sub_4a7d91a1)
                    if (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / (block.timestamp * sub_4a7d91a1) - (poolInfo[arg1].field_512 * sub_4a7d91a1) != poolInfo[arg1].field_256:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devAddr, 0
                    else:
                        require (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint
                        if (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint * devPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint != devPercent:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint * devPercent / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args treasuryAddr, 0
                    else:
                        require (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint
                        if (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint * treasuryPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint != treasuryPercent:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args treasuryAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint * treasuryPercent / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args investorAddr, 0
                    else:
                        require (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint
                        if (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint * investorPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint != investorPercent:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args investorAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint * investorPercent / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0
                    else:
                        require (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint
                        if (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if not 0 / ext_call.return_data[0]:
                            if poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            require 0 / ext_call.return_data[0]
                            if (1000 * 0 / ext_call.return_data[0]) - (devPercent * 0 / ext_call.return_data[0]) - (treasuryPercent * 0 / ext_call.return_data[0]) - (investorPercent * 0 / ext_call.return_data[0]) / 0 / ext_call.return_data[0] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if poolInfo[arg1].field_768 + ((1000 * 0 / ext_call.return_data[0]) - (devPercent * 0 / ext_call.return_data[0]) - (treasuryPercent * 0 / ext_call.return_data[0]) - (investorPercent * 0 / ext_call.return_data[0]) / 1000) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += (1000 * 0 / ext_call.return_data[0]) - (devPercent * 0 / ext_call.return_data[0]) - (treasuryPercent * 0 / ext_call.return_data[0]) - (investorPercent * 0 / ext_call.return_data[0]) / 1000
                    else:
                        require (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint
                        if 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if not 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]:
                            if poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            require 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            if (1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) / 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if poolInfo[arg1].field_768 + ((1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) / 1000) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += (1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) / 1000
            poolInfo[arg1].field_512 = block.timestamp
            emit UpdatePool(poolInfo[arg1].field_512, ext_call.return_data[0], poolInfo[arg1].field_768, arg1);
}

function massUpdatePools() payable {
    mem[64] = 96
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 19
        if block.timestamp > poolInfo[idx].field_512:
            mem[mem[64] + 4] = this.address
            require ext_code.size(poolInfo[idx].field_0)
            staticcall poolInfo[idx].field_0.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1539 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1540 = mem[_1539]
            require mem[_1539] == mem[_1539]
            if not mem[_1539]:
                poolInfo[idx].field_512 = block.timestamp
            else:
                if poolInfo[idx].field_512 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - poolInfo[idx].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devAddr, 0
                    else:
                        require 0 / totalAllocPoint
                        if 0 / totalAllocPoint * devPercent / 0 / totalAllocPoint != devPercent:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devAddr, 0 / totalAllocPoint * devPercent / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args treasuryAddr, 0
                    else:
                        require 0 / totalAllocPoint
                        if 0 / totalAllocPoint * treasuryPercent / 0 / totalAllocPoint != treasuryPercent:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args treasuryAddr, 0 / totalAllocPoint * treasuryPercent / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args investorAddr, 0
                    else:
                        require 0 / totalAllocPoint
                        if 0 / totalAllocPoint * investorPercent / 0 / totalAllocPoint != investorPercent:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args investorAddr, 0 / totalAllocPoint * investorPercent / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0
                    else:
                        require 0 / totalAllocPoint
                        if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        if mem[_1539] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require mem[_1539]
                        if not 0 / mem[_1539]:
                            if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            require 0 / mem[_1539]
                            if (1000 * 0 / mem[_1539]) - (devPercent * 0 / mem[_1539]) - (treasuryPercent * 0 / mem[_1539]) - (investorPercent * 0 / mem[_1539]) / 0 / mem[_1539] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1539]) - (devPercent * 0 / mem[_1539]) - (treasuryPercent * 0 / mem[_1539]) - (investorPercent * 0 / mem[_1539]) / 1000) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += (1000 * 0 / mem[_1539]) - (devPercent * 0 / mem[_1539]) - (treasuryPercent * 0 / mem[_1539]) - (investorPercent * 0 / mem[_1539]) / 1000
                    else:
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if mem[_1539] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require mem[_1539]
                        if not 10^12 * 0 / totalAllocPoint / mem[_1539]:
                            if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            require 10^12 * 0 / totalAllocPoint / mem[_1539]
                            if (1000 * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) / 10^12 * 0 / totalAllocPoint / mem[_1539] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if poolInfo[idx].field_768 + ((1000 * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) / 1000) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += (1000 * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) / 1000
                else:
                    require block.timestamp - poolInfo[idx].field_512
                    if (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1) / block.timestamp - poolInfo[idx].field_512 != sub_4a7d91a1:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * devPercent / 0 / totalAllocPoint != devPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, 0 / totalAllocPoint * devPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * treasuryPercent / 0 / totalAllocPoint != treasuryPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0 / totalAllocPoint * treasuryPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * investorPercent / 0 / totalAllocPoint != investorPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, 0 / totalAllocPoint * investorPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                        else:
                            require 0 / totalAllocPoint
                            if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if mem[_1539] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1539]
                            if not 0 / mem[_1539]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 0 / mem[_1539]
                                if (1000 * 0 / mem[_1539]) - (devPercent * 0 / mem[_1539]) - (treasuryPercent * 0 / mem[_1539]) - (investorPercent * 0 / mem[_1539]) / 0 / mem[_1539] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1539]) - (devPercent * 0 / mem[_1539]) - (treasuryPercent * 0 / mem[_1539]) - (investorPercent * 0 / mem[_1539]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 0 / mem[_1539]) - (devPercent * 0 / mem[_1539]) - (treasuryPercent * 0 / mem[_1539]) - (investorPercent * 0 / mem[_1539]) / 1000
                        else:
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_1539] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1539]
                            if not 10^12 * 0 / totalAllocPoint / mem[_1539]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 10^12 * 0 / totalAllocPoint / mem[_1539]
                                if (1000 * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) / 10^12 * 0 / totalAllocPoint / mem[_1539] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1539]) / 1000
                    else:
                        require (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1)
                        if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1) != poolInfo[idx].field_256:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, 0
                        else:
                            require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                            if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * devPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != devPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * devPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0
                        else:
                            require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                            if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * treasuryPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != treasuryPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * treasuryPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, 0
                        else:
                            require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                            if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * investorPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != investorPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * investorPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                        else:
                            require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                            if (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                            if mem[_1539] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1539]
                            if not 0 / mem[_1539]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 0 / mem[_1539]
                                if (1000 * 0 / mem[_1539]) - (devPercent * 0 / mem[_1539]) - (treasuryPercent * 0 / mem[_1539]) - (investorPercent * 0 / mem[_1539]) / 0 / mem[_1539] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1539]) - (devPercent * 0 / mem[_1539]) - (treasuryPercent * 0 / mem[_1539]) - (investorPercent * 0 / mem[_1539]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 0 / mem[_1539]) - (devPercent * 0 / mem[_1539]) - (treasuryPercent * 0 / mem[_1539]) - (investorPercent * 0 / mem[_1539]) / 1000
                        else:
                            require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                            if 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_1539] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1539]
                            if not 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539]
                                if (1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539]) / 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1539]) / 1000
                poolInfo[idx].field_512 = block.timestamp
                mem[mem[64]] = poolInfo[idx].field_512
                mem[mem[64] + 32] = _1540
                mem[mem[64] + 64] = poolInfo[idx].field_768
                emit UpdatePool(poolInfo[idx].field_512, _1540, poolInfo[idx].field_768, idx);
        idx = idx + 1
        continue 
}

function updateEmissionRate(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 19
        if block.timestamp > poolInfo[idx].field_512:
            mem[mem[64] + 4] = this.address
            require ext_code.size(poolInfo[idx].field_0)
            staticcall poolInfo[idx].field_0.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1545 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1546 = mem[_1545]
            require mem[_1545] == mem[_1545]
            if not mem[_1545]:
                poolInfo[idx].field_512 = block.timestamp
            else:
                if poolInfo[idx].field_512 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - poolInfo[idx].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devAddr, 0
                    else:
                        require 0 / totalAllocPoint
                        if 0 / totalAllocPoint * devPercent / 0 / totalAllocPoint != devPercent:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devAddr, 0 / totalAllocPoint * devPercent / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args treasuryAddr, 0
                    else:
                        require 0 / totalAllocPoint
                        if 0 / totalAllocPoint * treasuryPercent / 0 / totalAllocPoint != treasuryPercent:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args treasuryAddr, 0 / totalAllocPoint * treasuryPercent / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args investorAddr, 0
                    else:
                        require 0 / totalAllocPoint
                        if 0 / totalAllocPoint * investorPercent / 0 / totalAllocPoint != investorPercent:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args investorAddr, 0 / totalAllocPoint * investorPercent / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0
                    else:
                        require 0 / totalAllocPoint
                        if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                            revert with 0, 'SafeMath: multiplication overflow'
                        require ext_code.size(badAddress)
                        call badAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        if mem[_1545] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require mem[_1545]
                        if not 0 / mem[_1545]:
                            if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            require 0 / mem[_1545]
                            if (1000 * 0 / mem[_1545]) - (devPercent * 0 / mem[_1545]) - (treasuryPercent * 0 / mem[_1545]) - (investorPercent * 0 / mem[_1545]) / 0 / mem[_1545] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1545]) - (devPercent * 0 / mem[_1545]) - (treasuryPercent * 0 / mem[_1545]) - (investorPercent * 0 / mem[_1545]) / 1000) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += (1000 * 0 / mem[_1545]) - (devPercent * 0 / mem[_1545]) - (treasuryPercent * 0 / mem[_1545]) - (investorPercent * 0 / mem[_1545]) / 1000
                    else:
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if mem[_1545] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require mem[_1545]
                        if not 10^12 * 0 / totalAllocPoint / mem[_1545]:
                            if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            require 10^12 * 0 / totalAllocPoint / mem[_1545]
                            if (1000 * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) / 10^12 * 0 / totalAllocPoint / mem[_1545] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if poolInfo[idx].field_768 + ((1000 * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) / 1000) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += (1000 * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) / 1000
                else:
                    require block.timestamp - poolInfo[idx].field_512
                    if (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1) / block.timestamp - poolInfo[idx].field_512 != sub_4a7d91a1:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1):
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * devPercent / 0 / totalAllocPoint != devPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, 0 / totalAllocPoint * devPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * treasuryPercent / 0 / totalAllocPoint != treasuryPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0 / totalAllocPoint * treasuryPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * investorPercent / 0 / totalAllocPoint != investorPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, 0 / totalAllocPoint * investorPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                        else:
                            require 0 / totalAllocPoint
                            if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if mem[_1545] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1545]
                            if not 0 / mem[_1545]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 0 / mem[_1545]
                                if (1000 * 0 / mem[_1545]) - (devPercent * 0 / mem[_1545]) - (treasuryPercent * 0 / mem[_1545]) - (investorPercent * 0 / mem[_1545]) / 0 / mem[_1545] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1545]) - (devPercent * 0 / mem[_1545]) - (treasuryPercent * 0 / mem[_1545]) - (investorPercent * 0 / mem[_1545]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 0 / mem[_1545]) - (devPercent * 0 / mem[_1545]) - (treasuryPercent * 0 / mem[_1545]) - (investorPercent * 0 / mem[_1545]) / 1000
                        else:
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_1545] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1545]
                            if not 10^12 * 0 / totalAllocPoint / mem[_1545]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 10^12 * 0 / totalAllocPoint / mem[_1545]
                                if (1000 * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) / 10^12 * 0 / totalAllocPoint / mem[_1545] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1545]) / 1000
                    else:
                        require (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1)
                        if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1) != poolInfo[idx].field_256:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, 0
                        else:
                            require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                            if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * devPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != devPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * devPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0
                        else:
                            require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                            if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * treasuryPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != treasuryPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * treasuryPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, 0
                        else:
                            require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                            if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * investorPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != investorPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * investorPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                        else:
                            require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                            if (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                            if mem[_1545] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1545]
                            if not 0 / mem[_1545]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 0 / mem[_1545]
                                if (1000 * 0 / mem[_1545]) - (devPercent * 0 / mem[_1545]) - (treasuryPercent * 0 / mem[_1545]) - (investorPercent * 0 / mem[_1545]) / 0 / mem[_1545] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1545]) - (devPercent * 0 / mem[_1545]) - (treasuryPercent * 0 / mem[_1545]) - (investorPercent * 0 / mem[_1545]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 0 / mem[_1545]) - (devPercent * 0 / mem[_1545]) - (treasuryPercent * 0 / mem[_1545]) - (investorPercent * 0 / mem[_1545]) / 1000
                        else:
                            require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                            if 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_1545] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1545]
                            if not 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545]
                                if (1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545]) / 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1545]) / 1000
                poolInfo[idx].field_512 = block.timestamp
                mem[mem[64]] = poolInfo[idx].field_512
                mem[mem[64] + 32] = _1546
                mem[mem[64] + 64] = poolInfo[idx].field_768
                emit UpdatePool(poolInfo[idx].field_512, _1546, poolInfo[idx].field_768, idx);
        idx = idx + 1
        continue 
    sub_4a7d91a1 = arg1
    emit UpdateEmissionRate(arg1, msg.sender);
}

function set(uint256 arg1, uint256 arg2, address arg3, bool arg4) payable {
    mem[64] = 96
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if ext_code.size(arg3) > 0:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 19
            if block.timestamp > poolInfo[idx].field_512:
                mem[mem[64] + 4] = this.address
                require ext_code.size(poolInfo[idx].field_0)
                staticcall poolInfo[idx].field_0.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1616 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1626 = mem[_1616]
                require mem[_1616] == mem[_1616]
                if not mem[_1616]:
                    poolInfo[idx].field_512 = block.timestamp
                else:
                    if poolInfo[idx].field_512 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - poolInfo[idx].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * devPercent / 0 / totalAllocPoint != devPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, 0 / totalAllocPoint * devPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * treasuryPercent / 0 / totalAllocPoint != treasuryPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0 / totalAllocPoint * treasuryPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * investorPercent / 0 / totalAllocPoint != investorPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, 0 / totalAllocPoint * investorPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                        else:
                            require 0 / totalAllocPoint
                            if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if mem[_1616] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1616]
                            if not 0 / mem[_1616]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 0 / mem[_1616]
                                if (1000 * 0 / mem[_1616]) - (devPercent * 0 / mem[_1616]) - (treasuryPercent * 0 / mem[_1616]) - (investorPercent * 0 / mem[_1616]) / 0 / mem[_1616] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1616]) - (devPercent * 0 / mem[_1616]) - (treasuryPercent * 0 / mem[_1616]) - (investorPercent * 0 / mem[_1616]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 0 / mem[_1616]) - (devPercent * 0 / mem[_1616]) - (treasuryPercent * 0 / mem[_1616]) - (investorPercent * 0 / mem[_1616]) / 1000
                        else:
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_1616] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1616]
                            if not 10^12 * 0 / totalAllocPoint / mem[_1616]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 10^12 * 0 / totalAllocPoint / mem[_1616]
                                if (1000 * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) / 10^12 * 0 / totalAllocPoint / mem[_1616] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) / 1000
                    else:
                        require block.timestamp - poolInfo[idx].field_512
                        if (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1) / block.timestamp - poolInfo[idx].field_512 != sub_4a7d91a1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1):
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, 0
                            else:
                                require 0 / totalAllocPoint
                                if 0 / totalAllocPoint * devPercent / 0 / totalAllocPoint != devPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, 0 / totalAllocPoint * devPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0
                            else:
                                require 0 / totalAllocPoint
                                if 0 / totalAllocPoint * treasuryPercent / 0 / totalAllocPoint != treasuryPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0 / totalAllocPoint * treasuryPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, 0
                            else:
                                require 0 / totalAllocPoint
                                if 0 / totalAllocPoint * investorPercent / 0 / totalAllocPoint != investorPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, 0 / totalAllocPoint * investorPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                            else:
                                require 0 / totalAllocPoint
                                if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if mem[_1616] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1616]
                                if not 0 / mem[_1616]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 0 / mem[_1616]
                                    if (1000 * 0 / mem[_1616]) - (devPercent * 0 / mem[_1616]) - (treasuryPercent * 0 / mem[_1616]) - (investorPercent * 0 / mem[_1616]) / 0 / mem[_1616] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1616]) - (devPercent * 0 / mem[_1616]) - (treasuryPercent * 0 / mem[_1616]) - (investorPercent * 0 / mem[_1616]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 0 / mem[_1616]) - (devPercent * 0 / mem[_1616]) - (treasuryPercent * 0 / mem[_1616]) - (investorPercent * 0 / mem[_1616]) / 1000
                            else:
                                require 0 / totalAllocPoint
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_1616] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1616]
                                if not 10^12 * 0 / totalAllocPoint / mem[_1616]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 10^12 * 0 / totalAllocPoint / mem[_1616]
                                    if (1000 * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) / 10^12 * 0 / totalAllocPoint / mem[_1616] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1616]) / 1000
                        else:
                            require (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1)
                            if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1) != poolInfo[idx].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * devPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != devPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * devPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * treasuryPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != treasuryPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * treasuryPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * investorPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != investorPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * investorPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                if mem[_1616] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1616]
                                if not 0 / mem[_1616]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 0 / mem[_1616]
                                    if (1000 * 0 / mem[_1616]) - (devPercent * 0 / mem[_1616]) - (treasuryPercent * 0 / mem[_1616]) - (investorPercent * 0 / mem[_1616]) / 0 / mem[_1616] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1616]) - (devPercent * 0 / mem[_1616]) - (treasuryPercent * 0 / mem[_1616]) - (investorPercent * 0 / mem[_1616]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 0 / mem[_1616]) - (devPercent * 0 / mem[_1616]) - (treasuryPercent * 0 / mem[_1616]) - (investorPercent * 0 / mem[_1616]) / 1000
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_1616] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1616]
                                if not 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616]
                                    if (1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616]) / 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1616]) / 1000
                    poolInfo[idx].field_512 = block.timestamp
                    mem[mem[64]] = poolInfo[idx].field_512
                    mem[mem[64] + 32] = _1626
                    mem[mem[64] + 64] = poolInfo[idx].field_768
                    emit UpdatePool(poolInfo[idx].field_512, _1626, poolInfo[idx].field_768, idx);
            idx = idx + 1
            continue 
    else:
        if arg3:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'set: rewarder must be contract or zero'
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 19
            if block.timestamp > poolInfo[idx].field_512:
                mem[mem[64] + 4] = this.address
                require ext_code.size(poolInfo[idx].field_0)
                staticcall poolInfo[idx].field_0.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1619 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1627 = mem[_1619]
                require mem[_1619] == mem[_1619]
                if not mem[_1619]:
                    poolInfo[idx].field_512 = block.timestamp
                else:
                    if poolInfo[idx].field_512 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - poolInfo[idx].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * devPercent / 0 / totalAllocPoint != devPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, 0 / totalAllocPoint * devPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * treasuryPercent / 0 / totalAllocPoint != treasuryPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0 / totalAllocPoint * treasuryPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * investorPercent / 0 / totalAllocPoint != investorPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, 0 / totalAllocPoint * investorPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                        else:
                            require 0 / totalAllocPoint
                            if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if mem[_1619] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1619]
                            if not 0 / mem[_1619]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 0 / mem[_1619]
                                if (1000 * 0 / mem[_1619]) - (devPercent * 0 / mem[_1619]) - (treasuryPercent * 0 / mem[_1619]) - (investorPercent * 0 / mem[_1619]) / 0 / mem[_1619] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1619]) - (devPercent * 0 / mem[_1619]) - (treasuryPercent * 0 / mem[_1619]) - (investorPercent * 0 / mem[_1619]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 0 / mem[_1619]) - (devPercent * 0 / mem[_1619]) - (treasuryPercent * 0 / mem[_1619]) - (investorPercent * 0 / mem[_1619]) / 1000
                        else:
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_1619] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1619]
                            if not 10^12 * 0 / totalAllocPoint / mem[_1619]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 10^12 * 0 / totalAllocPoint / mem[_1619]
                                if (1000 * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) / 10^12 * 0 / totalAllocPoint / mem[_1619] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) / 1000
                    else:
                        require block.timestamp - poolInfo[idx].field_512
                        if (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1) / block.timestamp - poolInfo[idx].field_512 != sub_4a7d91a1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1):
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, 0
                            else:
                                require 0 / totalAllocPoint
                                if 0 / totalAllocPoint * devPercent / 0 / totalAllocPoint != devPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, 0 / totalAllocPoint * devPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0
                            else:
                                require 0 / totalAllocPoint
                                if 0 / totalAllocPoint * treasuryPercent / 0 / totalAllocPoint != treasuryPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0 / totalAllocPoint * treasuryPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, 0
                            else:
                                require 0 / totalAllocPoint
                                if 0 / totalAllocPoint * investorPercent / 0 / totalAllocPoint != investorPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, 0 / totalAllocPoint * investorPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                            else:
                                require 0 / totalAllocPoint
                                if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if mem[_1619] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1619]
                                if not 0 / mem[_1619]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 0 / mem[_1619]
                                    if (1000 * 0 / mem[_1619]) - (devPercent * 0 / mem[_1619]) - (treasuryPercent * 0 / mem[_1619]) - (investorPercent * 0 / mem[_1619]) / 0 / mem[_1619] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1619]) - (devPercent * 0 / mem[_1619]) - (treasuryPercent * 0 / mem[_1619]) - (investorPercent * 0 / mem[_1619]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 0 / mem[_1619]) - (devPercent * 0 / mem[_1619]) - (treasuryPercent * 0 / mem[_1619]) - (investorPercent * 0 / mem[_1619]) / 1000
                            else:
                                require 0 / totalAllocPoint
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_1619] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1619]
                                if not 10^12 * 0 / totalAllocPoint / mem[_1619]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 10^12 * 0 / totalAllocPoint / mem[_1619]
                                    if (1000 * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) / 10^12 * 0 / totalAllocPoint / mem[_1619] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1619]) / 1000
                        else:
                            require (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1)
                            if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1) != poolInfo[idx].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * devPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != devPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * devPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * treasuryPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != treasuryPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * treasuryPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * investorPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != investorPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * investorPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                if mem[_1619] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1619]
                                if not 0 / mem[_1619]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 0 / mem[_1619]
                                    if (1000 * 0 / mem[_1619]) - (devPercent * 0 / mem[_1619]) - (treasuryPercent * 0 / mem[_1619]) - (investorPercent * 0 / mem[_1619]) / 0 / mem[_1619] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1619]) - (devPercent * 0 / mem[_1619]) - (treasuryPercent * 0 / mem[_1619]) - (investorPercent * 0 / mem[_1619]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 0 / mem[_1619]) - (devPercent * 0 / mem[_1619]) - (treasuryPercent * 0 / mem[_1619]) - (investorPercent * 0 / mem[_1619]) / 1000
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_1619] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1619]
                                if not 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619]
                                    if (1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619]) / 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1619]) / 1000
                    poolInfo[idx].field_512 = block.timestamp
                    mem[mem[64]] = poolInfo[idx].field_512
                    mem[mem[64] + 32] = _1627
                    mem[mem[64] + 64] = poolInfo[idx].field_768
                    emit UpdatePool(poolInfo[idx].field_512, _1627, poolInfo[idx].field_768, idx);
            idx = idx + 1
            continue 
    require arg1 < poolInfo.length
    if poolInfo[arg1].field_256 > totalAllocPoint:
        revert with 0, 'SafeMath: subtraction overflow'
    if arg2 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint = totalAllocPoint - poolInfo[arg1].field_256 + arg2
    require arg1 < poolInfo.length
    poolInfo[arg1].field_256 = arg2
    require arg1 < poolInfo.length
    if not arg4:
        emit 0xa54644aa: arg2, arg4, arg1, poolInfo[arg1].field_1024
    else:
        poolInfo[arg1].field_1024 = arg3
        if arg4:
            emit 0xa54644aa: arg2, arg4, arg1, arg3
        else:
            require arg1 < poolInfo.length
            emit 0xa54644aa: arg2, arg4, arg1, poolInfo[arg1].field_1024
}

function add(uint256 arg1, address arg2, address arg3) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if ext_code.size(arg2) <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'add: LP token must be a valid contract'
    if ext_code.size(arg3) > 0:
        mem[0] = arg2
        mem[32] = 21
        if stor21[address(arg2)]:
            revert with 0, 'add: LP already added'
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 19
            if block.timestamp > poolInfo[idx].field_512:
                mem[mem[64] + 4] = this.address
                require ext_code.size(poolInfo[idx].field_0)
                staticcall poolInfo[idx].field_0.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1288 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1294 = mem[_1288]
                require mem[_1288] == mem[_1288]
                if not mem[_1288]:
                    poolInfo[idx].field_512 = block.timestamp
                else:
                    if poolInfo[idx].field_512 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - poolInfo[idx].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * devPercent / 0 / totalAllocPoint != devPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, 0 / totalAllocPoint * devPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * treasuryPercent / 0 / totalAllocPoint != treasuryPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0 / totalAllocPoint * treasuryPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * investorPercent / 0 / totalAllocPoint != investorPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, 0 / totalAllocPoint * investorPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                        else:
                            require 0 / totalAllocPoint
                            if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if mem[_1288] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1288]
                            if not 0 / mem[_1288]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 0 / mem[_1288]
                                if (1000 * 0 / mem[_1288]) - (devPercent * 0 / mem[_1288]) - (treasuryPercent * 0 / mem[_1288]) - (investorPercent * 0 / mem[_1288]) / 0 / mem[_1288] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1288]) - (devPercent * 0 / mem[_1288]) - (treasuryPercent * 0 / mem[_1288]) - (investorPercent * 0 / mem[_1288]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 0 / mem[_1288]) - (devPercent * 0 / mem[_1288]) - (treasuryPercent * 0 / mem[_1288]) - (investorPercent * 0 / mem[_1288]) / 1000
                        else:
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_1288] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1288]
                            if not 10^12 * 0 / totalAllocPoint / mem[_1288]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 10^12 * 0 / totalAllocPoint / mem[_1288]
                                if (1000 * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) / 10^12 * 0 / totalAllocPoint / mem[_1288] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) / 1000
                    else:
                        require block.timestamp - poolInfo[idx].field_512
                        if (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1) / block.timestamp - poolInfo[idx].field_512 != sub_4a7d91a1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1):
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, 0
                            else:
                                require 0 / totalAllocPoint
                                if 0 / totalAllocPoint * devPercent / 0 / totalAllocPoint != devPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, 0 / totalAllocPoint * devPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0
                            else:
                                require 0 / totalAllocPoint
                                if 0 / totalAllocPoint * treasuryPercent / 0 / totalAllocPoint != treasuryPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0 / totalAllocPoint * treasuryPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, 0
                            else:
                                require 0 / totalAllocPoint
                                if 0 / totalAllocPoint * investorPercent / 0 / totalAllocPoint != investorPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, 0 / totalAllocPoint * investorPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                            else:
                                require 0 / totalAllocPoint
                                if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if mem[_1288] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1288]
                                if not 0 / mem[_1288]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 0 / mem[_1288]
                                    if (1000 * 0 / mem[_1288]) - (devPercent * 0 / mem[_1288]) - (treasuryPercent * 0 / mem[_1288]) - (investorPercent * 0 / mem[_1288]) / 0 / mem[_1288] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1288]) - (devPercent * 0 / mem[_1288]) - (treasuryPercent * 0 / mem[_1288]) - (investorPercent * 0 / mem[_1288]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 0 / mem[_1288]) - (devPercent * 0 / mem[_1288]) - (treasuryPercent * 0 / mem[_1288]) - (investorPercent * 0 / mem[_1288]) / 1000
                            else:
                                require 0 / totalAllocPoint
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_1288] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1288]
                                if not 10^12 * 0 / totalAllocPoint / mem[_1288]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 10^12 * 0 / totalAllocPoint / mem[_1288]
                                    if (1000 * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) / 10^12 * 0 / totalAllocPoint / mem[_1288] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1288]) / 1000
                        else:
                            require (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1)
                            if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1) != poolInfo[idx].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * devPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != devPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * devPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * treasuryPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != treasuryPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * treasuryPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * investorPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != investorPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * investorPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                if mem[_1288] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1288]
                                if not 0 / mem[_1288]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 0 / mem[_1288]
                                    if (1000 * 0 / mem[_1288]) - (devPercent * 0 / mem[_1288]) - (treasuryPercent * 0 / mem[_1288]) - (investorPercent * 0 / mem[_1288]) / 0 / mem[_1288] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1288]) - (devPercent * 0 / mem[_1288]) - (treasuryPercent * 0 / mem[_1288]) - (investorPercent * 0 / mem[_1288]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 0 / mem[_1288]) - (devPercent * 0 / mem[_1288]) - (treasuryPercent * 0 / mem[_1288]) - (investorPercent * 0 / mem[_1288]) / 1000
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_1288] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1288]
                                if not 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288]
                                    if (1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288]) / 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1288]) / 1000
                    poolInfo[idx].field_512 = block.timestamp
                    mem[mem[64]] = poolInfo[idx].field_512
                    mem[mem[64] + 32] = _1294
                    mem[mem[64] + 64] = poolInfo[idx].field_768
                    emit UpdatePool(poolInfo[idx].field_512, _1294, poolInfo[idx].field_768, idx);
            idx = idx + 1
            continue 
    else:
        if arg3:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'add: rewarder must be contract or zero'
        mem[0] = arg2
        mem[32] = 21
        if stor21[address(arg2)]:
            revert with 0, 'add: LP already added'
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 19
            if block.timestamp > poolInfo[idx].field_512:
                mem[mem[64] + 4] = this.address
                require ext_code.size(poolInfo[idx].field_0)
                staticcall poolInfo[idx].field_0.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1289 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1299 = mem[_1289]
                require mem[_1289] == mem[_1289]
                if not mem[_1289]:
                    poolInfo[idx].field_512 = block.timestamp
                else:
                    if poolInfo[idx].field_512 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - poolInfo[idx].field_512:
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * devPercent / 0 / totalAllocPoint != devPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devAddr, 0 / totalAllocPoint * devPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * treasuryPercent / 0 / totalAllocPoint != treasuryPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args treasuryAddr, 0 / totalAllocPoint * treasuryPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, 0
                        else:
                            require 0 / totalAllocPoint
                            if 0 / totalAllocPoint * investorPercent / 0 / totalAllocPoint != investorPercent:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args investorAddr, 0 / totalAllocPoint * investorPercent / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0
                        else:
                            require 0 / totalAllocPoint
                            if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            require ext_code.size(badAddress)
                            call badAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if mem[_1289] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1289]
                            if not 0 / mem[_1289]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 0 / mem[_1289]
                                if (1000 * 0 / mem[_1289]) - (devPercent * 0 / mem[_1289]) - (treasuryPercent * 0 / mem[_1289]) - (investorPercent * 0 / mem[_1289]) / 0 / mem[_1289] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1289]) - (devPercent * 0 / mem[_1289]) - (treasuryPercent * 0 / mem[_1289]) - (investorPercent * 0 / mem[_1289]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 0 / mem[_1289]) - (devPercent * 0 / mem[_1289]) - (treasuryPercent * 0 / mem[_1289]) - (investorPercent * 0 / mem[_1289]) / 1000
                        else:
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if mem[_1289] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require mem[_1289]
                            if not 10^12 * 0 / totalAllocPoint / mem[_1289]:
                                if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require 10^12 * 0 / totalAllocPoint / mem[_1289]
                                if (1000 * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) / 10^12 * 0 / totalAllocPoint / mem[_1289] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if poolInfo[idx].field_768 + ((1000 * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) / 1000) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += (1000 * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) / 1000
                    else:
                        require block.timestamp - poolInfo[idx].field_512
                        if (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1) / block.timestamp - poolInfo[idx].field_512 != sub_4a7d91a1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1):
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, 0
                            else:
                                require 0 / totalAllocPoint
                                if 0 / totalAllocPoint * devPercent / 0 / totalAllocPoint != devPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, 0 / totalAllocPoint * devPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0
                            else:
                                require 0 / totalAllocPoint
                                if 0 / totalAllocPoint * treasuryPercent / 0 / totalAllocPoint != treasuryPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0 / totalAllocPoint * treasuryPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, 0
                            else:
                                require 0 / totalAllocPoint
                                if 0 / totalAllocPoint * investorPercent / 0 / totalAllocPoint != investorPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, 0 / totalAllocPoint * investorPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                            else:
                                require 0 / totalAllocPoint
                                if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if mem[_1289] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1289]
                                if not 0 / mem[_1289]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 0 / mem[_1289]
                                    if (1000 * 0 / mem[_1289]) - (devPercent * 0 / mem[_1289]) - (treasuryPercent * 0 / mem[_1289]) - (investorPercent * 0 / mem[_1289]) / 0 / mem[_1289] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1289]) - (devPercent * 0 / mem[_1289]) - (treasuryPercent * 0 / mem[_1289]) - (investorPercent * 0 / mem[_1289]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 0 / mem[_1289]) - (devPercent * 0 / mem[_1289]) - (treasuryPercent * 0 / mem[_1289]) - (investorPercent * 0 / mem[_1289]) / 1000
                            else:
                                require 0 / totalAllocPoint
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_1289] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1289]
                                if not 10^12 * 0 / totalAllocPoint / mem[_1289]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 10^12 * 0 / totalAllocPoint / mem[_1289]
                                    if (1000 * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) / 10^12 * 0 / totalAllocPoint / mem[_1289] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (devPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (treasuryPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) - (investorPercent * 10^12 * 0 / totalAllocPoint / mem[_1289]) / 1000
                        else:
                            require (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1)
                            if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / (block.timestamp * sub_4a7d91a1) - (poolInfo[idx].field_512 * sub_4a7d91a1) != poolInfo[idx].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * devPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != devPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * devPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * treasuryPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != treasuryPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args treasuryAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * treasuryPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * investorPercent / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != investorPercent:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args investorAddr, (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint * investorPercent / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                require ext_code.size(badAddress)
                                call badAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint) / 1000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint:
                                if mem[_1289] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1289]
                                if not 0 / mem[_1289]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 0 / mem[_1289]
                                    if (1000 * 0 / mem[_1289]) - (devPercent * 0 / mem[_1289]) - (treasuryPercent * 0 / mem[_1289]) - (investorPercent * 0 / mem[_1289]) / 0 / mem[_1289] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 0 / mem[_1289]) - (devPercent * 0 / mem[_1289]) - (treasuryPercent * 0 / mem[_1289]) - (investorPercent * 0 / mem[_1289]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 0 / mem[_1289]) - (devPercent * 0 / mem[_1289]) - (treasuryPercent * 0 / mem[_1289]) - (investorPercent * 0 / mem[_1289]) / 1000
                            else:
                                require (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint
                                if 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if mem[_1289] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require mem[_1289]
                                if not 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289]:
                                    if poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289]
                                    if (1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289]) / 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289] != -devPercent + -treasuryPercent + -investorPercent + 1000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if poolInfo[idx].field_768 + ((1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289]) / 1000) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += (1000 * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289]) - (devPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289]) - (treasuryPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289]) - (investorPercent * 10^12 * (block.timestamp * sub_4a7d91a1 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_4a7d91a1 * poolInfo[idx].field_256) / totalAllocPoint / mem[_1289]) / 1000
                    poolInfo[idx].field_512 = block.timestamp
                    mem[mem[64]] = poolInfo[idx].field_512
                    mem[mem[64] + 32] = _1299
                    mem[mem[64] + 64] = poolInfo[idx].field_768
                    emit UpdatePool(poolInfo[idx].field_512, _1299, poolInfo[idx].field_768, idx);
            idx = idx + 1
            continue 
    if totalAllocPoint + arg1 < totalAllocPoint:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint += arg1
    poolInfo.length++
    poolInfo[poolInfo.length].field_0 = arg2
    poolInfo[poolInfo.length].field_256 = arg1
    if block.timestamp > startTimestamp:
        poolInfo[poolInfo.length].field_512 = block.timestamp
    else:
        poolInfo[poolInfo.length].field_512 = startTimestamp
    poolInfo[poolInfo.length].field_768 = 0
    poolInfo[poolInfo.length].field_1024 = arg3
    if not stor21[address(arg2)]:
        stor20.length++
        stor20[stor20.length].field_0 = arg2
        stor20[stor20.length].field_160 = 0
        stor21[address(arg2)] = stor20.length
    if 1 > poolInfo.length:
        revert with 0, 'SafeMath: subtraction overflow'
    emit 0x4b16bd24: arg1, poolInfo.length - 1, arg2, arg3
}

function pendingTokens(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    require arg1 < poolInfo.length
    mem[100] = this.address
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[0]
    if block.timestamp <= poolInfo[arg1].field_512:
        mem[32] = 18
        if depositTime[address(msg.sender)] <= block.timestamp:
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256
                    mem[ceil32(return_data.size) + 128] = 0
                    mem[ceil32(return_data.size) + 160] = 128
                    mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           0,
                           ext_call.return_data[0],
                           mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                require arg1 < poolInfo.length
                mem[0] = 19
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 100] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256
                    mem[(2 * ceil32(return_data.size)) + 128] = 0
                    mem[(2 * ceil32(return_data.size)) + 160] = 128
                    mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           ext_call.return_data[0],
                           ext_call.return_data[0],
                           mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 96] = 4
                mem[64] = (4 * ceil32(return_data.size)) + 132
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                mem[(4 * ceil32(return_data.size)) + 136] = 0
                staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                        gas gas_remaining wei
                if not return_data.size:
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    if ext_call.return_data[0] < 64:
                        if ext_call.return_data[0] != 32:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                        require 0 < ext_call.return_data[0]
                        require 0 < ext_call.return_data[0]
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 0, None
                    require ext_call.return_data[0] >= 32
                    _11169 = 0, mem[132 len 28]
                    require 0, mem[132 len 28] <= test266151307()
                    require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                    _11779 = mem[0, mem[132 len 28] + 128]
                    require mem[0, mem[132 len 28] + 128] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                    mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                    require _11169 + _11779 + 160 <= ext_call.return_data[0] + 128
                    mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11779)] = mem[_11169 + 160 len ceil32(_11779)]
                    if ceil32(_11779) <= _11779:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22959 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23311 = mem[_22959]
                        require mem[_22959] == mem[_22959]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24015 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24015)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24015)]
                        if ceil32(_24015) > _24015:
                            mem[mem[64] + _24015 + 160] = 0
                        mem[mem[64] + 96] = _23311
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               _23311,
                               mem[mem[64] + 128 len ceil32(_24015) + 32]
                    mem[(4 * ceil32(return_data.size)) + _11779 + 164] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23135 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23487 = mem[_23135]
                    require mem[_23135] == mem[_23135]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24191 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24191)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24191)]
                    if ceil32(_24191) > _24191:
                        mem[mem[64] + _24191 + 160] = 0
                    mem[mem[64] + 96] = _23487
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23487,
                           mem[mem[64] + 128 len ceil32(_24191) + 32]
                mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                if return_data.size < 64:
                    if 32 != return_data.size:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    require 0 < return_data.size
                    require 0 < return_data.size
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                    if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                           ext_call.return_data[0]
                require return_data.size >= 32
                _11171 = mem[(4 * ceil32(return_data.size)) + 164]
                require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                _11780 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require _11171 + _11780 + 64 <= return_data.size + 32
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11780)] = mem[(4 * ceil32(return_data.size)) + _11171 + 196 len ceil32(_11780)]
                if ceil32(_11780) <= _11780:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22960 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23312 = mem[_22960]
                    require mem[_22960] == mem[_22960]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11780
                    mem[mem[64] + 160 len ceil32(_11780)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11780)]
                    if ceil32(_11780) > _11780:
                        mem[mem[64] + _11780 + 160] = 0
                    mem[mem[64] + 96] = _23312
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=_11780, data=mem[mem[64] + 160 len ceil32(_11780)]),
                           _23312
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11780 + 165] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23136 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23488 = mem[_23136]
                require mem[_23136] == mem[_23136]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11780
                mem[mem[64] + 160 len ceil32(_11780)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11780)]
                if ceil32(_11780) > _11780:
                    mem[mem[64] + _11780 + 160] = 0
                mem[mem[64] + 96] = _23488
                return -userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11780, data=mem[mem[64] + 160 len ceil32(_11780)]),
                       _23488
            require userInfo[arg1][address(arg2)].field_0
            if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11163 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11777 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11163 + _11777 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11777)] = mem[_11163 + 160 len ceil32(_11777)]
                if ceil32(_11777) <= _11777:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22955 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23307 = mem[_22955]
                    require mem[_22955] == mem[_22955]
                    mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24011 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24011)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24011)]
                    if ceil32(_24011) > _24011:
                        mem[mem[64] + _24011 + 160] = 0
                    mem[mem[64] + 96] = _23307
                    return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23307,
                           mem[mem[64] + 128 len ceil32(_24011) + 32]
                mem[(4 * ceil32(return_data.size)) + _11777 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23131 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23483 = mem[_23131]
                require mem[_23131] == mem[_23131]
                mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24187 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24187)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24187)]
                if ceil32(_24187) > _24187:
                    mem[mem[64] + _24187 + 160] = 0
                mem[mem[64] + 96] = _23483
                return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       _23483,
                       mem[mem[64] + 128 len ceil32(_24187) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11165 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11778 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11165 + _11778 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11778)] = mem[(4 * ceil32(return_data.size)) + _11165 + 196 len ceil32(_11778)]
            if ceil32(_11778) <= _11778:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _22956 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23308 = mem[_22956]
                require mem[_22956] == mem[_22956]
                mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11778
                mem[mem[64] + 160 len ceil32(_11778)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11778)]
                if ceil32(_11778) > _11778:
                    mem[mem[64] + _11778 + 160] = 0
                mem[mem[64] + 96] = _23308
                return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11778, data=mem[mem[64] + 160 len ceil32(_11778)]),
                       _23308
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11778 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23132 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23484 = mem[_23132]
            require mem[_23132] == mem[_23132]
            mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11778
            mem[mem[64] + 160 len ceil32(_11778)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11778)]
            if ceil32(_11778) > _11778:
                mem[mem[64] + _11778 + 160] = 0
            mem[mem[64] + 96] = _23484
            return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   address(ext_call.return_data[0]),
                   Array(len=_11778, data=mem[mem[64] + 160 len ceil32(_11778)]),
                   _23484
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11181 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11783 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11181 + _11783 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11783)] = mem[_11181 + 160 len ceil32(_11783)]
                if ceil32(_11783) <= _11783:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22967 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23319 = mem[_22967]
                    require mem[_22967] == mem[_22967]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24023 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24023)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24023)]
                    if ceil32(_24023) > _24023:
                        mem[mem[64] + _24023 + 160] = 0
                    mem[mem[64] + 96] = _23319
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           _23319,
                           mem[mem[64] + 128 len ceil32(_24023) + 32]
                mem[(4 * ceil32(return_data.size)) + _11783 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23143 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23495 = mem[_23143]
                require mem[_23143] == mem[_23143]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24199 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24199)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24199)]
                if ceil32(_24199) > _24199:
                    mem[mem[64] + _24199 + 160] = 0
                mem[mem[64] + 96] = _23495
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23495,
                       mem[mem[64] + 128 len ceil32(_24199) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11183 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11784 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11183 + _11784 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11784)] = mem[(4 * ceil32(return_data.size)) + _11183 + 196 len ceil32(_11784)]
            if ceil32(_11784) <= _11784:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _22968 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23320 = mem[_22968]
                require mem[_22968] == mem[_22968]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11784
                mem[mem[64] + 160 len ceil32(_11784)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11784)]
                if ceil32(_11784) > _11784:
                    mem[mem[64] + _11784 + 160] = 0
                mem[mem[64] + 96] = _23320
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=_11784, data=mem[mem[64] + 160 len ceil32(_11784)]),
                       _23320
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11784 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23144 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23496 = mem[_23144]
            require mem[_23144] == mem[_23144]
            mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11784
            mem[mem[64] + 160 len ceil32(_11784)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11784)]
            if ceil32(_11784) > _11784:
                mem[mem[64] + _11784 + 160] = 0
            mem[mem[64] + 96] = _23496
            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11784, data=mem[mem[64] + 160 len ceil32(_11784)]),
                   _23496
        require userInfo[arg1][address(arg2)].field_0
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 96] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 128
            mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
            mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
            return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   0,
                   128,
                   0,
                   ext_call.return_data[0],
                   mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
        require arg1 < poolInfo.length
        mem[0] = 19
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 100] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[(2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + 160] = 128
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
            return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   0,
                   128,
                   ext_call.return_data[0],
                   ext_call.return_data[0],
                   mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(4 * ceil32(return_data.size)) + 96] = 4
        mem[64] = (4 * ceil32(return_data.size)) + 132
        mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
        mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
        mem[(4 * ceil32(return_data.size)) + 136] = 0
        staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                gas gas_remaining wei
        if not return_data.size:
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if ext_call.return_data[0] < 64:
                if ext_call.return_data[0] != 32:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < ext_call.return_data[0]
                require 0 < ext_call.return_data[0]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       0,
                       None
            require ext_call.return_data[0] >= 32
            _11175 = 0, mem[132 len 28]
            require 0, mem[132 len 28] <= test266151307()
            require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
            _11781 = mem[0, mem[132 len 28] + 128]
            require mem[0, mem[132 len 28] + 128] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
            mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
            require _11175 + _11781 + 160 <= ext_call.return_data[0] + 128
            mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11781)] = mem[_11175 + 160 len ceil32(_11781)]
            if ceil32(_11781) <= _11781:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _22963 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23315 = mem[_22963]
                require mem[_22963] == mem[_22963]
                mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24019 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24019)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24019)]
                if ceil32(_24019) > _24019:
                    mem[mem[64] + _24019 + 160] = 0
                mem[mem[64] + 96] = _23315
                return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23315,
                       mem[mem[64] + 128 len ceil32(_24019) + 32]
            mem[(4 * ceil32(return_data.size)) + _11781 + 164] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23139 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23491 = mem[_23139]
            require mem[_23139] == mem[_23139]
            mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            _24195 = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 160 len ceil32(_24195)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24195)]
            if ceil32(_24195) > _24195:
                mem[mem[64] + _24195 + 160] = 0
            mem[mem[64] + 96] = _23491
            return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   _23491,
                   mem[mem[64] + 128 len ceil32(_24195) + 32]
        mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
        mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   ext_call.return_data[0],
                   3,
                   '???',
                   0
        if return_data.size < 64:
            if 32 != return_data.size:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            require 0 < return_data.size
            require 0 < return_data.size
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
            if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
            return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                   ext_call.return_data[0]
        require return_data.size >= 32
        _11177 = mem[(4 * ceil32(return_data.size)) + 164]
        require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
        _11782 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
        mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require _11177 + _11782 + 64 <= return_data.size + 32
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11782)] = mem[(4 * ceil32(return_data.size)) + _11177 + 196 len ceil32(_11782)]
        if ceil32(_11782) <= _11782:
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _22964 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23316 = mem[_22964]
            require mem[_22964] == mem[_22964]
            mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11782
            mem[mem[64] + 160 len ceil32(_11782)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11782)]
            if ceil32(_11782) > _11782:
                mem[mem[64] + _11782 + 160] = 0
            mem[mem[64] + 96] = _23316
            return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11782, data=mem[mem[64] + 160 len ceil32(_11782)]),
                   _23316
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11782 + 165] = 0
        mem[mem[64] + 4] = arg2
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _23140 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _23492 = mem[_23140]
        require mem[_23140] == mem[_23140]
        mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
        mem[mem[64] + 32] = address(ext_call.return_data[0])
        mem[mem[64] + 64] = 128
        mem[mem[64] + 128] = _11782
        mem[mem[64] + 160 len ceil32(_11782)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11782)]
        if ceil32(_11782) > _11782:
            mem[mem[64] + _11782 + 160] = 0
        mem[mem[64] + 96] = _23492
        return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
               address(ext_call.return_data[0]),
               Array(len=_11782, data=mem[mem[64] + 160 len ceil32(_11782)]),
               _23492
    if not ext_call.return_data[0]:
        mem[32] = 18
        if depositTime[address(msg.sender)] <= block.timestamp:
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256
                    mem[ceil32(return_data.size) + 128] = 0
                    mem[ceil32(return_data.size) + 160] = 128
                    mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           0,
                           ext_call.return_data[0],
                           mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                require arg1 < poolInfo.length
                mem[0] = 19
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 100] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256
                    mem[(2 * ceil32(return_data.size)) + 128] = 0
                    mem[(2 * ceil32(return_data.size)) + 160] = 128
                    mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           ext_call.return_data[0],
                           ext_call.return_data[0],
                           mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 96] = 4
                mem[64] = (4 * ceil32(return_data.size)) + 132
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                mem[(4 * ceil32(return_data.size)) + 136] = 0
                staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                        gas gas_remaining wei
                if not return_data.size:
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    if ext_call.return_data[0] < 64:
                        if ext_call.return_data[0] != 32:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                        require 0 < ext_call.return_data[0]
                        require 0 < ext_call.return_data[0]
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 0, None
                    require ext_call.return_data[0] >= 32
                    _11193 = 0, mem[132 len 28]
                    require 0, mem[132 len 28] <= test266151307()
                    require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                    _11787 = mem[0, mem[132 len 28] + 128]
                    require mem[0, mem[132 len 28] + 128] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                    mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                    require _11193 + _11787 + 160 <= ext_call.return_data[0] + 128
                    mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11787)] = mem[_11193 + 160 len ceil32(_11787)]
                    if ceil32(_11787) <= _11787:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _22975 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23327 = mem[_22975]
                        require mem[_22975] == mem[_22975]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24031 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24031)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24031)]
                        if ceil32(_24031) > _24031:
                            mem[mem[64] + _24031 + 160] = 0
                        mem[mem[64] + 96] = _23327
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               _23327,
                               mem[mem[64] + 128 len ceil32(_24031) + 32]
                    mem[(4 * ceil32(return_data.size)) + _11787 + 164] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23151 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23503 = mem[_23151]
                    require mem[_23151] == mem[_23151]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24207 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24207)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24207)]
                    if ceil32(_24207) > _24207:
                        mem[mem[64] + _24207 + 160] = 0
                    mem[mem[64] + 96] = _23503
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23503,
                           mem[mem[64] + 128 len ceil32(_24207) + 32]
                mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                if return_data.size < 64:
                    if 32 != return_data.size:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    require 0 < return_data.size
                    require 0 < return_data.size
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                    if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                           ext_call.return_data[0]
                require return_data.size >= 32
                _11195 = mem[(4 * ceil32(return_data.size)) + 164]
                require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                _11788 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require _11195 + _11788 + 64 <= return_data.size + 32
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11788)] = mem[(4 * ceil32(return_data.size)) + _11195 + 196 len ceil32(_11788)]
                if ceil32(_11788) <= _11788:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22976 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23328 = mem[_22976]
                    require mem[_22976] == mem[_22976]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11788
                    mem[mem[64] + 160 len ceil32(_11788)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11788)]
                    if ceil32(_11788) > _11788:
                        mem[mem[64] + _11788 + 160] = 0
                    mem[mem[64] + 96] = _23328
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=_11788, data=mem[mem[64] + 160 len ceil32(_11788)]),
                           _23328
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11788 + 165] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23152 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23504 = mem[_23152]
                require mem[_23152] == mem[_23152]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11788
                mem[mem[64] + 160 len ceil32(_11788)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11788)]
                if ceil32(_11788) > _11788:
                    mem[mem[64] + _11788 + 160] = 0
                mem[mem[64] + 96] = _23504
                return -userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11788, data=mem[mem[64] + 160 len ceil32(_11788)]),
                       _23504
            require userInfo[arg1][address(arg2)].field_0
            if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11187 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11785 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11187 + _11785 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11785)] = mem[_11187 + 160 len ceil32(_11785)]
                if ceil32(_11785) <= _11785:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22971 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23323 = mem[_22971]
                    require mem[_22971] == mem[_22971]
                    mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24027 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24027)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24027)]
                    if ceil32(_24027) > _24027:
                        mem[mem[64] + _24027 + 160] = 0
                    mem[mem[64] + 96] = _23323
                    return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23323,
                           mem[mem[64] + 128 len ceil32(_24027) + 32]
                mem[(4 * ceil32(return_data.size)) + _11785 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23147 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23499 = mem[_23147]
                require mem[_23147] == mem[_23147]
                mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24203 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24203)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24203)]
                if ceil32(_24203) > _24203:
                    mem[mem[64] + _24203 + 160] = 0
                mem[mem[64] + 96] = _23499
                return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       _23499,
                       mem[mem[64] + 128 len ceil32(_24203) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11189 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11786 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11189 + _11786 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11786)] = mem[(4 * ceil32(return_data.size)) + _11189 + 196 len ceil32(_11786)]
            if ceil32(_11786) <= _11786:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _22972 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23324 = mem[_22972]
                require mem[_22972] == mem[_22972]
                mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11786
                mem[mem[64] + 160 len ceil32(_11786)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11786)]
                if ceil32(_11786) > _11786:
                    mem[mem[64] + _11786 + 160] = 0
                mem[mem[64] + 96] = _23324
                return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11786, data=mem[mem[64] + 160 len ceil32(_11786)]),
                       _23324
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11786 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23148 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23500 = mem[_23148]
            require mem[_23148] == mem[_23148]
            mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11786
            mem[mem[64] + 160 len ceil32(_11786)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11786)]
            if ceil32(_11786) > _11786:
                mem[mem[64] + _11786 + 160] = 0
            mem[mem[64] + 96] = _23500
            return (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   address(ext_call.return_data[0]),
                   Array(len=_11786, data=mem[mem[64] + 160 len ceil32(_11786)]),
                   _23500
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11205 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11791 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11205 + _11791 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11791)] = mem[_11205 + 160 len ceil32(_11791)]
                if ceil32(_11791) <= _11791:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22983 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23335 = mem[_22983]
                    require mem[_22983] == mem[_22983]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24039 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24039)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24039)]
                    if ceil32(_24039) > _24039:
                        mem[mem[64] + _24039 + 160] = 0
                    mem[mem[64] + 96] = _23335
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           _23335,
                           mem[mem[64] + 128 len ceil32(_24039) + 32]
                mem[(4 * ceil32(return_data.size)) + _11791 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23159 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23511 = mem[_23159]
                require mem[_23159] == mem[_23159]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24215 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24215)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24215)]
                if ceil32(_24215) > _24215:
                    mem[mem[64] + _24215 + 160] = 0
                mem[mem[64] + 96] = _23511
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23511,
                       mem[mem[64] + 128 len ceil32(_24215) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11207 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11792 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11207 + _11792 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11792)] = mem[(4 * ceil32(return_data.size)) + _11207 + 196 len ceil32(_11792)]
            if ceil32(_11792) <= _11792:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _22984 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23336 = mem[_22984]
                require mem[_22984] == mem[_22984]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11792
                mem[mem[64] + 160 len ceil32(_11792)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11792)]
                if ceil32(_11792) > _11792:
                    mem[mem[64] + _11792 + 160] = 0
                mem[mem[64] + 96] = _23336
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=_11792, data=mem[mem[64] + 160 len ceil32(_11792)]),
                       _23336
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11792 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23160 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23512 = mem[_23160]
            require mem[_23160] == mem[_23160]
            mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11792
            mem[mem[64] + 160 len ceil32(_11792)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11792)]
            if ceil32(_11792) > _11792:
                mem[mem[64] + _11792 + 160] = 0
            mem[mem[64] + 96] = _23512
            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11792, data=mem[mem[64] + 160 len ceil32(_11792)]),
                   _23512
        require userInfo[arg1][address(arg2)].field_0
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 96] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 128
            mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
            mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
            return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   0,
                   128,
                   0,
                   ext_call.return_data[0],
                   mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
        require arg1 < poolInfo.length
        mem[0] = 19
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 100] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[(2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + 160] = 128
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
            return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   0,
                   128,
                   ext_call.return_data[0],
                   ext_call.return_data[0],
                   mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(4 * ceil32(return_data.size)) + 96] = 4
        mem[64] = (4 * ceil32(return_data.size)) + 132
        mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
        mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
        mem[(4 * ceil32(return_data.size)) + 136] = 0
        staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                gas gas_remaining wei
        if not return_data.size:
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if ext_call.return_data[0] < 64:
                if ext_call.return_data[0] != 32:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < ext_call.return_data[0]
                require 0 < ext_call.return_data[0]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       0,
                       None
            require ext_call.return_data[0] >= 32
            _11199 = 0, mem[132 len 28]
            require 0, mem[132 len 28] <= test266151307()
            require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
            _11789 = mem[0, mem[132 len 28] + 128]
            require mem[0, mem[132 len 28] + 128] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
            mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
            require _11199 + _11789 + 160 <= ext_call.return_data[0] + 128
            mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11789)] = mem[_11199 + 160 len ceil32(_11789)]
            if ceil32(_11789) <= _11789:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _22979 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23331 = mem[_22979]
                require mem[_22979] == mem[_22979]
                mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24035 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24035)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24035)]
                if ceil32(_24035) > _24035:
                    mem[mem[64] + _24035 + 160] = 0
                mem[mem[64] + 96] = _23331
                return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23331,
                       mem[mem[64] + 128 len ceil32(_24035) + 32]
            mem[(4 * ceil32(return_data.size)) + _11789 + 164] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23155 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23507 = mem[_23155]
            require mem[_23155] == mem[_23155]
            mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            _24211 = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 160 len ceil32(_24211)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24211)]
            if ceil32(_24211) > _24211:
                mem[mem[64] + _24211 + 160] = 0
            mem[mem[64] + 96] = _23507
            return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   _23507,
                   mem[mem[64] + 128 len ceil32(_24211) + 32]
        mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
        mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   ext_call.return_data[0],
                   3,
                   '???',
                   0
        if return_data.size < 64:
            if 32 != return_data.size:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            require 0 < return_data.size
            require 0 < return_data.size
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
            if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
            return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                   ext_call.return_data[0]
        require return_data.size >= 32
        _11201 = mem[(4 * ceil32(return_data.size)) + 164]
        require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
        _11790 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
        mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require _11201 + _11790 + 64 <= return_data.size + 32
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11790)] = mem[(4 * ceil32(return_data.size)) + _11201 + 196 len ceil32(_11790)]
        if ceil32(_11790) <= _11790:
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _22980 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23332 = mem[_22980]
            require mem[_22980] == mem[_22980]
            mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11790
            mem[mem[64] + 160 len ceil32(_11790)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11790)]
            if ceil32(_11790) > _11790:
                mem[mem[64] + _11790 + 160] = 0
            mem[mem[64] + 96] = _23332
            return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11790, data=mem[mem[64] + 160 len ceil32(_11790)]),
                   _23332
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11790 + 165] = 0
        mem[mem[64] + 4] = arg2
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _23156 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _23508 = mem[_23156]
        require mem[_23156] == mem[_23156]
        mem[mem[64]] = (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
        mem[mem[64] + 32] = address(ext_call.return_data[0])
        mem[mem[64] + 64] = 128
        mem[mem[64] + 128] = _11790
        mem[mem[64] + 160 len ceil32(_11790)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11790)]
        if ceil32(_11790) > _11790:
            mem[mem[64] + _11790 + 160] = 0
        mem[mem[64] + 96] = _23508
        return Mask(255, 1, (userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256), 
               address(ext_call.return_data[0]),
               Array(len=_11790, data=mem[mem[64] + 160 len ceil32(_11790)]),
               _23508
    if poolInfo[arg1].field_512 > block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.timestamp - poolInfo[arg1].field_512:
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not 0 / totalAllocPoint:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            mem[32] = 18
            if depositTime[address(msg.sender)] <= block.timestamp:
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not poolInfo[arg1].field_1024:
                        mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256
                        mem[ceil32(return_data.size) + 128] = 0
                        mem[ceil32(return_data.size) + 160] = 128
                        mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                        if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                            mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                        return -userInfo[arg1][address(arg2)].field_256, 
                               0,
                               128,
                               0,
                               ext_call.return_data[0],
                               mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                    require arg1 < poolInfo.length
                    mem[0] = 19
                    if not poolInfo[arg1].field_1024:
                        mem[ceil32(return_data.size) + 100] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256
                        mem[(2 * ceil32(return_data.size)) + 128] = 0
                        mem[(2 * ceil32(return_data.size)) + 160] = 128
                        mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                        mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                        if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                            mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                        return -userInfo[arg1][address(arg2)].field_256, 
                               0,
                               128,
                               ext_call.return_data[0],
                               ext_call.return_data[0],
                               mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.rewardToken() with:
                            gas gas_remaining wei
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.rewardToken() with:
                            gas gas_remaining wei
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    mem[(4 * ceil32(return_data.size)) + 96] = 4
                    mem[64] = (4 * ceil32(return_data.size)) + 132
                    mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                    mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                    mem[(4 * ceil32(return_data.size)) + 136] = 0
                    staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                            gas gas_remaining wei
                    if not return_data.size:
                        if not ext_call.success:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                        if ext_call.return_data[0] < 64:
                            if ext_call.return_data[0] != 32:
                                require ext_code.size(poolInfo[arg1].field_1024)
                                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                        gas gas_remaining wei
                                       args arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[0]
                                return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                            require 0 < ext_call.return_data[0]
                            require 0 < ext_call.return_data[0]
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 0, None
                        require ext_call.return_data[0] >= 32
                        _11409 = 0, mem[132 len 28]
                        require 0, mem[132 len 28] <= test266151307()
                        require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                        _11859 = mem[0, mem[132 len 28] + 128]
                        require mem[0, mem[132 len 28] + 128] <= test266151307()
                        require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                        mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                        mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                        require _11409 + _11859 + 160 <= ext_call.return_data[0] + 128
                        mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11859)] = mem[_11409 + 160 len ceil32(_11859)]
                        if ceil32(_11859) <= _11859:
                            mem[mem[64] + 4] = arg2
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args address(arg2)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _23119 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _23471 = mem[_23119]
                            require mem[_23119] == mem[_23119]
                            mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                            mem[mem[64] + 32] = address(ext_call.return_data[0])
                            mem[mem[64] + 64] = 128
                            _24175 = mem[(4 * ceil32(return_data.size)) + 132]
                            mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                            mem[mem[64] + 160 len ceil32(_24175)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24175)]
                            if ceil32(_24175) > _24175:
                                mem[mem[64] + _24175 + 160] = 0
                            mem[mem[64] + 96] = _23471
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   address(ext_call.return_data[0]),
                                   128,
                                   _23471,
                                   mem[mem[64] + 128 len ceil32(_24175) + 32]
                        mem[(4 * ceil32(return_data.size)) + _11859 + 164] = 0
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23295 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23647 = mem[_23295]
                        require mem[_23295] == mem[_23295]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24351 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24351)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24351)]
                        if ceil32(_24351) > _24351:
                            mem[mem[64] + _24351 + 160] = 0
                        mem[mem[64] + 96] = _23647
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               _23647,
                               mem[mem[64] + 128 len ceil32(_24351) + 32]
                    mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                    mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    if return_data.size < 64:
                        if 32 != return_data.size:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                        require 0 < return_data.size
                        require 0 < return_data.size
                        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                        if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                               ext_call.return_data[0]
                    require return_data.size >= 32
                    _11411 = mem[(4 * ceil32(return_data.size)) + 164]
                    require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                    _11860 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                    require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                    require _11411 + _11860 + 64 <= return_data.size + 32
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11860)] = mem[(4 * ceil32(return_data.size)) + _11411 + 196 len ceil32(_11860)]
                    if ceil32(_11860) <= _11860:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23120 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23472 = mem[_23120]
                        require mem[_23120] == mem[_23120]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        mem[mem[64] + 128] = _11860
                        mem[mem[64] + 160 len ceil32(_11860)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11860)]
                        if ceil32(_11860) > _11860:
                            mem[mem[64] + _11860 + 160] = 0
                        mem[mem[64] + 96] = _23472
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               Array(len=_11860, data=mem[mem[64] + 160 len ceil32(_11860)]),
                               _23472
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11860 + 165] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23296 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23648 = mem[_23296]
                    require mem[_23296] == mem[_23296]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11860
                    mem[mem[64] + 160 len ceil32(_11860)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11860)]
                    if ceil32(_11860) > _11860:
                        mem[mem[64] + _11860 + 160] = 0
                    mem[mem[64] + 96] = _23648
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=_11860, data=mem[mem[64] + 160 len ceil32(_11860)]),
                           _23648
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 'SafeMath: multiplication overflow'
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[ceil32(return_data.size) + 128] = 0
                    mem[ceil32(return_data.size) + 160] = 128
                    mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           0,
                           ext_call.return_data[0],
                           mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                require arg1 < poolInfo.length
                mem[0] = 19
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 100] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[(2 * ceil32(return_data.size)) + 128] = 0
                    mem[(2 * ceil32(return_data.size)) + 160] = 128
                    mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           ext_call.return_data[0],
                           ext_call.return_data[0],
                           mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 96] = 4
                mem[64] = (4 * ceil32(return_data.size)) + 132
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                mem[(4 * ceil32(return_data.size)) + 136] = 0
                staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                        gas gas_remaining wei
                if not return_data.size:
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    if ext_call.return_data[0] < 64:
                        if ext_call.return_data[0] != 32:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   address(ext_call.return_data[0]),
                                   128,
                                   ext_call.return_data[0],
                                   3,
                                   '???',
                                   0
                        require 0 < ext_call.return_data[0]
                        require 0 < ext_call.return_data[0]
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               0,
                               None
                    require ext_call.return_data[0] >= 32
                    _11403 = 0, mem[132 len 28]
                    require 0, mem[132 len 28] <= test266151307()
                    require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                    _11857 = mem[0, mem[132 len 28] + 128]
                    require mem[0, mem[132 len 28] + 128] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                    mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                    require _11403 + _11857 + 160 <= ext_call.return_data[0] + 128
                    mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11857)] = mem[_11403 + 160 len ceil32(_11857)]
                    if ceil32(_11857) <= _11857:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23115 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23467 = mem[_23115]
                        require mem[_23115] == mem[_23115]
                        mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24171 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24171)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24171)]
                        if ceil32(_24171) > _24171:
                            mem[mem[64] + _24171 + 160] = 0
                        mem[mem[64] + 96] = _23467
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               _23467,
                               mem[mem[64] + 128 len ceil32(_24171) + 32]
                    mem[(4 * ceil32(return_data.size)) + _11857 + 164] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23291 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23643 = mem[_23291]
                    require mem[_23291] == mem[_23291]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24347 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24347)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24347)]
                    if ceil32(_24347) > _24347:
                        mem[mem[64] + _24347 + 160] = 0
                    mem[mem[64] + 96] = _23643
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23643,
                           mem[mem[64] + 128 len ceil32(_24347) + 32]
                mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if return_data.size < 64:
                    if 32 != return_data.size:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < return_data.size
                    require 0 < return_data.size
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                    if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                           ext_call.return_data[0]
                require return_data.size >= 32
                _11405 = mem[(4 * ceil32(return_data.size)) + 164]
                require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                _11858 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require _11405 + _11858 + 64 <= return_data.size + 32
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11858)] = mem[(4 * ceil32(return_data.size)) + _11405 + 196 len ceil32(_11858)]
                if ceil32(_11858) <= _11858:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23116 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23468 = mem[_23116]
                    require mem[_23116] == mem[_23116]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11858
                    mem[mem[64] + 160 len ceil32(_11858)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11858)]
                    if ceil32(_11858) > _11858:
                        mem[mem[64] + _11858 + 160] = 0
                    mem[mem[64] + 96] = _23468
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=_11858, data=mem[mem[64] + 160 len ceil32(_11858)]),
                           _23468
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11858 + 165] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23292 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23644 = mem[_23292]
                require mem[_23292] == mem[_23292]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11858
                mem[mem[64] + 160 len ceil32(_11858)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11858)]
                if ceil32(_11858) > _11858:
                    mem[mem[64] + _11858 + 160] = 0
                mem[mem[64] + 96] = _23644
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11858, data=mem[mem[64] + 160 len ceil32(_11858)]),
                       _23644
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[ceil32(return_data.size) + 128] = 0
                    mem[ceil32(return_data.size) + 160] = 128
                    mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           0,
                           128,
                           0,
                           ext_call.return_data[0],
                           mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                require arg1 < poolInfo.length
                mem[0] = 19
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 100] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[(2 * ceil32(return_data.size)) + 128] = 0
                    mem[(2 * ceil32(return_data.size)) + 160] = 128
                    mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           0,
                           128,
                           ext_call.return_data[0],
                           ext_call.return_data[0],
                           mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 96] = 4
                mem[64] = (4 * ceil32(return_data.size)) + 132
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                mem[(4 * ceil32(return_data.size)) + 136] = 0
                staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                        gas gas_remaining wei
                if not return_data.size:
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    if ext_call.return_data[0] < 64:
                        if ext_call.return_data[0] != 32:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                                   address(ext_call.return_data[0]),
                                   128,
                                   ext_call.return_data[0],
                                   3,
                                   '???',
                                   0
                        require 0 < ext_call.return_data[0]
                        require 0 < ext_call.return_data[0]
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               0,
                               None
                    require ext_call.return_data[0] >= 32
                    _11421 = 0, mem[132 len 28]
                    require 0, mem[132 len 28] <= test266151307()
                    require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                    _11863 = mem[0, mem[132 len 28] + 128]
                    require mem[0, mem[132 len 28] + 128] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                    mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                    require _11421 + _11863 + 160 <= ext_call.return_data[0] + 128
                    mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11863)] = mem[_11421 + 160 len ceil32(_11863)]
                    if ceil32(_11863) <= _11863:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23127 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23479 = mem[_23127]
                        require mem[_23127] == mem[_23127]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24183 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24183)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24183)]
                        if ceil32(_24183) > _24183:
                            mem[mem[64] + _24183 + 160] = 0
                        mem[mem[64] + 96] = _23479
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               _23479,
                               mem[mem[64] + 128 len ceil32(_24183) + 32]
                    mem[(4 * ceil32(return_data.size)) + _11863 + 164] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23303 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23655 = mem[_23303]
                    require mem[_23303] == mem[_23303]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24359 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24359)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24359)]
                    if ceil32(_24359) > _24359:
                        mem[mem[64] + _24359 + 160] = 0
                    mem[mem[64] + 96] = _23655
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           _23655,
                           mem[mem[64] + 128 len ceil32(_24359) + 32]
                mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if return_data.size < 64:
                    if 32 != return_data.size:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < return_data.size
                    require 0 < return_data.size
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                    if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                           ext_call.return_data[0]
                require return_data.size >= 32
                _11423 = mem[(4 * ceil32(return_data.size)) + 164]
                require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                _11864 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require _11423 + _11864 + 64 <= return_data.size + 32
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11864)] = mem[(4 * ceil32(return_data.size)) + _11423 + 196 len ceil32(_11864)]
                if ceil32(_11864) <= _11864:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23128 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23480 = mem[_23128]
                    require mem[_23128] == mem[_23128]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11864
                    mem[mem[64] + 160 len ceil32(_11864)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11864)]
                    if ceil32(_11864) > _11864:
                        mem[mem[64] + _11864 + 160] = 0
                    mem[mem[64] + 96] = _23480
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           Array(len=_11864, data=mem[mem[64] + 160 len ceil32(_11864)]),
                           _23480
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11864 + 165] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23304 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23656 = mem[_23304]
                require mem[_23304] == mem[_23304]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11864
                mem[mem[64] + 160 len ceil32(_11864)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11864)]
                if ceil32(_11864) > _11864:
                    mem[mem[64] + _11864 + 160] = 0
                mem[mem[64] + 96] = _23656
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=_11864, data=mem[mem[64] + 160 len ceil32(_11864)]),
                       _23656
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11415 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11861 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11415 + _11861 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11861)] = mem[_11415 + 160 len ceil32(_11861)]
                if ceil32(_11861) <= _11861:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23123 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23475 = mem[_23123]
                    require mem[_23123] == mem[_23123]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24179 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24179)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24179)]
                    if ceil32(_24179) > _24179:
                        mem[mem[64] + _24179 + 160] = 0
                    mem[mem[64] + 96] = _23475
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           _23475,
                           mem[mem[64] + 128 len ceil32(_24179) + 32]
                mem[(4 * ceil32(return_data.size)) + _11861 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23299 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23651 = mem[_23299]
                require mem[_23299] == mem[_23299]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24355 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24355)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24355)]
                if ceil32(_24355) > _24355:
                    mem[mem[64] + _24355 + 160] = 0
                mem[mem[64] + 96] = _23651
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23651,
                       mem[mem[64] + 128 len ceil32(_24355) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11417 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11862 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11417 + _11862 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11862)] = mem[(4 * ceil32(return_data.size)) + _11417 + 196 len ceil32(_11862)]
            if ceil32(_11862) <= _11862:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23124 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23476 = mem[_23124]
                require mem[_23124] == mem[_23124]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11862
                mem[mem[64] + 160 len ceil32(_11862)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11862)]
                if ceil32(_11862) > _11862:
                    mem[mem[64] + _11862 + 160] = 0
                mem[mem[64] + 96] = _23476
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=_11862, data=mem[mem[64] + 160 len ceil32(_11862)]),
                       _23476
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11862 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23300 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23652 = mem[_23300]
            require mem[_23300] == mem[_23300]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11862
            mem[mem[64] + 160 len ceil32(_11862)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11862)]
            if ceil32(_11862) > _11862:
                mem[mem[64] + _11862 + 160] = 0
            mem[mem[64] + 96] = _23652
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11862, data=mem[mem[64] + 160 len ceil32(_11862)]),
                   _23652
        require 0 / totalAllocPoint
        if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            mem[32] = 18
            if depositTime[address(msg.sender)] <= block.timestamp:
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not poolInfo[arg1].field_1024:
                        mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256
                        mem[ceil32(return_data.size) + 128] = 0
                        mem[ceil32(return_data.size) + 160] = 128
                        mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                        if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                            mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                        return -userInfo[arg1][address(arg2)].field_256, 
                               0,
                               128,
                               0,
                               ext_call.return_data[0],
                               mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                    require arg1 < poolInfo.length
                    mem[0] = 19
                    if not poolInfo[arg1].field_1024:
                        mem[ceil32(return_data.size) + 100] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256
                        mem[(2 * ceil32(return_data.size)) + 128] = 0
                        mem[(2 * ceil32(return_data.size)) + 160] = 128
                        mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                        mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                        if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                            mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                        return -userInfo[arg1][address(arg2)].field_256, 
                               0,
                               128,
                               ext_call.return_data[0],
                               ext_call.return_data[0],
                               mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.rewardToken() with:
                            gas gas_remaining wei
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.rewardToken() with:
                            gas gas_remaining wei
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    mem[(4 * ceil32(return_data.size)) + 96] = 4
                    mem[64] = (4 * ceil32(return_data.size)) + 132
                    mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                    mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                    mem[(4 * ceil32(return_data.size)) + 136] = 0
                    staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                            gas gas_remaining wei
                    if not return_data.size:
                        if not ext_call.success:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                        if ext_call.return_data[0] < 64:
                            if ext_call.return_data[0] != 32:
                                require ext_code.size(poolInfo[arg1].field_1024)
                                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                        gas gas_remaining wei
                                       args arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[0]
                                return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                            require 0 < ext_call.return_data[0]
                            require 0 < ext_call.return_data[0]
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 0, None
                        require ext_call.return_data[0] >= 32
                        _11385 = 0, mem[132 len 28]
                        require 0, mem[132 len 28] <= test266151307()
                        require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                        _11851 = mem[0, mem[132 len 28] + 128]
                        require mem[0, mem[132 len 28] + 128] <= test266151307()
                        require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                        mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                        mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                        require _11385 + _11851 + 160 <= ext_call.return_data[0] + 128
                        mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11851)] = mem[_11385 + 160 len ceil32(_11851)]
                        if ceil32(_11851) <= _11851:
                            mem[mem[64] + 4] = arg2
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args address(arg2)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _23103 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _23455 = mem[_23103]
                            require mem[_23103] == mem[_23103]
                            mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                            mem[mem[64] + 32] = address(ext_call.return_data[0])
                            mem[mem[64] + 64] = 128
                            _24159 = mem[(4 * ceil32(return_data.size)) + 132]
                            mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                            mem[mem[64] + 160 len ceil32(_24159)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24159)]
                            if ceil32(_24159) > _24159:
                                mem[mem[64] + _24159 + 160] = 0
                            mem[mem[64] + 96] = _23455
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   address(ext_call.return_data[0]),
                                   128,
                                   _23455,
                                   mem[mem[64] + 128 len ceil32(_24159) + 32]
                        mem[(4 * ceil32(return_data.size)) + _11851 + 164] = 0
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23279 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23631 = mem[_23279]
                        require mem[_23279] == mem[_23279]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24335 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24335)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24335)]
                        if ceil32(_24335) > _24335:
                            mem[mem[64] + _24335 + 160] = 0
                        mem[mem[64] + 96] = _23631
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               _23631,
                               mem[mem[64] + 128 len ceil32(_24335) + 32]
                    mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                    mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    if return_data.size < 64:
                        if 32 != return_data.size:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                        require 0 < return_data.size
                        require 0 < return_data.size
                        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                        if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                               ext_call.return_data[0]
                    require return_data.size >= 32
                    _11387 = mem[(4 * ceil32(return_data.size)) + 164]
                    require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                    _11852 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                    require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                    require _11387 + _11852 + 64 <= return_data.size + 32
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11852)] = mem[(4 * ceil32(return_data.size)) + _11387 + 196 len ceil32(_11852)]
                    if ceil32(_11852) <= _11852:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23104 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23456 = mem[_23104]
                        require mem[_23104] == mem[_23104]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        mem[mem[64] + 128] = _11852
                        mem[mem[64] + 160 len ceil32(_11852)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11852)]
                        if ceil32(_11852) > _11852:
                            mem[mem[64] + _11852 + 160] = 0
                        mem[mem[64] + 96] = _23456
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               Array(len=_11852, data=mem[mem[64] + 160 len ceil32(_11852)]),
                               _23456
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11852 + 165] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23280 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23632 = mem[_23280]
                    require mem[_23280] == mem[_23280]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11852
                    mem[mem[64] + 160 len ceil32(_11852)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11852)]
                    if ceil32(_11852) > _11852:
                        mem[mem[64] + _11852 + 160] = 0
                    mem[mem[64] + 96] = _23632
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=_11852, data=mem[mem[64] + 160 len ceil32(_11852)]),
                           _23632
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 'SafeMath: multiplication overflow'
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[ceil32(return_data.size) + 128] = 0
                    mem[ceil32(return_data.size) + 160] = 128
                    mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           0,
                           ext_call.return_data[0],
                           mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                require arg1 < poolInfo.length
                mem[0] = 19
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 100] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[(2 * ceil32(return_data.size)) + 128] = 0
                    mem[(2 * ceil32(return_data.size)) + 160] = 128
                    mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           ext_call.return_data[0],
                           ext_call.return_data[0],
                           mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 96] = 4
                mem[64] = (4 * ceil32(return_data.size)) + 132
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                mem[(4 * ceil32(return_data.size)) + 136] = 0
                staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                        gas gas_remaining wei
                if not return_data.size:
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    if ext_call.return_data[0] < 64:
                        if ext_call.return_data[0] != 32:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   address(ext_call.return_data[0]),
                                   128,
                                   ext_call.return_data[0],
                                   3,
                                   '???',
                                   0
                        require 0 < ext_call.return_data[0]
                        require 0 < ext_call.return_data[0]
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               0,
                               None
                    require ext_call.return_data[0] >= 32
                    _11379 = 0, mem[132 len 28]
                    require 0, mem[132 len 28] <= test266151307()
                    require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                    _11849 = mem[0, mem[132 len 28] + 128]
                    require mem[0, mem[132 len 28] + 128] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                    mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                    require _11379 + _11849 + 160 <= ext_call.return_data[0] + 128
                    mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11849)] = mem[_11379 + 160 len ceil32(_11849)]
                    if ceil32(_11849) <= _11849:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23099 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23451 = mem[_23099]
                        require mem[_23099] == mem[_23099]
                        mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24155 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24155)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24155)]
                        if ceil32(_24155) > _24155:
                            mem[mem[64] + _24155 + 160] = 0
                        mem[mem[64] + 96] = _23451
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               _23451,
                               mem[mem[64] + 128 len ceil32(_24155) + 32]
                    mem[(4 * ceil32(return_data.size)) + _11849 + 164] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23275 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23627 = mem[_23275]
                    require mem[_23275] == mem[_23275]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24331 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24331)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24331)]
                    if ceil32(_24331) > _24331:
                        mem[mem[64] + _24331 + 160] = 0
                    mem[mem[64] + 96] = _23627
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23627,
                           mem[mem[64] + 128 len ceil32(_24331) + 32]
                mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if return_data.size < 64:
                    if 32 != return_data.size:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < return_data.size
                    require 0 < return_data.size
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                    if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                           ext_call.return_data[0]
                require return_data.size >= 32
                _11381 = mem[(4 * ceil32(return_data.size)) + 164]
                require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                _11850 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require _11381 + _11850 + 64 <= return_data.size + 32
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11850)] = mem[(4 * ceil32(return_data.size)) + _11381 + 196 len ceil32(_11850)]
                if ceil32(_11850) <= _11850:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23100 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23452 = mem[_23100]
                    require mem[_23100] == mem[_23100]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11850
                    mem[mem[64] + 160 len ceil32(_11850)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11850)]
                    if ceil32(_11850) > _11850:
                        mem[mem[64] + _11850 + 160] = 0
                    mem[mem[64] + 96] = _23452
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=_11850, data=mem[mem[64] + 160 len ceil32(_11850)]),
                           _23452
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11850 + 165] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23276 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23628 = mem[_23276]
                require mem[_23276] == mem[_23276]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11850
                mem[mem[64] + 160 len ceil32(_11850)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11850)]
                if ceil32(_11850) > _11850:
                    mem[mem[64] + _11850 + 160] = 0
                mem[mem[64] + 96] = _23628
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11850, data=mem[mem[64] + 160 len ceil32(_11850)]),
                       _23628
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[ceil32(return_data.size) + 128] = 0
                    mem[ceil32(return_data.size) + 160] = 128
                    mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           0,
                           128,
                           0,
                           ext_call.return_data[0],
                           mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                require arg1 < poolInfo.length
                mem[0] = 19
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 100] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[(2 * ceil32(return_data.size)) + 128] = 0
                    mem[(2 * ceil32(return_data.size)) + 160] = 128
                    mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           0,
                           128,
                           ext_call.return_data[0],
                           ext_call.return_data[0],
                           mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 96] = 4
                mem[64] = (4 * ceil32(return_data.size)) + 132
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                mem[(4 * ceil32(return_data.size)) + 136] = 0
                staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                        gas gas_remaining wei
                if not return_data.size:
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    if ext_call.return_data[0] < 64:
                        if ext_call.return_data[0] != 32:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                                   address(ext_call.return_data[0]),
                                   128,
                                   ext_call.return_data[0],
                                   3,
                                   '???',
                                   0
                        require 0 < ext_call.return_data[0]
                        require 0 < ext_call.return_data[0]
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               0,
                               None
                    require ext_call.return_data[0] >= 32
                    _11397 = 0, mem[132 len 28]
                    require 0, mem[132 len 28] <= test266151307()
                    require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                    _11855 = mem[0, mem[132 len 28] + 128]
                    require mem[0, mem[132 len 28] + 128] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                    mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                    require _11397 + _11855 + 160 <= ext_call.return_data[0] + 128
                    mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11855)] = mem[_11397 + 160 len ceil32(_11855)]
                    if ceil32(_11855) <= _11855:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23111 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23463 = mem[_23111]
                        require mem[_23111] == mem[_23111]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24167 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24167)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24167)]
                        if ceil32(_24167) > _24167:
                            mem[mem[64] + _24167 + 160] = 0
                        mem[mem[64] + 96] = _23463
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               _23463,
                               mem[mem[64] + 128 len ceil32(_24167) + 32]
                    mem[(4 * ceil32(return_data.size)) + _11855 + 164] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23287 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23639 = mem[_23287]
                    require mem[_23287] == mem[_23287]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24343 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24343)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24343)]
                    if ceil32(_24343) > _24343:
                        mem[mem[64] + _24343 + 160] = 0
                    mem[mem[64] + 96] = _23639
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           _23639,
                           mem[mem[64] + 128 len ceil32(_24343) + 32]
                mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if return_data.size < 64:
                    if 32 != return_data.size:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < return_data.size
                    require 0 < return_data.size
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                    if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                           ext_call.return_data[0]
                require return_data.size >= 32
                _11399 = mem[(4 * ceil32(return_data.size)) + 164]
                require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                _11856 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require _11399 + _11856 + 64 <= return_data.size + 32
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11856)] = mem[(4 * ceil32(return_data.size)) + _11399 + 196 len ceil32(_11856)]
                if ceil32(_11856) <= _11856:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23112 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23464 = mem[_23112]
                    require mem[_23112] == mem[_23112]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11856
                    mem[mem[64] + 160 len ceil32(_11856)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11856)]
                    if ceil32(_11856) > _11856:
                        mem[mem[64] + _11856 + 160] = 0
                    mem[mem[64] + 96] = _23464
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           Array(len=_11856, data=mem[mem[64] + 160 len ceil32(_11856)]),
                           _23464
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11856 + 165] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23288 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23640 = mem[_23288]
                require mem[_23288] == mem[_23288]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11856
                mem[mem[64] + 160 len ceil32(_11856)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11856)]
                if ceil32(_11856) > _11856:
                    mem[mem[64] + _11856 + 160] = 0
                mem[mem[64] + 96] = _23640
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=_11856, data=mem[mem[64] + 160 len ceil32(_11856)]),
                       _23640
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11391 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11853 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11391 + _11853 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11853)] = mem[_11391 + 160 len ceil32(_11853)]
                if ceil32(_11853) <= _11853:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23107 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23459 = mem[_23107]
                    require mem[_23107] == mem[_23107]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24163 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24163)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24163)]
                    if ceil32(_24163) > _24163:
                        mem[mem[64] + _24163 + 160] = 0
                    mem[mem[64] + 96] = _23459
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           _23459,
                           mem[mem[64] + 128 len ceil32(_24163) + 32]
                mem[(4 * ceil32(return_data.size)) + _11853 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23283 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23635 = mem[_23283]
                require mem[_23283] == mem[_23283]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24339 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24339)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24339)]
                if ceil32(_24339) > _24339:
                    mem[mem[64] + _24339 + 160] = 0
                mem[mem[64] + 96] = _23635
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23635,
                       mem[mem[64] + 128 len ceil32(_24339) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11393 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11854 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11393 + _11854 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11854)] = mem[(4 * ceil32(return_data.size)) + _11393 + 196 len ceil32(_11854)]
            if ceil32(_11854) <= _11854:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23108 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23460 = mem[_23108]
                require mem[_23108] == mem[_23108]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11854
                mem[mem[64] + 160 len ceil32(_11854)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11854)]
                if ceil32(_11854) > _11854:
                    mem[mem[64] + _11854 + 160] = 0
                mem[mem[64] + 96] = _23460
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=_11854, data=mem[mem[64] + 160 len ceil32(_11854)]),
                       _23460
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11854 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23284 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23636 = mem[_23284]
            require mem[_23284] == mem[_23284]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11854
            mem[mem[64] + 160 len ceil32(_11854)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11854)]
            if ceil32(_11854) > _11854:
                mem[mem[64] + _11854 + 160] = 0
            mem[mem[64] + 96] = _23636
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11854, data=mem[mem[64] + 160 len ceil32(_11854)]),
                   _23636
        require (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
        if 10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        mem[32] = 18
        if depositTime[address(msg.sender)] <= block.timestamp:
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256
                    mem[ceil32(return_data.size) + 128] = 0
                    mem[ceil32(return_data.size) + 160] = 128
                    mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           0,
                           ext_call.return_data[0],
                           mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                require arg1 < poolInfo.length
                mem[0] = 19
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 100] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256
                    mem[(2 * ceil32(return_data.size)) + 128] = 0
                    mem[(2 * ceil32(return_data.size)) + 160] = 128
                    mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           ext_call.return_data[0],
                           ext_call.return_data[0],
                           mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 96] = 4
                mem[64] = (4 * ceil32(return_data.size)) + 132
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                mem[(4 * ceil32(return_data.size)) + 136] = 0
                staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                        gas gas_remaining wei
                if not return_data.size:
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    if ext_call.return_data[0] < 64:
                        if ext_call.return_data[0] != 32:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                        require 0 < ext_call.return_data[0]
                        require 0 < ext_call.return_data[0]
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 0, None
                    require ext_call.return_data[0] >= 32
                    _11361 = 0, mem[132 len 28]
                    require 0, mem[132 len 28] <= test266151307()
                    require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                    _11843 = mem[0, mem[132 len 28] + 128]
                    require mem[0, mem[132 len 28] + 128] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                    mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                    require _11361 + _11843 + 160 <= ext_call.return_data[0] + 128
                    mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11843)] = mem[_11361 + 160 len ceil32(_11843)]
                    if ceil32(_11843) <= _11843:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23087 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23439 = mem[_23087]
                        require mem[_23087] == mem[_23087]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24143 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24143)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24143)]
                        if ceil32(_24143) > _24143:
                            mem[mem[64] + _24143 + 160] = 0
                        mem[mem[64] + 96] = _23439
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               _23439,
                               mem[mem[64] + 128 len ceil32(_24143) + 32]
                    mem[(4 * ceil32(return_data.size)) + _11843 + 164] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23263 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23615 = mem[_23263]
                    require mem[_23263] == mem[_23263]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24319 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24319)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24319)]
                    if ceil32(_24319) > _24319:
                        mem[mem[64] + _24319 + 160] = 0
                    mem[mem[64] + 96] = _23615
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23615,
                           mem[mem[64] + 128 len ceil32(_24319) + 32]
                mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                if return_data.size < 64:
                    if 32 != return_data.size:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    require 0 < return_data.size
                    require 0 < return_data.size
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                    if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                           ext_call.return_data[0]
                require return_data.size >= 32
                _11363 = mem[(4 * ceil32(return_data.size)) + 164]
                require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                _11844 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require _11363 + _11844 + 64 <= return_data.size + 32
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11844)] = mem[(4 * ceil32(return_data.size)) + _11363 + 196 len ceil32(_11844)]
                if ceil32(_11844) <= _11844:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23088 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23440 = mem[_23088]
                    require mem[_23088] == mem[_23088]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11844
                    mem[mem[64] + 160 len ceil32(_11844)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11844)]
                    if ceil32(_11844) > _11844:
                        mem[mem[64] + _11844 + 160] = 0
                    mem[mem[64] + 96] = _23440
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=_11844, data=mem[mem[64] + 160 len ceil32(_11844)]),
                           _23440
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11844 + 165] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23264 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23616 = mem[_23264]
                require mem[_23264] == mem[_23264]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11844
                mem[mem[64] + 160 len ceil32(_11844)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11844)]
                if ceil32(_11844) > _11844:
                    mem[mem[64] + _11844 + 160] = 0
                mem[mem[64] + 96] = _23616
                return -userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11844, data=mem[mem[64] + 160 len ceil32(_11844)]),
                       _23616
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11355 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11841 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11355 + _11841 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11841)] = mem[_11355 + 160 len ceil32(_11841)]
                if ceil32(_11841) <= _11841:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23083 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23435 = mem[_23083]
                    require mem[_23083] == mem[_23083]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24139 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24139)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24139)]
                    if ceil32(_24139) > _24139:
                        mem[mem[64] + _24139 + 160] = 0
                    mem[mem[64] + 96] = _23435
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23435,
                           mem[mem[64] + 128 len ceil32(_24139) + 32]
                mem[(4 * ceil32(return_data.size)) + _11841 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23259 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23611 = mem[_23259]
                require mem[_23259] == mem[_23259]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24315 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24315)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24315)]
                if ceil32(_24315) > _24315:
                    mem[mem[64] + _24315 + 160] = 0
                mem[mem[64] + 96] = _23611
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       _23611,
                       mem[mem[64] + 128 len ceil32(_24315) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11357 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11842 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11357 + _11842 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11842)] = mem[(4 * ceil32(return_data.size)) + _11357 + 196 len ceil32(_11842)]
            if ceil32(_11842) <= _11842:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23084 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23436 = mem[_23084]
                require mem[_23084] == mem[_23084]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11842
                mem[mem[64] + 160 len ceil32(_11842)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11842)]
                if ceil32(_11842) > _11842:
                    mem[mem[64] + _11842 + 160] = 0
                mem[mem[64] + 96] = _23436
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11842, data=mem[mem[64] + 160 len ceil32(_11842)]),
                       _23436
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11842 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23260 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23612 = mem[_23260]
            require mem[_23260] == mem[_23260]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11842
            mem[mem[64] + 160 len ceil32(_11842)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11842)]
            if ceil32(_11842) > _11842:
                mem[mem[64] + _11842 + 160] = 0
            mem[mem[64] + 96] = _23612
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   address(ext_call.return_data[0]),
                   Array(len=_11842, data=mem[mem[64] + 160 len ceil32(_11842)]),
                   _23612
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11373 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11847 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11373 + _11847 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11847)] = mem[_11373 + 160 len ceil32(_11847)]
                if ceil32(_11847) <= _11847:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23095 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23447 = mem[_23095]
                    require mem[_23095] == mem[_23095]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24151 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24151)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24151)]
                    if ceil32(_24151) > _24151:
                        mem[mem[64] + _24151 + 160] = 0
                    mem[mem[64] + 96] = _23447
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           _23447,
                           mem[mem[64] + 128 len ceil32(_24151) + 32]
                mem[(4 * ceil32(return_data.size)) + _11847 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23271 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23623 = mem[_23271]
                require mem[_23271] == mem[_23271]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24327 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24327)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24327)]
                if ceil32(_24327) > _24327:
                    mem[mem[64] + _24327 + 160] = 0
                mem[mem[64] + 96] = _23623
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23623,
                       mem[mem[64] + 128 len ceil32(_24327) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11375 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11848 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11375 + _11848 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11848)] = mem[(4 * ceil32(return_data.size)) + _11375 + 196 len ceil32(_11848)]
            if ceil32(_11848) <= _11848:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23096 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23448 = mem[_23096]
                require mem[_23096] == mem[_23096]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11848
                mem[mem[64] + 160 len ceil32(_11848)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11848)]
                if ceil32(_11848) > _11848:
                    mem[mem[64] + _11848 + 160] = 0
                mem[mem[64] + 96] = _23448
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=_11848, data=mem[mem[64] + 160 len ceil32(_11848)]),
                       _23448
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11848 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23272 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23624 = mem[_23272]
            require mem[_23272] == mem[_23272]
            mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11848
            mem[mem[64] + 160 len ceil32(_11848)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11848)]
            if ceil32(_11848) > _11848:
                mem[mem[64] + _11848 + 160] = 0
            mem[mem[64] + 96] = _23624
            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11848, data=mem[mem[64] + 160 len ceil32(_11848)]),
                   _23624
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 128
            mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
            mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   0,
                   128,
                   0,
                   ext_call.return_data[0],
                   mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
        require arg1 < poolInfo.length
        mem[0] = 19
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 100] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[(2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + 160] = 128
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   0,
                   128,
                   ext_call.return_data[0],
                   ext_call.return_data[0],
                   mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(4 * ceil32(return_data.size)) + 96] = 4
        mem[64] = (4 * ceil32(return_data.size)) + 132
        mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
        mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
        mem[(4 * ceil32(return_data.size)) + 136] = 0
        staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                gas gas_remaining wei
        if not return_data.size:
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if ext_call.return_data[0] < 64:
                if ext_call.return_data[0] != 32:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < ext_call.return_data[0]
                require 0 < ext_call.return_data[0]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       0,
                       None
            require ext_call.return_data[0] >= 32
            _11367 = 0, mem[132 len 28]
            require 0, mem[132 len 28] <= test266151307()
            require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
            _11845 = mem[0, mem[132 len 28] + 128]
            require mem[0, mem[132 len 28] + 128] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
            mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
            require _11367 + _11845 + 160 <= ext_call.return_data[0] + 128
            mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11845)] = mem[_11367 + 160 len ceil32(_11845)]
            if ceil32(_11845) <= _11845:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23091 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23443 = mem[_23091]
                require mem[_23091] == mem[_23091]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24147 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24147)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24147)]
                if ceil32(_24147) > _24147:
                    mem[mem[64] + _24147 + 160] = 0
                mem[mem[64] + 96] = _23443
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23443,
                       mem[mem[64] + 128 len ceil32(_24147) + 32]
            mem[(4 * ceil32(return_data.size)) + _11845 + 164] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23267 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23619 = mem[_23267]
            require mem[_23267] == mem[_23267]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            _24323 = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 160 len ceil32(_24323)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24323)]
            if ceil32(_24323) > _24323:
                mem[mem[64] + _24323 + 160] = 0
            mem[mem[64] + 96] = _23619
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   _23619,
                   mem[mem[64] + 128 len ceil32(_24323) + 32]
        mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
        mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   ext_call.return_data[0],
                   3,
                   '???',
                   0
        if return_data.size < 64:
            if 32 != return_data.size:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            require 0 < return_data.size
            require 0 < return_data.size
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
            if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                   ext_call.return_data[0]
        require return_data.size >= 32
        _11369 = mem[(4 * ceil32(return_data.size)) + 164]
        require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
        _11846 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
        mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require _11369 + _11846 + 64 <= return_data.size + 32
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11846)] = mem[(4 * ceil32(return_data.size)) + _11369 + 196 len ceil32(_11846)]
        if ceil32(_11846) <= _11846:
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23092 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23444 = mem[_23092]
            require mem[_23092] == mem[_23092]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11846
            mem[mem[64] + 160 len ceil32(_11846)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11846)]
            if ceil32(_11846) > _11846:
                mem[mem[64] + _11846 + 160] = 0
            mem[mem[64] + 96] = _23444
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11846, data=mem[mem[64] + 160 len ceil32(_11846)]),
                   _23444
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11846 + 165] = 0
        mem[mem[64] + 4] = arg2
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _23268 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _23620 = mem[_23268]
        require mem[_23268] == mem[_23268]
        mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
        mem[mem[64] + 32] = address(ext_call.return_data[0])
        mem[mem[64] + 64] = 128
        mem[mem[64] + 128] = _11846
        mem[mem[64] + 160 len ceil32(_11846)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11846)]
        if ceil32(_11846) > _11846:
            mem[mem[64] + _11846 + 160] = 0
        mem[mem[64] + 96] = _23620
        return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
               address(ext_call.return_data[0]),
               Array(len=_11846, data=mem[mem[64] + 160 len ceil32(_11846)]),
               _23620
    require block.timestamp - poolInfo[arg1].field_512
    if (block.timestamp * sub_4a7d91a1) - (poolInfo[arg1].field_512 * sub_4a7d91a1) / block.timestamp - poolInfo[arg1].field_512 != sub_4a7d91a1:
        revert with 0, 'SafeMath: multiplication overflow'
    if not (block.timestamp * sub_4a7d91a1) - (poolInfo[arg1].field_512 * sub_4a7d91a1):
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not 0 / totalAllocPoint:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            mem[32] = 18
            if depositTime[address(msg.sender)] <= block.timestamp:
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not poolInfo[arg1].field_1024:
                        mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256
                        mem[ceil32(return_data.size) + 128] = 0
                        mem[ceil32(return_data.size) + 160] = 128
                        mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                        if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                            mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                        return -userInfo[arg1][address(arg2)].field_256, 
                               0,
                               128,
                               0,
                               ext_call.return_data[0],
                               mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                    require arg1 < poolInfo.length
                    mem[0] = 19
                    if not poolInfo[arg1].field_1024:
                        mem[ceil32(return_data.size) + 100] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256
                        mem[(2 * ceil32(return_data.size)) + 128] = 0
                        mem[(2 * ceil32(return_data.size)) + 160] = 128
                        mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                        mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                        if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                            mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                        return -userInfo[arg1][address(arg2)].field_256, 
                               0,
                               128,
                               ext_call.return_data[0],
                               ext_call.return_data[0],
                               mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.rewardToken() with:
                            gas gas_remaining wei
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.rewardToken() with:
                            gas gas_remaining wei
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    mem[(4 * ceil32(return_data.size)) + 96] = 4
                    mem[64] = (4 * ceil32(return_data.size)) + 132
                    mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                    mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                    mem[(4 * ceil32(return_data.size)) + 136] = 0
                    staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                            gas gas_remaining wei
                    if not return_data.size:
                        if not ext_call.success:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                        if ext_call.return_data[0] < 64:
                            if ext_call.return_data[0] != 32:
                                require ext_code.size(poolInfo[arg1].field_1024)
                                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                        gas gas_remaining wei
                                       args arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[0]
                                return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                            require 0 < ext_call.return_data[0]
                            require 0 < ext_call.return_data[0]
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 0, None
                        require ext_call.return_data[0] >= 32
                        _11337 = 0, mem[132 len 28]
                        require 0, mem[132 len 28] <= test266151307()
                        require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                        _11835 = mem[0, mem[132 len 28] + 128]
                        require mem[0, mem[132 len 28] + 128] <= test266151307()
                        require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                        mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                        mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                        require _11337 + _11835 + 160 <= ext_call.return_data[0] + 128
                        mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11835)] = mem[_11337 + 160 len ceil32(_11835)]
                        if ceil32(_11835) <= _11835:
                            mem[mem[64] + 4] = arg2
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args address(arg2)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _23071 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _23423 = mem[_23071]
                            require mem[_23071] == mem[_23071]
                            mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                            mem[mem[64] + 32] = address(ext_call.return_data[0])
                            mem[mem[64] + 64] = 128
                            _24127 = mem[(4 * ceil32(return_data.size)) + 132]
                            mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                            mem[mem[64] + 160 len ceil32(_24127)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24127)]
                            if ceil32(_24127) > _24127:
                                mem[mem[64] + _24127 + 160] = 0
                            mem[mem[64] + 96] = _23423
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   address(ext_call.return_data[0]),
                                   128,
                                   _23423,
                                   mem[mem[64] + 128 len ceil32(_24127) + 32]
                        mem[(4 * ceil32(return_data.size)) + _11835 + 164] = 0
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23247 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23599 = mem[_23247]
                        require mem[_23247] == mem[_23247]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24303 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24303)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24303)]
                        if ceil32(_24303) > _24303:
                            mem[mem[64] + _24303 + 160] = 0
                        mem[mem[64] + 96] = _23599
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               _23599,
                               mem[mem[64] + 128 len ceil32(_24303) + 32]
                    mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                    mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    if return_data.size < 64:
                        if 32 != return_data.size:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                        require 0 < return_data.size
                        require 0 < return_data.size
                        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                        if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                               ext_call.return_data[0]
                    require return_data.size >= 32
                    _11339 = mem[(4 * ceil32(return_data.size)) + 164]
                    require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                    _11836 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                    require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                    require _11339 + _11836 + 64 <= return_data.size + 32
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11836)] = mem[(4 * ceil32(return_data.size)) + _11339 + 196 len ceil32(_11836)]
                    if ceil32(_11836) <= _11836:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23072 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23424 = mem[_23072]
                        require mem[_23072] == mem[_23072]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        mem[mem[64] + 128] = _11836
                        mem[mem[64] + 160 len ceil32(_11836)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11836)]
                        if ceil32(_11836) > _11836:
                            mem[mem[64] + _11836 + 160] = 0
                        mem[mem[64] + 96] = _23424
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               Array(len=_11836, data=mem[mem[64] + 160 len ceil32(_11836)]),
                               _23424
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11836 + 165] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23248 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23600 = mem[_23248]
                    require mem[_23248] == mem[_23248]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11836
                    mem[mem[64] + 160 len ceil32(_11836)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11836)]
                    if ceil32(_11836) > _11836:
                        mem[mem[64] + _11836 + 160] = 0
                    mem[mem[64] + 96] = _23600
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=_11836, data=mem[mem[64] + 160 len ceil32(_11836)]),
                           _23600
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 'SafeMath: multiplication overflow'
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[ceil32(return_data.size) + 128] = 0
                    mem[ceil32(return_data.size) + 160] = 128
                    mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           0,
                           ext_call.return_data[0],
                           mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                require arg1 < poolInfo.length
                mem[0] = 19
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 100] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[(2 * ceil32(return_data.size)) + 128] = 0
                    mem[(2 * ceil32(return_data.size)) + 160] = 128
                    mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           ext_call.return_data[0],
                           ext_call.return_data[0],
                           mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 96] = 4
                mem[64] = (4 * ceil32(return_data.size)) + 132
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                mem[(4 * ceil32(return_data.size)) + 136] = 0
                staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                        gas gas_remaining wei
                if not return_data.size:
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    if ext_call.return_data[0] < 64:
                        if ext_call.return_data[0] != 32:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   address(ext_call.return_data[0]),
                                   128,
                                   ext_call.return_data[0],
                                   3,
                                   '???',
                                   0
                        require 0 < ext_call.return_data[0]
                        require 0 < ext_call.return_data[0]
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               0,
                               None
                    require ext_call.return_data[0] >= 32
                    _11331 = 0, mem[132 len 28]
                    require 0, mem[132 len 28] <= test266151307()
                    require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                    _11833 = mem[0, mem[132 len 28] + 128]
                    require mem[0, mem[132 len 28] + 128] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                    mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                    require _11331 + _11833 + 160 <= ext_call.return_data[0] + 128
                    mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11833)] = mem[_11331 + 160 len ceil32(_11833)]
                    if ceil32(_11833) <= _11833:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23067 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23419 = mem[_23067]
                        require mem[_23067] == mem[_23067]
                        mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24123 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24123)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24123)]
                        if ceil32(_24123) > _24123:
                            mem[mem[64] + _24123 + 160] = 0
                        mem[mem[64] + 96] = _23419
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               _23419,
                               mem[mem[64] + 128 len ceil32(_24123) + 32]
                    mem[(4 * ceil32(return_data.size)) + _11833 + 164] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23243 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23595 = mem[_23243]
                    require mem[_23243] == mem[_23243]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24299 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24299)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24299)]
                    if ceil32(_24299) > _24299:
                        mem[mem[64] + _24299 + 160] = 0
                    mem[mem[64] + 96] = _23595
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23595,
                           mem[mem[64] + 128 len ceil32(_24299) + 32]
                mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if return_data.size < 64:
                    if 32 != return_data.size:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < return_data.size
                    require 0 < return_data.size
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                    if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                           ext_call.return_data[0]
                require return_data.size >= 32
                _11333 = mem[(4 * ceil32(return_data.size)) + 164]
                require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                _11834 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require _11333 + _11834 + 64 <= return_data.size + 32
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11834)] = mem[(4 * ceil32(return_data.size)) + _11333 + 196 len ceil32(_11834)]
                if ceil32(_11834) <= _11834:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23068 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23420 = mem[_23068]
                    require mem[_23068] == mem[_23068]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11834
                    mem[mem[64] + 160 len ceil32(_11834)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11834)]
                    if ceil32(_11834) > _11834:
                        mem[mem[64] + _11834 + 160] = 0
                    mem[mem[64] + 96] = _23420
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=_11834, data=mem[mem[64] + 160 len ceil32(_11834)]),
                           _23420
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11834 + 165] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23244 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23596 = mem[_23244]
                require mem[_23244] == mem[_23244]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11834
                mem[mem[64] + 160 len ceil32(_11834)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11834)]
                if ceil32(_11834) > _11834:
                    mem[mem[64] + _11834 + 160] = 0
                mem[mem[64] + 96] = _23596
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11834, data=mem[mem[64] + 160 len ceil32(_11834)]),
                       _23596
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[ceil32(return_data.size) + 128] = 0
                    mem[ceil32(return_data.size) + 160] = 128
                    mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           0,
                           128,
                           0,
                           ext_call.return_data[0],
                           mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                require arg1 < poolInfo.length
                mem[0] = 19
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 100] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[(2 * ceil32(return_data.size)) + 128] = 0
                    mem[(2 * ceil32(return_data.size)) + 160] = 128
                    mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           0,
                           128,
                           ext_call.return_data[0],
                           ext_call.return_data[0],
                           mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 96] = 4
                mem[64] = (4 * ceil32(return_data.size)) + 132
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                mem[(4 * ceil32(return_data.size)) + 136] = 0
                staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                        gas gas_remaining wei
                if not return_data.size:
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    if ext_call.return_data[0] < 64:
                        if ext_call.return_data[0] != 32:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                                   address(ext_call.return_data[0]),
                                   128,
                                   ext_call.return_data[0],
                                   3,
                                   '???',
                                   0
                        require 0 < ext_call.return_data[0]
                        require 0 < ext_call.return_data[0]
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               0,
                               None
                    require ext_call.return_data[0] >= 32
                    _11349 = 0, mem[132 len 28]
                    require 0, mem[132 len 28] <= test266151307()
                    require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                    _11839 = mem[0, mem[132 len 28] + 128]
                    require mem[0, mem[132 len 28] + 128] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                    mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                    require _11349 + _11839 + 160 <= ext_call.return_data[0] + 128
                    mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11839)] = mem[_11349 + 160 len ceil32(_11839)]
                    if ceil32(_11839) <= _11839:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23079 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23431 = mem[_23079]
                        require mem[_23079] == mem[_23079]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24135 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24135)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24135)]
                        if ceil32(_24135) > _24135:
                            mem[mem[64] + _24135 + 160] = 0
                        mem[mem[64] + 96] = _23431
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               _23431,
                               mem[mem[64] + 128 len ceil32(_24135) + 32]
                    mem[(4 * ceil32(return_data.size)) + _11839 + 164] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23255 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23607 = mem[_23255]
                    require mem[_23255] == mem[_23255]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24311 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24311)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24311)]
                    if ceil32(_24311) > _24311:
                        mem[mem[64] + _24311 + 160] = 0
                    mem[mem[64] + 96] = _23607
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           _23607,
                           mem[mem[64] + 128 len ceil32(_24311) + 32]
                mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if return_data.size < 64:
                    if 32 != return_data.size:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < return_data.size
                    require 0 < return_data.size
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                    if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                           ext_call.return_data[0]
                require return_data.size >= 32
                _11351 = mem[(4 * ceil32(return_data.size)) + 164]
                require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                _11840 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require _11351 + _11840 + 64 <= return_data.size + 32
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11840)] = mem[(4 * ceil32(return_data.size)) + _11351 + 196 len ceil32(_11840)]
                if ceil32(_11840) <= _11840:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23080 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23432 = mem[_23080]
                    require mem[_23080] == mem[_23080]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11840
                    mem[mem[64] + 160 len ceil32(_11840)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11840)]
                    if ceil32(_11840) > _11840:
                        mem[mem[64] + _11840 + 160] = 0
                    mem[mem[64] + 96] = _23432
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           Array(len=_11840, data=mem[mem[64] + 160 len ceil32(_11840)]),
                           _23432
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11840 + 165] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23256 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23608 = mem[_23256]
                require mem[_23256] == mem[_23256]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11840
                mem[mem[64] + 160 len ceil32(_11840)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11840)]
                if ceil32(_11840) > _11840:
                    mem[mem[64] + _11840 + 160] = 0
                mem[mem[64] + 96] = _23608
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=_11840, data=mem[mem[64] + 160 len ceil32(_11840)]),
                       _23608
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11343 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11837 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11343 + _11837 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11837)] = mem[_11343 + 160 len ceil32(_11837)]
                if ceil32(_11837) <= _11837:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23075 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23427 = mem[_23075]
                    require mem[_23075] == mem[_23075]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24131 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24131)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24131)]
                    if ceil32(_24131) > _24131:
                        mem[mem[64] + _24131 + 160] = 0
                    mem[mem[64] + 96] = _23427
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           _23427,
                           mem[mem[64] + 128 len ceil32(_24131) + 32]
                mem[(4 * ceil32(return_data.size)) + _11837 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23251 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23603 = mem[_23251]
                require mem[_23251] == mem[_23251]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24307 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24307)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24307)]
                if ceil32(_24307) > _24307:
                    mem[mem[64] + _24307 + 160] = 0
                mem[mem[64] + 96] = _23603
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23603,
                       mem[mem[64] + 128 len ceil32(_24307) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11345 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11838 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11345 + _11838 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11838)] = mem[(4 * ceil32(return_data.size)) + _11345 + 196 len ceil32(_11838)]
            if ceil32(_11838) <= _11838:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23076 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23428 = mem[_23076]
                require mem[_23076] == mem[_23076]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11838
                mem[mem[64] + 160 len ceil32(_11838)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11838)]
                if ceil32(_11838) > _11838:
                    mem[mem[64] + _11838 + 160] = 0
                mem[mem[64] + 96] = _23428
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=_11838, data=mem[mem[64] + 160 len ceil32(_11838)]),
                       _23428
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11838 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23252 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23604 = mem[_23252]
            require mem[_23252] == mem[_23252]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11838
            mem[mem[64] + 160 len ceil32(_11838)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11838)]
            if ceil32(_11838) > _11838:
                mem[mem[64] + _11838 + 160] = 0
            mem[mem[64] + 96] = _23604
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11838, data=mem[mem[64] + 160 len ceil32(_11838)]),
                   _23604
        require 0 / totalAllocPoint
        if (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 0 / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            mem[32] = 18
            if depositTime[address(msg.sender)] <= block.timestamp:
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not poolInfo[arg1].field_1024:
                        mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256
                        mem[ceil32(return_data.size) + 128] = 0
                        mem[ceil32(return_data.size) + 160] = 128
                        mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                        if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                            mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                        return -userInfo[arg1][address(arg2)].field_256, 
                               0,
                               128,
                               0,
                               ext_call.return_data[0],
                               mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                    require arg1 < poolInfo.length
                    mem[0] = 19
                    if not poolInfo[arg1].field_1024:
                        mem[ceil32(return_data.size) + 100] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256
                        mem[(2 * ceil32(return_data.size)) + 128] = 0
                        mem[(2 * ceil32(return_data.size)) + 160] = 128
                        mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                        mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                        if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                            mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                        return -userInfo[arg1][address(arg2)].field_256, 
                               0,
                               128,
                               ext_call.return_data[0],
                               ext_call.return_data[0],
                               mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.rewardToken() with:
                            gas gas_remaining wei
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.rewardToken() with:
                            gas gas_remaining wei
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    mem[(4 * ceil32(return_data.size)) + 96] = 4
                    mem[64] = (4 * ceil32(return_data.size)) + 132
                    mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                    mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                    mem[(4 * ceil32(return_data.size)) + 136] = 0
                    staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                            gas gas_remaining wei
                    if not return_data.size:
                        if not ext_call.success:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                        if ext_call.return_data[0] < 64:
                            if ext_call.return_data[0] != 32:
                                require ext_code.size(poolInfo[arg1].field_1024)
                                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                        gas gas_remaining wei
                                       args arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[0]
                                return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                            require 0 < ext_call.return_data[0]
                            require 0 < ext_call.return_data[0]
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 0, None
                        require ext_call.return_data[0] >= 32
                        _11313 = 0, mem[132 len 28]
                        require 0, mem[132 len 28] <= test266151307()
                        require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                        _11827 = mem[0, mem[132 len 28] + 128]
                        require mem[0, mem[132 len 28] + 128] <= test266151307()
                        require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                        mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                        mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                        require _11313 + _11827 + 160 <= ext_call.return_data[0] + 128
                        mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11827)] = mem[_11313 + 160 len ceil32(_11827)]
                        if ceil32(_11827) <= _11827:
                            mem[mem[64] + 4] = arg2
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args address(arg2)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _23055 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _23407 = mem[_23055]
                            require mem[_23055] == mem[_23055]
                            mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                            mem[mem[64] + 32] = address(ext_call.return_data[0])
                            mem[mem[64] + 64] = 128
                            _24111 = mem[(4 * ceil32(return_data.size)) + 132]
                            mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                            mem[mem[64] + 160 len ceil32(_24111)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24111)]
                            if ceil32(_24111) > _24111:
                                mem[mem[64] + _24111 + 160] = 0
                            mem[mem[64] + 96] = _23407
                            return -userInfo[arg1][address(arg2)].field_256, 
                                   address(ext_call.return_data[0]),
                                   128,
                                   _23407,
                                   mem[mem[64] + 128 len ceil32(_24111) + 32]
                        mem[(4 * ceil32(return_data.size)) + _11827 + 164] = 0
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23231 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23583 = mem[_23231]
                        require mem[_23231] == mem[_23231]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24287 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24287)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24287)]
                        if ceil32(_24287) > _24287:
                            mem[mem[64] + _24287 + 160] = 0
                        mem[mem[64] + 96] = _23583
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               _23583,
                               mem[mem[64] + 128 len ceil32(_24287) + 32]
                    mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                    mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    if return_data.size < 64:
                        if 32 != return_data.size:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                        require 0 < return_data.size
                        require 0 < return_data.size
                        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                        if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                               ext_call.return_data[0]
                    require return_data.size >= 32
                    _11315 = mem[(4 * ceil32(return_data.size)) + 164]
                    require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                    _11828 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                    require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                    require _11315 + _11828 + 64 <= return_data.size + 32
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11828)] = mem[(4 * ceil32(return_data.size)) + _11315 + 196 len ceil32(_11828)]
                    if ceil32(_11828) <= _11828:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23056 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23408 = mem[_23056]
                        require mem[_23056] == mem[_23056]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        mem[mem[64] + 128] = _11828
                        mem[mem[64] + 160 len ceil32(_11828)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11828)]
                        if ceil32(_11828) > _11828:
                            mem[mem[64] + _11828 + 160] = 0
                        mem[mem[64] + 96] = _23408
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               Array(len=_11828, data=mem[mem[64] + 160 len ceil32(_11828)]),
                               _23408
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11828 + 165] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23232 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23584 = mem[_23232]
                    require mem[_23232] == mem[_23232]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11828
                    mem[mem[64] + 160 len ceil32(_11828)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11828)]
                    if ceil32(_11828) > _11828:
                        mem[mem[64] + _11828 + 160] = 0
                    mem[mem[64] + 96] = _23584
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=_11828, data=mem[mem[64] + 160 len ceil32(_11828)]),
                           _23584
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 'SafeMath: multiplication overflow'
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[ceil32(return_data.size) + 128] = 0
                    mem[ceil32(return_data.size) + 160] = 128
                    mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           0,
                           ext_call.return_data[0],
                           mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                require arg1 < poolInfo.length
                mem[0] = 19
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 100] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[(2 * ceil32(return_data.size)) + 128] = 0
                    mem[(2 * ceil32(return_data.size)) + 160] = 128
                    mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           ext_call.return_data[0],
                           ext_call.return_data[0],
                           mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 96] = 4
                mem[64] = (4 * ceil32(return_data.size)) + 132
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                mem[(4 * ceil32(return_data.size)) + 136] = 0
                staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                        gas gas_remaining wei
                if not return_data.size:
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    if ext_call.return_data[0] < 64:
                        if ext_call.return_data[0] != 32:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                                   address(ext_call.return_data[0]),
                                   128,
                                   ext_call.return_data[0],
                                   3,
                                   '???',
                                   0
                        require 0 < ext_call.return_data[0]
                        require 0 < ext_call.return_data[0]
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               0,
                               None
                    require ext_call.return_data[0] >= 32
                    _11307 = 0, mem[132 len 28]
                    require 0, mem[132 len 28] <= test266151307()
                    require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                    _11825 = mem[0, mem[132 len 28] + 128]
                    require mem[0, mem[132 len 28] + 128] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                    mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                    require _11307 + _11825 + 160 <= ext_call.return_data[0] + 128
                    mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11825)] = mem[_11307 + 160 len ceil32(_11825)]
                    if ceil32(_11825) <= _11825:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23051 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23403 = mem[_23051]
                        require mem[_23051] == mem[_23051]
                        mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24107 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24107)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24107)]
                        if ceil32(_24107) > _24107:
                            mem[mem[64] + _24107 + 160] = 0
                        mem[mem[64] + 96] = _23403
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               _23403,
                               mem[mem[64] + 128 len ceil32(_24107) + 32]
                    mem[(4 * ceil32(return_data.size)) + _11825 + 164] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23227 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23579 = mem[_23227]
                    require mem[_23227] == mem[_23227]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24283 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24283)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24283)]
                    if ceil32(_24283) > _24283:
                        mem[mem[64] + _24283 + 160] = 0
                    mem[mem[64] + 96] = _23579
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23579,
                           mem[mem[64] + 128 len ceil32(_24283) + 32]
                mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if return_data.size < 64:
                    if 32 != return_data.size:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < return_data.size
                    require 0 < return_data.size
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                    if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                           ext_call.return_data[0]
                require return_data.size >= 32
                _11309 = mem[(4 * ceil32(return_data.size)) + 164]
                require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                _11826 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require _11309 + _11826 + 64 <= return_data.size + 32
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11826)] = mem[(4 * ceil32(return_data.size)) + _11309 + 196 len ceil32(_11826)]
                if ceil32(_11826) <= _11826:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23052 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23404 = mem[_23052]
                    require mem[_23052] == mem[_23052]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11826
                    mem[mem[64] + 160 len ceil32(_11826)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11826)]
                    if ceil32(_11826) > _11826:
                        mem[mem[64] + _11826 + 160] = 0
                    mem[mem[64] + 96] = _23404
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=_11826, data=mem[mem[64] + 160 len ceil32(_11826)]),
                           _23404
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11826 + 165] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23228 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23580 = mem[_23228]
                require mem[_23228] == mem[_23228]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11826
                mem[mem[64] + 160 len ceil32(_11826)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11826)]
                if ceil32(_11826) > _11826:
                    mem[mem[64] + _11826 + 160] = 0
                mem[mem[64] + 96] = _23580
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11826, data=mem[mem[64] + 160 len ceil32(_11826)]),
                       _23580
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[ceil32(return_data.size) + 128] = 0
                    mem[ceil32(return_data.size) + 160] = 128
                    mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           0,
                           128,
                           0,
                           ext_call.return_data[0],
                           mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                require arg1 < poolInfo.length
                mem[0] = 19
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 100] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[(2 * ceil32(return_data.size)) + 128] = 0
                    mem[(2 * ceil32(return_data.size)) + 160] = 128
                    mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           0,
                           128,
                           ext_call.return_data[0],
                           ext_call.return_data[0],
                           mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 96] = 4
                mem[64] = (4 * ceil32(return_data.size)) + 132
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                mem[(4 * ceil32(return_data.size)) + 136] = 0
                staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                        gas gas_remaining wei
                if not return_data.size:
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    if ext_call.return_data[0] < 64:
                        if ext_call.return_data[0] != 32:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                                   address(ext_call.return_data[0]),
                                   128,
                                   ext_call.return_data[0],
                                   3,
                                   '???',
                                   0
                        require 0 < ext_call.return_data[0]
                        require 0 < ext_call.return_data[0]
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               0,
                               None
                    require ext_call.return_data[0] >= 32
                    _11325 = 0, mem[132 len 28]
                    require 0, mem[132 len 28] <= test266151307()
                    require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                    _11831 = mem[0, mem[132 len 28] + 128]
                    require mem[0, mem[132 len 28] + 128] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                    mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                    require _11325 + _11831 + 160 <= ext_call.return_data[0] + 128
                    mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11831)] = mem[_11325 + 160 len ceil32(_11831)]
                    if ceil32(_11831) <= _11831:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23063 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23415 = mem[_23063]
                        require mem[_23063] == mem[_23063]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24119 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24119)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24119)]
                        if ceil32(_24119) > _24119:
                            mem[mem[64] + _24119 + 160] = 0
                        mem[mem[64] + 96] = _23415
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               _23415,
                               mem[mem[64] + 128 len ceil32(_24119) + 32]
                    mem[(4 * ceil32(return_data.size)) + _11831 + 164] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23239 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23591 = mem[_23239]
                    require mem[_23239] == mem[_23239]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24295 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24295)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24295)]
                    if ceil32(_24295) > _24295:
                        mem[mem[64] + _24295 + 160] = 0
                    mem[mem[64] + 96] = _23591
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           _23591,
                           mem[mem[64] + 128 len ceil32(_24295) + 32]
                mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if return_data.size < 64:
                    if 32 != return_data.size:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < return_data.size
                    require 0 < return_data.size
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                    if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                           ext_call.return_data[0]
                require return_data.size >= 32
                _11327 = mem[(4 * ceil32(return_data.size)) + 164]
                require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                _11832 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require _11327 + _11832 + 64 <= return_data.size + 32
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11832)] = mem[(4 * ceil32(return_data.size)) + _11327 + 196 len ceil32(_11832)]
                if ceil32(_11832) <= _11832:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23064 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23416 = mem[_23064]
                    require mem[_23064] == mem[_23064]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11832
                    mem[mem[64] + 160 len ceil32(_11832)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11832)]
                    if ceil32(_11832) > _11832:
                        mem[mem[64] + _11832 + 160] = 0
                    mem[mem[64] + 96] = _23416
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           Array(len=_11832, data=mem[mem[64] + 160 len ceil32(_11832)]),
                           _23416
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11832 + 165] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23240 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23592 = mem[_23240]
                require mem[_23240] == mem[_23240]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11832
                mem[mem[64] + 160 len ceil32(_11832)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11832)]
                if ceil32(_11832) > _11832:
                    mem[mem[64] + _11832 + 160] = 0
                mem[mem[64] + 96] = _23592
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=_11832, data=mem[mem[64] + 160 len ceil32(_11832)]),
                       _23592
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11319 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11829 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11319 + _11829 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11829)] = mem[_11319 + 160 len ceil32(_11829)]
                if ceil32(_11829) <= _11829:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23059 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23411 = mem[_23059]
                    require mem[_23059] == mem[_23059]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24115 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24115)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24115)]
                    if ceil32(_24115) > _24115:
                        mem[mem[64] + _24115 + 160] = 0
                    mem[mem[64] + 96] = _23411
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           _23411,
                           mem[mem[64] + 128 len ceil32(_24115) + 32]
                mem[(4 * ceil32(return_data.size)) + _11829 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23235 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23587 = mem[_23235]
                require mem[_23235] == mem[_23235]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24291 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24291)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24291)]
                if ceil32(_24291) > _24291:
                    mem[mem[64] + _24291 + 160] = 0
                mem[mem[64] + 96] = _23587
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23587,
                       mem[mem[64] + 128 len ceil32(_24291) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11321 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11830 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11321 + _11830 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11830)] = mem[(4 * ceil32(return_data.size)) + _11321 + 196 len ceil32(_11830)]
            if ceil32(_11830) <= _11830:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23060 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23412 = mem[_23060]
                require mem[_23060] == mem[_23060]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11830
                mem[mem[64] + 160 len ceil32(_11830)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11830)]
                if ceil32(_11830) > _11830:
                    mem[mem[64] + _11830 + 160] = 0
                mem[mem[64] + 96] = _23412
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=_11830, data=mem[mem[64] + 160 len ceil32(_11830)]),
                       _23412
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11830 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23236 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23588 = mem[_23236]
            require mem[_23236] == mem[_23236]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11830
            mem[mem[64] + 160 len ceil32(_11830)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11830)]
            if ceil32(_11830) > _11830:
                mem[mem[64] + _11830 + 160] = 0
            mem[mem[64] + 96] = _23588
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11830, data=mem[mem[64] + 160 len ceil32(_11830)]),
                   _23588
        require (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000
        if 10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        mem[32] = 18
        if depositTime[address(msg.sender)] <= block.timestamp:
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256
                    mem[ceil32(return_data.size) + 128] = 0
                    mem[ceil32(return_data.size) + 160] = 128
                    mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           0,
                           ext_call.return_data[0],
                           mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                require arg1 < poolInfo.length
                mem[0] = 19
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 100] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256
                    mem[(2 * ceil32(return_data.size)) + 128] = 0
                    mem[(2 * ceil32(return_data.size)) + 160] = 128
                    mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           ext_call.return_data[0],
                           ext_call.return_data[0],
                           mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 96] = 4
                mem[64] = (4 * ceil32(return_data.size)) + 132
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                mem[(4 * ceil32(return_data.size)) + 136] = 0
                staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                        gas gas_remaining wei
                if not return_data.size:
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    if ext_call.return_data[0] < 64:
                        if ext_call.return_data[0] != 32:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                        require 0 < ext_call.return_data[0]
                        require 0 < ext_call.return_data[0]
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 0, None
                    require ext_call.return_data[0] >= 32
                    _11289 = 0, mem[132 len 28]
                    require 0, mem[132 len 28] <= test266151307()
                    require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                    _11819 = mem[0, mem[132 len 28] + 128]
                    require mem[0, mem[132 len 28] + 128] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                    mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                    require _11289 + _11819 + 160 <= ext_call.return_data[0] + 128
                    mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11819)] = mem[_11289 + 160 len ceil32(_11819)]
                    if ceil32(_11819) <= _11819:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23039 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23391 = mem[_23039]
                        require mem[_23039] == mem[_23039]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24095 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24095)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24095)]
                        if ceil32(_24095) > _24095:
                            mem[mem[64] + _24095 + 160] = 0
                        mem[mem[64] + 96] = _23391
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               _23391,
                               mem[mem[64] + 128 len ceil32(_24095) + 32]
                    mem[(4 * ceil32(return_data.size)) + _11819 + 164] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23215 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23567 = mem[_23215]
                    require mem[_23215] == mem[_23215]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24271 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24271)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24271)]
                    if ceil32(_24271) > _24271:
                        mem[mem[64] + _24271 + 160] = 0
                    mem[mem[64] + 96] = _23567
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23567,
                           mem[mem[64] + 128 len ceil32(_24271) + 32]
                mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                if return_data.size < 64:
                    if 32 != return_data.size:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    require 0 < return_data.size
                    require 0 < return_data.size
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                    if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                           ext_call.return_data[0]
                require return_data.size >= 32
                _11291 = mem[(4 * ceil32(return_data.size)) + 164]
                require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                _11820 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require _11291 + _11820 + 64 <= return_data.size + 32
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11820)] = mem[(4 * ceil32(return_data.size)) + _11291 + 196 len ceil32(_11820)]
                if ceil32(_11820) <= _11820:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23040 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23392 = mem[_23040]
                    require mem[_23040] == mem[_23040]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11820
                    mem[mem[64] + 160 len ceil32(_11820)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11820)]
                    if ceil32(_11820) > _11820:
                        mem[mem[64] + _11820 + 160] = 0
                    mem[mem[64] + 96] = _23392
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=_11820, data=mem[mem[64] + 160 len ceil32(_11820)]),
                           _23392
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11820 + 165] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23216 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23568 = mem[_23216]
                require mem[_23216] == mem[_23216]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11820
                mem[mem[64] + 160 len ceil32(_11820)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11820)]
                if ceil32(_11820) > _11820:
                    mem[mem[64] + _11820 + 160] = 0
                mem[mem[64] + 96] = _23568
                return -userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11820, data=mem[mem[64] + 160 len ceil32(_11820)]),
                       _23568
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11283 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11817 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11283 + _11817 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11817)] = mem[_11283 + 160 len ceil32(_11817)]
                if ceil32(_11817) <= _11817:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23035 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23387 = mem[_23035]
                    require mem[_23035] == mem[_23035]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24091 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24091)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24091)]
                    if ceil32(_24091) > _24091:
                        mem[mem[64] + _24091 + 160] = 0
                    mem[mem[64] + 96] = _23387
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23387,
                           mem[mem[64] + 128 len ceil32(_24091) + 32]
                mem[(4 * ceil32(return_data.size)) + _11817 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23211 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23563 = mem[_23211]
                require mem[_23211] == mem[_23211]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24267 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24267)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24267)]
                if ceil32(_24267) > _24267:
                    mem[mem[64] + _24267 + 160] = 0
                mem[mem[64] + 96] = _23563
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       _23563,
                       mem[mem[64] + 128 len ceil32(_24267) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11285 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11818 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11285 + _11818 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11818)] = mem[(4 * ceil32(return_data.size)) + _11285 + 196 len ceil32(_11818)]
            if ceil32(_11818) <= _11818:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23036 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23388 = mem[_23036]
                require mem[_23036] == mem[_23036]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11818
                mem[mem[64] + 160 len ceil32(_11818)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11818)]
                if ceil32(_11818) > _11818:
                    mem[mem[64] + _11818 + 160] = 0
                mem[mem[64] + 96] = _23388
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11818, data=mem[mem[64] + 160 len ceil32(_11818)]),
                       _23388
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11818 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23212 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23564 = mem[_23212]
            require mem[_23212] == mem[_23212]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11818
            mem[mem[64] + 160 len ceil32(_11818)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11818)]
            if ceil32(_11818) > _11818:
                mem[mem[64] + _11818 + 160] = 0
            mem[mem[64] + 96] = _23564
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   address(ext_call.return_data[0]),
                   Array(len=_11818, data=mem[mem[64] + 160 len ceil32(_11818)]),
                   _23564
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11301 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11823 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11301 + _11823 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11823)] = mem[_11301 + 160 len ceil32(_11823)]
                if ceil32(_11823) <= _11823:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23047 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23399 = mem[_23047]
                    require mem[_23047] == mem[_23047]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24103 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24103)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24103)]
                    if ceil32(_24103) > _24103:
                        mem[mem[64] + _24103 + 160] = 0
                    mem[mem[64] + 96] = _23399
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           _23399,
                           mem[mem[64] + 128 len ceil32(_24103) + 32]
                mem[(4 * ceil32(return_data.size)) + _11823 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23223 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23575 = mem[_23223]
                require mem[_23223] == mem[_23223]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24279 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24279)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24279)]
                if ceil32(_24279) > _24279:
                    mem[mem[64] + _24279 + 160] = 0
                mem[mem[64] + 96] = _23575
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23575,
                       mem[mem[64] + 128 len ceil32(_24279) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11303 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11824 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11303 + _11824 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11824)] = mem[(4 * ceil32(return_data.size)) + _11303 + 196 len ceil32(_11824)]
            if ceil32(_11824) <= _11824:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23048 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23400 = mem[_23048]
                require mem[_23048] == mem[_23048]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11824
                mem[mem[64] + 160 len ceil32(_11824)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11824)]
                if ceil32(_11824) > _11824:
                    mem[mem[64] + _11824 + 160] = 0
                mem[mem[64] + 96] = _23400
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=_11824, data=mem[mem[64] + 160 len ceil32(_11824)]),
                       _23400
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11824 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23224 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23576 = mem[_23224]
            require mem[_23224] == mem[_23224]
            mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11824
            mem[mem[64] + 160 len ceil32(_11824)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11824)]
            if ceil32(_11824) > _11824:
                mem[mem[64] + _11824 + 160] = 0
            mem[mem[64] + 96] = _23576
            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11824, data=mem[mem[64] + 160 len ceil32(_11824)]),
                   _23576
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 128
            mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
            mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   0,
                   128,
                   0,
                   ext_call.return_data[0],
                   mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
        require arg1 < poolInfo.length
        mem[0] = 19
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 100] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[(2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + 160] = 128
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   0,
                   128,
                   ext_call.return_data[0],
                   ext_call.return_data[0],
                   mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(4 * ceil32(return_data.size)) + 96] = 4
        mem[64] = (4 * ceil32(return_data.size)) + 132
        mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
        mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
        mem[(4 * ceil32(return_data.size)) + 136] = 0
        staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                gas gas_remaining wei
        if not return_data.size:
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if ext_call.return_data[0] < 64:
                if ext_call.return_data[0] != 32:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < ext_call.return_data[0]
                require 0 < ext_call.return_data[0]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       0,
                       None
            require ext_call.return_data[0] >= 32
            _11295 = 0, mem[132 len 28]
            require 0, mem[132 len 28] <= test266151307()
            require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
            _11821 = mem[0, mem[132 len 28] + 128]
            require mem[0, mem[132 len 28] + 128] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
            mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
            require _11295 + _11821 + 160 <= ext_call.return_data[0] + 128
            mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11821)] = mem[_11295 + 160 len ceil32(_11821)]
            if ceil32(_11821) <= _11821:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23043 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23395 = mem[_23043]
                require mem[_23043] == mem[_23043]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24099 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24099)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24099)]
                if ceil32(_24099) > _24099:
                    mem[mem[64] + _24099 + 160] = 0
                mem[mem[64] + 96] = _23395
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23395,
                       mem[mem[64] + 128 len ceil32(_24099) + 32]
            mem[(4 * ceil32(return_data.size)) + _11821 + 164] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23219 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23571 = mem[_23219]
            require mem[_23219] == mem[_23219]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            _24275 = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 160 len ceil32(_24275)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24275)]
            if ceil32(_24275) > _24275:
                mem[mem[64] + _24275 + 160] = 0
            mem[mem[64] + 96] = _23571
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   _23571,
                   mem[mem[64] + 128 len ceil32(_24275) + 32]
        mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
        mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   ext_call.return_data[0],
                   3,
                   '???',
                   0
        if return_data.size < 64:
            if 32 != return_data.size:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            require 0 < return_data.size
            require 0 < return_data.size
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
            if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                   ext_call.return_data[0]
        require return_data.size >= 32
        _11297 = mem[(4 * ceil32(return_data.size)) + 164]
        require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
        _11822 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
        mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require _11297 + _11822 + 64 <= return_data.size + 32
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11822)] = mem[(4 * ceil32(return_data.size)) + _11297 + 196 len ceil32(_11822)]
        if ceil32(_11822) <= _11822:
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23044 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23396 = mem[_23044]
            require mem[_23044] == mem[_23044]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11822
            mem[mem[64] + 160 len ceil32(_11822)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11822)]
            if ceil32(_11822) > _11822:
                mem[mem[64] + _11822 + 160] = 0
            mem[mem[64] + 96] = _23396
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11822, data=mem[mem[64] + 160 len ceil32(_11822)]),
                   _23396
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11822 + 165] = 0
        mem[mem[64] + 4] = arg2
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _23220 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _23572 = mem[_23220]
        require mem[_23220] == mem[_23220]
        mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
        mem[mem[64] + 32] = address(ext_call.return_data[0])
        mem[mem[64] + 64] = 128
        mem[mem[64] + 128] = _11822
        mem[mem[64] + 160 len ceil32(_11822)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11822)]
        if ceil32(_11822) > _11822:
            mem[mem[64] + _11822 + 160] = 0
        mem[mem[64] + 96] = _23572
        return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * 0 / totalAllocPoint) - (devPercent * 0 / totalAllocPoint) - (treasuryPercent * 0 / totalAllocPoint) - (investorPercent * 0 / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
               address(ext_call.return_data[0]),
               Array(len=_11822, data=mem[mem[64] + 160 len ceil32(_11822)]),
               _23572
    require (block.timestamp * sub_4a7d91a1) - (poolInfo[arg1].field_512 * sub_4a7d91a1)
    if (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / (block.timestamp * sub_4a7d91a1) - (poolInfo[arg1].field_512 * sub_4a7d91a1) != poolInfo[arg1].field_256:
        revert with 0, 'SafeMath: multiplication overflow'
    if totalAllocPoint <= 0:
        revert with 0, 'SafeMath: division by zero'
    require totalAllocPoint
    if not (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint:
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        mem[32] = 18
        if depositTime[address(msg.sender)] <= block.timestamp:
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256
                    mem[ceil32(return_data.size) + 128] = 0
                    mem[ceil32(return_data.size) + 160] = 128
                    mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           0,
                           ext_call.return_data[0],
                           mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                require arg1 < poolInfo.length
                mem[0] = 19
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 100] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256
                    mem[(2 * ceil32(return_data.size)) + 128] = 0
                    mem[(2 * ceil32(return_data.size)) + 160] = 128
                    mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           ext_call.return_data[0],
                           ext_call.return_data[0],
                           mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 96] = 4
                mem[64] = (4 * ceil32(return_data.size)) + 132
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                mem[(4 * ceil32(return_data.size)) + 136] = 0
                staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                        gas gas_remaining wei
                if not return_data.size:
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    if ext_call.return_data[0] < 64:
                        if ext_call.return_data[0] != 32:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                        require 0 < ext_call.return_data[0]
                        require 0 < ext_call.return_data[0]
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 0, None
                    require ext_call.return_data[0] >= 32
                    _11265 = 0, mem[132 len 28]
                    require 0, mem[132 len 28] <= test266151307()
                    require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                    _11811 = mem[0, mem[132 len 28] + 128]
                    require mem[0, mem[132 len 28] + 128] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                    mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                    require _11265 + _11811 + 160 <= ext_call.return_data[0] + 128
                    mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11811)] = mem[_11265 + 160 len ceil32(_11811)]
                    if ceil32(_11811) <= _11811:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23023 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23375 = mem[_23023]
                        require mem[_23023] == mem[_23023]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24079 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24079)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24079)]
                        if ceil32(_24079) > _24079:
                            mem[mem[64] + _24079 + 160] = 0
                        mem[mem[64] + 96] = _23375
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               _23375,
                               mem[mem[64] + 128 len ceil32(_24079) + 32]
                    mem[(4 * ceil32(return_data.size)) + _11811 + 164] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23199 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23551 = mem[_23199]
                    require mem[_23199] == mem[_23199]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24255 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24255)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24255)]
                    if ceil32(_24255) > _24255:
                        mem[mem[64] + _24255 + 160] = 0
                    mem[mem[64] + 96] = _23551
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23551,
                           mem[mem[64] + 128 len ceil32(_24255) + 32]
                mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                if return_data.size < 64:
                    if 32 != return_data.size:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    require 0 < return_data.size
                    require 0 < return_data.size
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                    if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                           ext_call.return_data[0]
                require return_data.size >= 32
                _11267 = mem[(4 * ceil32(return_data.size)) + 164]
                require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                _11812 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require _11267 + _11812 + 64 <= return_data.size + 32
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11812)] = mem[(4 * ceil32(return_data.size)) + _11267 + 196 len ceil32(_11812)]
                if ceil32(_11812) <= _11812:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23024 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23376 = mem[_23024]
                    require mem[_23024] == mem[_23024]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11812
                    mem[mem[64] + 160 len ceil32(_11812)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11812)]
                    if ceil32(_11812) > _11812:
                        mem[mem[64] + _11812 + 160] = 0
                    mem[mem[64] + 96] = _23376
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=_11812, data=mem[mem[64] + 160 len ceil32(_11812)]),
                           _23376
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11812 + 165] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23200 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23552 = mem[_23200]
                require mem[_23200] == mem[_23200]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11812
                mem[mem[64] + 160 len ceil32(_11812)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11812)]
                if ceil32(_11812) > _11812:
                    mem[mem[64] + _11812 + 160] = 0
                mem[mem[64] + 96] = _23552
                return -userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11812, data=mem[mem[64] + 160 len ceil32(_11812)]),
                       _23552
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11259 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11809 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11259 + _11809 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11809)] = mem[_11259 + 160 len ceil32(_11809)]
                if ceil32(_11809) <= _11809:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23019 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23371 = mem[_23019]
                    require mem[_23019] == mem[_23019]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24075 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24075)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24075)]
                    if ceil32(_24075) > _24075:
                        mem[mem[64] + _24075 + 160] = 0
                    mem[mem[64] + 96] = _23371
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23371,
                           mem[mem[64] + 128 len ceil32(_24075) + 32]
                mem[(4 * ceil32(return_data.size)) + _11809 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23195 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23547 = mem[_23195]
                require mem[_23195] == mem[_23195]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24251 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24251)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24251)]
                if ceil32(_24251) > _24251:
                    mem[mem[64] + _24251 + 160] = 0
                mem[mem[64] + 96] = _23547
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       _23547,
                       mem[mem[64] + 128 len ceil32(_24251) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11261 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11810 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11261 + _11810 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11810)] = mem[(4 * ceil32(return_data.size)) + _11261 + 196 len ceil32(_11810)]
            if ceil32(_11810) <= _11810:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23020 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23372 = mem[_23020]
                require mem[_23020] == mem[_23020]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11810
                mem[mem[64] + 160 len ceil32(_11810)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11810)]
                if ceil32(_11810) > _11810:
                    mem[mem[64] + _11810 + 160] = 0
                mem[mem[64] + 96] = _23372
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11810, data=mem[mem[64] + 160 len ceil32(_11810)]),
                       _23372
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11810 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23196 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23548 = mem[_23196]
            require mem[_23196] == mem[_23196]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11810
            mem[mem[64] + 160 len ceil32(_11810)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11810)]
            if ceil32(_11810) > _11810:
                mem[mem[64] + _11810 + 160] = 0
            mem[mem[64] + 96] = _23548
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   address(ext_call.return_data[0]),
                   Array(len=_11810, data=mem[mem[64] + 160 len ceil32(_11810)]),
                   _23548
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11277 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11815 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11277 + _11815 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11815)] = mem[_11277 + 160 len ceil32(_11815)]
                if ceil32(_11815) <= _11815:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23031 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23383 = mem[_23031]
                    require mem[_23031] == mem[_23031]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24087 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24087)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24087)]
                    if ceil32(_24087) > _24087:
                        mem[mem[64] + _24087 + 160] = 0
                    mem[mem[64] + 96] = _23383
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           _23383,
                           mem[mem[64] + 128 len ceil32(_24087) + 32]
                mem[(4 * ceil32(return_data.size)) + _11815 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23207 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23559 = mem[_23207]
                require mem[_23207] == mem[_23207]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24263 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24263)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24263)]
                if ceil32(_24263) > _24263:
                    mem[mem[64] + _24263 + 160] = 0
                mem[mem[64] + 96] = _23559
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23559,
                       mem[mem[64] + 128 len ceil32(_24263) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11279 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11816 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11279 + _11816 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11816)] = mem[(4 * ceil32(return_data.size)) + _11279 + 196 len ceil32(_11816)]
            if ceil32(_11816) <= _11816:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23032 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23384 = mem[_23032]
                require mem[_23032] == mem[_23032]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11816
                mem[mem[64] + 160 len ceil32(_11816)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11816)]
                if ceil32(_11816) > _11816:
                    mem[mem[64] + _11816 + 160] = 0
                mem[mem[64] + 96] = _23384
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=_11816, data=mem[mem[64] + 160 len ceil32(_11816)]),
                       _23384
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11816 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23208 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23560 = mem[_23208]
            require mem[_23208] == mem[_23208]
            mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11816
            mem[mem[64] + 160 len ceil32(_11816)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11816)]
            if ceil32(_11816) > _11816:
                mem[mem[64] + _11816 + 160] = 0
            mem[mem[64] + 96] = _23560
            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11816, data=mem[mem[64] + 160 len ceil32(_11816)]),
                   _23560
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 128
            mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
            mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   0,
                   128,
                   0,
                   ext_call.return_data[0],
                   mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
        require arg1 < poolInfo.length
        mem[0] = 19
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 100] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[(2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + 160] = 128
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   0,
                   128,
                   ext_call.return_data[0],
                   ext_call.return_data[0],
                   mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(4 * ceil32(return_data.size)) + 96] = 4
        mem[64] = (4 * ceil32(return_data.size)) + 132
        mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
        mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
        mem[(4 * ceil32(return_data.size)) + 136] = 0
        staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                gas gas_remaining wei
        if not return_data.size:
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if ext_call.return_data[0] < 64:
                if ext_call.return_data[0] != 32:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < ext_call.return_data[0]
                require 0 < ext_call.return_data[0]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       0,
                       None
            require ext_call.return_data[0] >= 32
            _11271 = 0, mem[132 len 28]
            require 0, mem[132 len 28] <= test266151307()
            require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
            _11813 = mem[0, mem[132 len 28] + 128]
            require mem[0, mem[132 len 28] + 128] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
            mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
            require _11271 + _11813 + 160 <= ext_call.return_data[0] + 128
            mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11813)] = mem[_11271 + 160 len ceil32(_11813)]
            if ceil32(_11813) <= _11813:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23027 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23379 = mem[_23027]
                require mem[_23027] == mem[_23027]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24083 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24083)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24083)]
                if ceil32(_24083) > _24083:
                    mem[mem[64] + _24083 + 160] = 0
                mem[mem[64] + 96] = _23379
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23379,
                       mem[mem[64] + 128 len ceil32(_24083) + 32]
            mem[(4 * ceil32(return_data.size)) + _11813 + 164] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23203 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23555 = mem[_23203]
            require mem[_23203] == mem[_23203]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            _24259 = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 160 len ceil32(_24259)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24259)]
            if ceil32(_24259) > _24259:
                mem[mem[64] + _24259 + 160] = 0
            mem[mem[64] + 96] = _23555
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   _23555,
                   mem[mem[64] + 128 len ceil32(_24259) + 32]
        mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
        mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   ext_call.return_data[0],
                   3,
                   '???',
                   0
        if return_data.size < 64:
            if 32 != return_data.size:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            require 0 < return_data.size
            require 0 < return_data.size
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
            if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                   ext_call.return_data[0]
        require return_data.size >= 32
        _11273 = mem[(4 * ceil32(return_data.size)) + 164]
        require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
        _11814 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
        mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require _11273 + _11814 + 64 <= return_data.size + 32
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11814)] = mem[(4 * ceil32(return_data.size)) + _11273 + 196 len ceil32(_11814)]
        if ceil32(_11814) <= _11814:
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23028 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23380 = mem[_23028]
            require mem[_23028] == mem[_23028]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11814
            mem[mem[64] + 160 len ceil32(_11814)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11814)]
            if ceil32(_11814) > _11814:
                mem[mem[64] + _11814 + 160] = 0
            mem[mem[64] + 96] = _23380
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11814, data=mem[mem[64] + 160 len ceil32(_11814)]),
                   _23380
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11814 + 165] = 0
        mem[mem[64] + 4] = arg2
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _23204 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _23556 = mem[_23204]
        require mem[_23204] == mem[_23204]
        mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
        mem[mem[64] + 32] = address(ext_call.return_data[0])
        mem[mem[64] + 64] = 128
        mem[mem[64] + 128] = _11814
        mem[mem[64] + 160 len ceil32(_11814)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11814)]
        if ceil32(_11814) > _11814:
            mem[mem[64] + _11814 + 160] = 0
        mem[mem[64] + 96] = _23556
        return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
               address(ext_call.return_data[0]),
               Array(len=_11814, data=mem[mem[64] + 160 len ceil32(_11814)]),
               _23556
    require (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint
    if (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint != -devPercent + -treasuryPercent + -investorPercent + 1000:
        revert with 0, 'SafeMath: multiplication overflow'
    if not (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000:
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        mem[32] = 18
        if depositTime[address(msg.sender)] <= block.timestamp:
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256
                    mem[ceil32(return_data.size) + 128] = 0
                    mem[ceil32(return_data.size) + 160] = 128
                    mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           0,
                           ext_call.return_data[0],
                           mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
                require arg1 < poolInfo.length
                mem[0] = 19
                if not poolInfo[arg1].field_1024:
                    mem[ceil32(return_data.size) + 100] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256
                    mem[(2 * ceil32(return_data.size)) + 128] = 0
                    mem[(2 * ceil32(return_data.size)) + 160] = 128
                    mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                    mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                    if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                        mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           0,
                           128,
                           ext_call.return_data[0],
                           ext_call.return_data[0],
                           mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.rewardToken() with:
                        gas gas_remaining wei
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                mem[(4 * ceil32(return_data.size)) + 96] = 4
                mem[64] = (4 * ceil32(return_data.size)) + 132
                mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
                mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
                mem[(4 * ceil32(return_data.size)) + 136] = 0
                staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                        gas gas_remaining wei
                if not return_data.size:
                    if not ext_call.success:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    if ext_call.return_data[0] < 64:
                        if ext_call.return_data[0] != 32:
                            require ext_code.size(poolInfo[arg1].field_1024)
                            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                    gas gas_remaining wei
                                   args arg2
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                        require 0 < ext_call.return_data[0]
                        require 0 < ext_call.return_data[0]
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 0, None
                    require ext_call.return_data[0] >= 32
                    _11241 = 0, mem[132 len 28]
                    require 0, mem[132 len 28] <= test266151307()
                    require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                    _11803 = mem[0, mem[132 len 28] + 128]
                    require mem[0, mem[132 len 28] + 128] <= test266151307()
                    require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                    mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                    mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                    require _11241 + _11803 + 160 <= ext_call.return_data[0] + 128
                    mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11803)] = mem[_11241 + 160 len ceil32(_11803)]
                    if ceil32(_11803) <= _11803:
                        mem[mem[64] + 4] = arg2
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args address(arg2)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _23007 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _23359 = mem[_23007]
                        require mem[_23007] == mem[_23007]
                        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                        mem[mem[64] + 32] = address(ext_call.return_data[0])
                        mem[mem[64] + 64] = 128
                        _24063 = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                        mem[mem[64] + 160 len ceil32(_24063)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24063)]
                        if ceil32(_24063) > _24063:
                            mem[mem[64] + _24063 + 160] = 0
                        mem[mem[64] + 96] = _23359
                        return -userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               _23359,
                               mem[mem[64] + 128 len ceil32(_24063) + 32]
                    mem[(4 * ceil32(return_data.size)) + _11803 + 164] = 0
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23183 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23535 = mem[_23183]
                    require mem[_23183] == mem[_23183]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24239 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24239)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24239)]
                    if ceil32(_24239) > _24239:
                        mem[mem[64] + _24239 + 160] = 0
                    mem[mem[64] + 96] = _23535
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23535,
                           mem[mem[64] + 128 len ceil32(_24239) + 32]
                mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
                mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                if return_data.size < 64:
                    if 32 != return_data.size:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    require 0 < return_data.size
                    require 0 < return_data.size
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                    if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                           ext_call.return_data[0]
                require return_data.size >= 32
                _11243 = mem[(4 * ceil32(return_data.size)) + 164]
                require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
                _11804 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
                require _11243 + _11804 + 64 <= return_data.size + 32
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11804)] = mem[(4 * ceil32(return_data.size)) + _11243 + 196 len ceil32(_11804)]
                if ceil32(_11804) <= _11804:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23008 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23360 = mem[_23008]
                    require mem[_23008] == mem[_23008]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    mem[mem[64] + 128] = _11804
                    mem[mem[64] + 160 len ceil32(_11804)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11804)]
                    if ceil32(_11804) > _11804:
                        mem[mem[64] + _11804 + 160] = 0
                    mem[mem[64] + 96] = _23360
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           Array(len=_11804, data=mem[mem[64] + 160 len ceil32(_11804)]),
                           _23360
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11804 + 165] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23184 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23536 = mem[_23184]
                require mem[_23184] == mem[_23184]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11804
                mem[mem[64] + 160 len ceil32(_11804)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11804)]
                if ceil32(_11804) > _11804:
                    mem[mem[64] + _11804 + 160] = 0
                mem[mem[64] + 96] = _23536
                return -userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11804, data=mem[mem[64] + 160 len ceil32(_11804)]),
                       _23536
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11235 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11801 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11235 + _11801 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11801)] = mem[_11235 + 160 len ceil32(_11801)]
                if ceil32(_11801) <= _11801:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23003 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23355 = mem[_23003]
                    require mem[_23003] == mem[_23003]
                    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24059 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24059)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24059)]
                    if ceil32(_24059) > _24059:
                        mem[mem[64] + _24059 + 160] = 0
                    mem[mem[64] + 96] = _23355
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23355,
                           mem[mem[64] + 128 len ceil32(_24059) + 32]
                mem[(4 * ceil32(return_data.size)) + _11801 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23179 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23531 = mem[_23179]
                require mem[_23179] == mem[_23179]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24235 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24235)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24235)]
                if ceil32(_24235) > _24235:
                    mem[mem[64] + _24235 + 160] = 0
                mem[mem[64] + 96] = _23531
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       _23531,
                       mem[mem[64] + 128 len ceil32(_24235) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11237 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11802 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11237 + _11802 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11802)] = mem[(4 * ceil32(return_data.size)) + _11237 + 196 len ceil32(_11802)]
            if ceil32(_11802) <= _11802:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23004 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23356 = mem[_23004]
                require mem[_23004] == mem[_23004]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11802
                mem[mem[64] + 160 len ceil32(_11802)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11802)]
                if ceil32(_11802) > _11802:
                    mem[mem[64] + _11802 + 160] = 0
                mem[mem[64] + 96] = _23356
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11802, data=mem[mem[64] + 160 len ceil32(_11802)]),
                       _23356
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11802 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23180 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23532 = mem[_23180]
            require mem[_23180] == mem[_23180]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11802
            mem[mem[64] + 160 len ceil32(_11802)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11802)]
            if ceil32(_11802) > _11802:
                mem[mem[64] + _11802 + 160] = 0
            mem[mem[64] + 96] = _23532
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   address(ext_call.return_data[0]),
                   Array(len=_11802, data=mem[mem[64] + 160 len ceil32(_11802)]),
                   _23532
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                               address(ext_call.return_data[0]),
                               128,
                               ext_call.return_data[0],
                               3,
                               '???',
                               0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           0,
                           None
                require ext_call.return_data[0] >= 32
                _11253 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11807 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11253 + _11807 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11807)] = mem[_11253 + 160 len ceil32(_11807)]
                if ceil32(_11807) <= _11807:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _23015 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23367 = mem[_23015]
                    require mem[_23015] == mem[_23015]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24071 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24071)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24071)]
                    if ceil32(_24071) > _24071:
                        mem[mem[64] + _24071 + 160] = 0
                    mem[mem[64] + 96] = _23367
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           _23367,
                           mem[mem[64] + 128 len ceil32(_24071) + 32]
                mem[(4 * ceil32(return_data.size)) + _11807 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23191 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23543 = mem[_23191]
                require mem[_23191] == mem[_23191]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24247 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24247)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24247)]
                if ceil32(_24247) > _24247:
                    mem[mem[64] + _24247 + 160] = 0
                mem[mem[64] + 96] = _23543
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23543,
                       mem[mem[64] + 128 len ceil32(_24247) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11255 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11808 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11255 + _11808 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11808)] = mem[(4 * ceil32(return_data.size)) + _11255 + 196 len ceil32(_11808)]
            if ceil32(_11808) <= _11808:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23016 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23368 = mem[_23016]
                require mem[_23016] == mem[_23016]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11808
                mem[mem[64] + 160 len ceil32(_11808)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11808)]
                if ceil32(_11808) > _11808:
                    mem[mem[64] + _11808 + 160] = 0
                mem[mem[64] + 96] = _23368
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       Array(len=_11808, data=mem[mem[64] + 160 len ceil32(_11808)]),
                       _23368
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11808 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23192 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23544 = mem[_23192]
            require mem[_23192] == mem[_23192]
            mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11808
            mem[mem[64] + 160 len ceil32(_11808)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11808)]
            if ceil32(_11808) > _11808:
                mem[mem[64] + _11808 + 160] = 0
            mem[mem[64] + 96] = _23544
            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11808, data=mem[mem[64] + 160 len ceil32(_11808)]),
                   _23544
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 128
            mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
            mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   0,
                   128,
                   0,
                   ext_call.return_data[0],
                   mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
        require arg1 < poolInfo.length
        mem[0] = 19
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 100] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[(2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + 160] = 128
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   0,
                   128,
                   ext_call.return_data[0],
                   ext_call.return_data[0],
                   mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(4 * ceil32(return_data.size)) + 96] = 4
        mem[64] = (4 * ceil32(return_data.size)) + 132
        mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
        mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
        mem[(4 * ceil32(return_data.size)) + 136] = 0
        staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                gas gas_remaining wei
        if not return_data.size:
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if ext_call.return_data[0] < 64:
                if ext_call.return_data[0] != 32:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < ext_call.return_data[0]
                require 0 < ext_call.return_data[0]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       0,
                       None
            require ext_call.return_data[0] >= 32
            _11247 = 0, mem[132 len 28]
            require 0, mem[132 len 28] <= test266151307()
            require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
            _11805 = mem[0, mem[132 len 28] + 128]
            require mem[0, mem[132 len 28] + 128] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
            mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
            require _11247 + _11805 + 160 <= ext_call.return_data[0] + 128
            mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11805)] = mem[_11247 + 160 len ceil32(_11805)]
            if ceil32(_11805) <= _11805:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23011 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23363 = mem[_23011]
                require mem[_23011] == mem[_23011]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24067 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24067)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24067)]
                if ceil32(_24067) > _24067:
                    mem[mem[64] + _24067 + 160] = 0
                mem[mem[64] + 96] = _23363
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23363,
                       mem[mem[64] + 128 len ceil32(_24067) + 32]
            mem[(4 * ceil32(return_data.size)) + _11805 + 164] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23187 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23539 = mem[_23187]
            require mem[_23187] == mem[_23187]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            _24243 = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 160 len ceil32(_24243)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24243)]
            if ceil32(_24243) > _24243:
                mem[mem[64] + _24243 + 160] = 0
            mem[mem[64] + 96] = _23539
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   _23539,
                   mem[mem[64] + 128 len ceil32(_24243) + 32]
        mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
        mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   ext_call.return_data[0],
                   3,
                   '???',
                   0
        if return_data.size < 64:
            if 32 != return_data.size:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            require 0 < return_data.size
            require 0 < return_data.size
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
            if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                   ext_call.return_data[0]
        require return_data.size >= 32
        _11249 = mem[(4 * ceil32(return_data.size)) + 164]
        require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
        _11806 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
        mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require _11249 + _11806 + 64 <= return_data.size + 32
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11806)] = mem[(4 * ceil32(return_data.size)) + _11249 + 196 len ceil32(_11806)]
        if ceil32(_11806) <= _11806:
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23012 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23364 = mem[_23012]
            require mem[_23012] == mem[_23012]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11806
            mem[mem[64] + 160 len ceil32(_11806)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11806)]
            if ceil32(_11806) > _11806:
                mem[mem[64] + _11806 + 160] = 0
            mem[mem[64] + 96] = _23364
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11806, data=mem[mem[64] + 160 len ceil32(_11806)]),
                   _23364
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11806 + 165] = 0
        mem[mem[64] + 4] = arg2
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _23188 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _23540 = mem[_23188]
        require mem[_23188] == mem[_23188]
        mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
        mem[mem[64] + 32] = address(ext_call.return_data[0])
        mem[mem[64] + 64] = 128
        mem[mem[64] + 128] = _11806
        mem[mem[64] + 160 len ceil32(_11806)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11806)]
        if ceil32(_11806) > _11806:
            mem[mem[64] + _11806 + 160] = 0
        mem[mem[64] + 96] = _23540
        return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
               address(ext_call.return_data[0]),
               Array(len=_11806, data=mem[mem[64] + 160 len ceil32(_11806)]),
               _23540
    require (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000
    if 10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 != 10^12:
        revert with 0, 'SafeMath: multiplication overflow'
    if ext_call.return_data[0] <= 0:
        revert with 0, 'SafeMath: division by zero'
    require ext_call.return_data[0]
    if poolInfo[arg1].field_768 + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
        revert with 0, 'SafeMath: addition overflow'
    mem[32] = 18
    if depositTime[address(msg.sender)] <= block.timestamp:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256
                mem[ceil32(return_data.size) + 128] = 0
                mem[ceil32(return_data.size) + 160] = 128
                mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
                return -userInfo[arg1][address(arg2)].field_256, 
                       0,
                       128,
                       0,
                       ext_call.return_data[0],
                       mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
            require arg1 < poolInfo.length
            mem[0] = 19
            if not poolInfo[arg1].field_1024:
                mem[ceil32(return_data.size) + 100] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256
                mem[(2 * ceil32(return_data.size)) + 128] = 0
                mem[(2 * ceil32(return_data.size)) + 160] = 128
                mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
                if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                    mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
                return -userInfo[arg1][address(arg2)].field_256, 
                       0,
                       128,
                       ext_call.return_data[0],
                       ext_call.return_data[0],
                       mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.rewardToken() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            mem[(4 * ceil32(return_data.size)) + 96] = 4
            mem[64] = (4 * ceil32(return_data.size)) + 132
            mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
            mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
            mem[(4 * ceil32(return_data.size)) + 136] = 0
            staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                    gas gas_remaining wei
            if not return_data.size:
                if not ext_call.success:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                if ext_call.return_data[0] < 64:
                    if ext_call.return_data[0] != 32:
                        require ext_code.size(poolInfo[arg1].field_1024)
                        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                                gas gas_remaining wei
                               args arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[0]
                        return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                    require 0 < ext_call.return_data[0]
                    require 0 < ext_call.return_data[0]
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 0, None
                require ext_call.return_data[0] >= 32
                _11217 = 0, mem[132 len 28]
                require 0, mem[132 len 28] <= test266151307()
                require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
                _11795 = mem[0, mem[132 len 28] + 128]
                require mem[0, mem[132 len 28] + 128] <= test266151307()
                require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
                mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
                mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
                require _11217 + _11795 + 160 <= ext_call.return_data[0] + 128
                mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11795)] = mem[_11217 + 160 len ceil32(_11795)]
                if ceil32(_11795) <= _11795:
                    mem[mem[64] + 4] = arg2
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args address(arg2)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _22991 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _23343 = mem[_22991]
                    require mem[_22991] == mem[_22991]
                    mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                    mem[mem[64] + 32] = address(ext_call.return_data[0])
                    mem[mem[64] + 64] = 128
                    _24047 = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                    mem[mem[64] + 160 len ceil32(_24047)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24047)]
                    if ceil32(_24047) > _24047:
                        mem[mem[64] + _24047 + 160] = 0
                    mem[mem[64] + 96] = _23343
                    return -userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           _23343,
                           mem[mem[64] + 128 len ceil32(_24047) + 32]
                mem[(4 * ceil32(return_data.size)) + _11795 + 164] = 0
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _23167 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23519 = mem[_23167]
                require mem[_23167] == mem[_23167]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24223 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24223)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24223)]
                if ceil32(_24223) > _24223:
                    mem[mem[64] + _24223 + 160] = 0
                mem[mem[64] + 96] = _23519
                return -userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       _23519,
                       mem[mem[64] + 128 len ceil32(_24223) + 32]
            mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
            mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
            if return_data.size < 64:
                if 32 != return_data.size:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return -userInfo[arg1][address(arg2)].field_256, address(ext_call.return_data[0]), 128, ext_call.return_data[0], 3, '???', 0
                require 0 < return_data.size
                require 0 < return_data.size
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
                if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                    mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
                return -userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                       ext_call.return_data[0]
            require return_data.size >= 32
            _11219 = mem[(4 * ceil32(return_data.size)) + 164]
            require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
            _11796 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
            require _11219 + _11796 + 64 <= return_data.size + 32
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11796)] = mem[(4 * ceil32(return_data.size)) + _11219 + 196 len ceil32(_11796)]
            if ceil32(_11796) <= _11796:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _22992 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23344 = mem[_22992]
                require mem[_22992] == mem[_22992]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                mem[mem[64] + 128] = _11796
                mem[mem[64] + 160 len ceil32(_11796)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11796)]
                if ceil32(_11796) > _11796:
                    mem[mem[64] + _11796 + 160] = 0
                mem[mem[64] + 96] = _23344
                return -userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       Array(len=_11796, data=mem[mem[64] + 160 len ceil32(_11796)]),
                       _23344
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11796 + 165] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23168 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23520 = mem[_23168]
            require mem[_23168] == mem[_23168]
            mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11796
            mem[mem[64] + 160 len ceil32(_11796)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11796)]
            if ceil32(_11796) > _11796:
                mem[mem[64] + _11796 + 160] = 0
            mem[mem[64] + 96] = _23520
            return -userInfo[arg1][address(arg2)].field_256, 
                   address(ext_call.return_data[0]),
                   Array(len=_11796, data=mem[mem[64] + 160 len ceil32(_11796)]),
                   _23520
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 128
            mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
            mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   0,
                   128,
                   0,
                   ext_call.return_data[0],
                   mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
        require arg1 < poolInfo.length
        mem[0] = 19
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 100] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
            mem[(2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + 160] = 128
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   0,
                   128,
                   ext_call.return_data[0],
                   ext_call.return_data[0],
                   mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(4 * ceil32(return_data.size)) + 96] = 4
        mem[64] = (4 * ceil32(return_data.size)) + 132
        mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
        mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
        mem[(4 * ceil32(return_data.size)) + 136] = 0
        staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                gas gas_remaining wei
        if not return_data.size:
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if ext_call.return_data[0] < 64:
                if ext_call.return_data[0] != 32:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < ext_call.return_data[0]
                require 0 < ext_call.return_data[0]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       0,
                       None
            require ext_call.return_data[0] >= 32
            _11211 = 0, mem[132 len 28]
            require 0, mem[132 len 28] <= test266151307()
            require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
            _11793 = mem[0, mem[132 len 28] + 128]
            require mem[0, mem[132 len 28] + 128] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
            mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
            require _11211 + _11793 + 160 <= ext_call.return_data[0] + 128
            mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11793)] = mem[_11211 + 160 len ceil32(_11793)]
            if ceil32(_11793) <= _11793:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _22987 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23339 = mem[_22987]
                require mem[_22987] == mem[_22987]
                mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24043 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24043)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24043)]
                if ceil32(_24043) > _24043:
                    mem[mem[64] + _24043 + 160] = 0
                mem[mem[64] + 96] = _23339
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       _23339,
                       mem[mem[64] + 128 len ceil32(_24043) + 32]
            mem[(4 * ceil32(return_data.size)) + _11793 + 164] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23163 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23515 = mem[_23163]
            require mem[_23163] == mem[_23163]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            _24219 = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 160 len ceil32(_24219)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24219)]
            if ceil32(_24219) > _24219:
                mem[mem[64] + _24219 + 160] = 0
            mem[mem[64] + 96] = _23515
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   address(ext_call.return_data[0]),
                   128,
                   _23515,
                   mem[mem[64] + 128 len ceil32(_24219) + 32]
        mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
        mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   address(ext_call.return_data[0]),
                   128,
                   ext_call.return_data[0],
                   3,
                   '???',
                   0
        if return_data.size < 64:
            if 32 != return_data.size:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            require 0 < return_data.size
            require 0 < return_data.size
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
            if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   address(ext_call.return_data[0]),
                   Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                   ext_call.return_data[0]
        require return_data.size >= 32
        _11213 = mem[(4 * ceil32(return_data.size)) + 164]
        require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
        _11794 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
        mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require _11213 + _11794 + 64 <= return_data.size + 32
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11794)] = mem[(4 * ceil32(return_data.size)) + _11213 + 196 len ceil32(_11794)]
        if ceil32(_11794) <= _11794:
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _22988 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23340 = mem[_22988]
            require mem[_22988] == mem[_22988]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11794
            mem[mem[64] + 160 len ceil32(_11794)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11794)]
            if ceil32(_11794) > _11794:
                mem[mem[64] + _11794 + 160] = 0
            mem[mem[64] + 96] = _23340
            return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
                   address(ext_call.return_data[0]),
                   Array(len=_11794, data=mem[mem[64] + 160 len ceil32(_11794)]),
                   _23340
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11794 + 165] = 0
        mem[mem[64] + 4] = arg2
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _23164 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _23516 = mem[_23164]
        require mem[_23164] == mem[_23164]
        mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256
        mem[mem[64] + 32] = address(ext_call.return_data[0])
        mem[mem[64] + 64] = 128
        mem[mem[64] + 128] = _11794
        mem[mem[64] + 160 len ceil32(_11794)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11794)]
        if ceil32(_11794) > _11794:
            mem[mem[64] + _11794 + 160] = 0
        mem[mem[64] + 96] = _23516
        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256, 
               address(ext_call.return_data[0]),
               Array(len=_11794, data=mem[mem[64] + 160 len ceil32(_11794)]),
               _23516
    if not userInfo[arg1][address(arg2)].field_0:
        if userInfo[arg1][address(arg2)].field_256 > 0:
            revert with 0, 'SafeMath: subtraction overflow'
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 128
            mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
            mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                   0,
                   128,
                   0,
                   ext_call.return_data[0],
                   mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
        require arg1 < poolInfo.length
        mem[0] = 19
        if not poolInfo[arg1].field_1024:
            mem[ceil32(return_data.size) + 100] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 96] = -userInfo[arg1][address(arg2)].field_256 / 2
            mem[(2 * ceil32(return_data.size)) + 128] = 0
            mem[(2 * ceil32(return_data.size)) + 160] = 128
            mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
            if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
                mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                   0,
                   128,
                   ext_call.return_data[0],
                   ext_call.return_data[0],
                   mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.rewardToken() with:
                gas gas_remaining wei
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        mem[(4 * ceil32(return_data.size)) + 96] = 4
        mem[64] = (4 * ceil32(return_data.size)) + 132
        mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
        mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
        mem[(4 * ceil32(return_data.size)) + 136] = 0
        staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
                gas gas_remaining wei
        if not return_data.size:
            if not ext_call.success:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            if ext_call.return_data[0] < 64:
                if ext_call.return_data[0] != 32:
                    require ext_code.size(poolInfo[arg1].field_1024)
                    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                            gas gas_remaining wei
                           args arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                           address(ext_call.return_data[0]),
                           128,
                           ext_call.return_data[0],
                           3,
                           '???',
                           0
                require 0 < ext_call.return_data[0]
                require 0 < ext_call.return_data[0]
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       0,
                       None
            require ext_call.return_data[0] >= 32
            _11229 = 0, mem[132 len 28]
            require 0, mem[132 len 28] <= test266151307()
            require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
            _11799 = mem[0, mem[132 len 28] + 128]
            require mem[0, mem[132 len 28] + 128] <= test266151307()
            require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
            mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
            mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
            require _11229 + _11799 + 160 <= ext_call.return_data[0] + 128
            mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11799)] = mem[_11229 + 160 len ceil32(_11799)]
            if ceil32(_11799) <= _11799:
                mem[mem[64] + 4] = arg2
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args address(arg2)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _22999 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _23351 = mem[_22999]
                require mem[_22999] == mem[_22999]
                mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
                mem[mem[64] + 32] = address(ext_call.return_data[0])
                mem[mem[64] + 64] = 128
                _24055 = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
                mem[mem[64] + 160 len ceil32(_24055)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24055)]
                if ceil32(_24055) > _24055:
                    mem[mem[64] + _24055 + 160] = 0
                mem[mem[64] + 96] = _23351
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       _23351,
                       mem[mem[64] + 128 len ceil32(_24055) + 32]
            mem[(4 * ceil32(return_data.size)) + _11799 + 164] = 0
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23175 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23527 = mem[_23175]
            require mem[_23175] == mem[_23175]
            mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            _24231 = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 160 len ceil32(_24231)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24231)]
            if ceil32(_24231) > _24231:
                mem[mem[64] + _24231 + 160] = 0
            mem[mem[64] + 96] = _23527
            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   _23527,
                   mem[mem[64] + 128 len ceil32(_24231) + 32]
        mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
        mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   ext_call.return_data[0],
                   3,
                   '???',
                   0
        if return_data.size < 64:
            if 32 != return_data.size:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            require 0 < return_data.size
            require 0 < return_data.size
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = -userInfo[arg1][address(arg2)].field_256 / 2
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
            if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
                mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
                   ext_call.return_data[0]
        require return_data.size >= 32
        _11231 = mem[(4 * ceil32(return_data.size)) + 164]
        require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
        _11800 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
        require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
        mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
        require _11231 + _11800 + 64 <= return_data.size + 32
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11800)] = mem[(4 * ceil32(return_data.size)) + _11231 + 196 len ceil32(_11800)]
        if ceil32(_11800) <= _11800:
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _23000 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23352 = mem[_23000]
            require mem[_23000] == mem[_23000]
            mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            mem[mem[64] + 128] = _11800
            mem[mem[64] + 160 len ceil32(_11800)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11800)]
            if ceil32(_11800) > _11800:
                mem[mem[64] + _11800 + 160] = 0
            mem[mem[64] + 96] = _23352
            return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   Array(len=_11800, data=mem[mem[64] + 160 len ceil32(_11800)]),
                   _23352
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11800 + 165] = 0
        mem[mem[64] + 4] = arg2
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _23176 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _23528 = mem[_23176]
        require mem[_23176] == mem[_23176]
        mem[mem[64]] = -userInfo[arg1][address(arg2)].field_256 / 2
        mem[mem[64] + 32] = address(ext_call.return_data[0])
        mem[mem[64] + 64] = 128
        mem[mem[64] + 128] = _11800
        mem[mem[64] + 160 len ceil32(_11800)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11800)]
        if ceil32(_11800) > _11800:
            mem[mem[64] + _11800 + 160] = 0
        mem[mem[64] + 96] = _23528
        return Mask(255, 1, -userInfo[arg1][address(arg2)].field_256), 
               address(ext_call.return_data[0]),
               Array(len=_11800, data=mem[mem[64] + 160 len ceil32(_11800)]),
               _23528
    require userInfo[arg1][address(arg2)].field_0
    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0]):
        revert with 0, 'SafeMath: multiplication overflow'
    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
        revert with 0, 'SafeMath: subtraction overflow'
    if not poolInfo[arg1].field_1024:
        mem[ceil32(return_data.size) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
        mem[ceil32(return_data.size) + 128] = 0
        mem[ceil32(return_data.size) + 160] = 128
        mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
        mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
        if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
            mem[ceil32(return_data.size) + ext_call.return_data[0] + 256] = 0
        return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
               0,
               128,
               0,
               ext_call.return_data[0],
               mem[ceil32(return_data.size) + 256 len ceil32(ext_call.return_data[0])]
    require arg1 < poolInfo.length
    mem[0] = 19
    if not poolInfo[arg1].field_1024:
        mem[ceil32(return_data.size) + 100] = arg2
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                gas gas_remaining wei
               args arg2
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[(2 * ceil32(return_data.size)) + 96] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
        mem[(2 * ceil32(return_data.size)) + 128] = 0
        mem[(2 * ceil32(return_data.size)) + 160] = 128
        mem[(2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
        mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])] = mem[128 len ceil32(ext_call.return_data[0])]
        if ceil32(ext_call.return_data[0]) > ext_call.return_data[0]:
            mem[(2 * ceil32(return_data.size)) + ext_call.return_data[0] + 256] = 0
        return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
               0,
               128,
               ext_call.return_data[0],
               ext_call.return_data[0],
               mem[(2 * ceil32(return_data.size)) + 256 len ceil32(ext_call.return_data[0])]
    require ext_code.size(poolInfo[arg1].field_1024)
    staticcall poolInfo[arg1].field_1024.rewardToken() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(poolInfo[arg1].field_1024)
    staticcall poolInfo[arg1].field_1024.rewardToken() with:
            gas gas_remaining wei
    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[(4 * ceil32(return_data.size)) + 96] = 4
    mem[64] = (4 * ceil32(return_data.size)) + 132
    mem[(4 * ceil32(return_data.size)) + 128 len 4] = unknown_0x95d89b41(?????)
    mem[(4 * ceil32(return_data.size)) + 132] = 0, mem[(4 * ceil32(return_data.size)) + 132 len 28]
    mem[(4 * ceil32(return_data.size)) + 136] = 0
    staticcall address(ext_call.return_data[0]).mem[(4 * ceil32(return_data.size)) + 132 len 4] with:
            gas gas_remaining wei
    if not return_data.size:
        if not ext_call.success:
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   ext_call.return_data[0],
                   3,
                   '???',
                   0
        if ext_call.return_data[0] < 64:
            if ext_call.return_data[0] != 32:
                require ext_code.size(poolInfo[arg1].field_1024)
                staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                        gas gas_remaining wei
                       args arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[0]
                return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                       address(ext_call.return_data[0]),
                       128,
                       ext_call.return_data[0],
                       3,
                       '???',
                       0
            require 0 < ext_call.return_data[0]
            require 0 < ext_call.return_data[0]
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   ext_call.return_data[0],
                   0,
                   None
        require ext_call.return_data[0] >= 32
        _11223 = 0, mem[132 len 28]
        require 0, mem[132 len 28] <= test266151307()
        require 0, mem[132 len 28] + 159 < ext_call.return_data[0] + 128
        _11797 = mem[0, mem[132 len 28] + 128]
        require mem[0, mem[132 len 28] + 128] <= test266151307()
        require (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164 <= test266151307() and ceil32(mem[0, mem[132 len 28] + 128]) + 164 >= 132
        mem[64] = (4 * ceil32(return_data.size)) + ceil32(mem[0, mem[132 len 28] + 128]) + 164
        mem[(4 * ceil32(return_data.size)) + 132] = mem[0, mem[132 len 28] + 128]
        require _11223 + _11797 + 160 <= ext_call.return_data[0] + 128
        mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_11797)] = mem[_11223 + 160 len ceil32(_11797)]
        if ceil32(_11797) <= _11797:
            mem[mem[64] + 4] = arg2
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args address(arg2)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _22995 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _23347 = mem[_22995]
            require mem[_22995] == mem[_22995]
            mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
            mem[mem[64] + 32] = address(ext_call.return_data[0])
            mem[mem[64] + 64] = 128
            _24051 = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
            mem[mem[64] + 160 len ceil32(_24051)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24051)]
            if ceil32(_24051) > _24051:
                mem[mem[64] + _24051 + 160] = 0
            mem[mem[64] + 96] = _23347
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   _23347,
                   mem[mem[64] + 128 len ceil32(_24051) + 32]
        mem[(4 * ceil32(return_data.size)) + _11797 + 164] = 0
        mem[mem[64] + 4] = arg2
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _23171 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _23523 = mem[_23171]
        require mem[_23171] == mem[_23171]
        mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
        mem[mem[64] + 32] = address(ext_call.return_data[0])
        mem[mem[64] + 64] = 128
        _24227 = mem[(4 * ceil32(return_data.size)) + 132]
        mem[mem[64] + 128] = mem[(4 * ceil32(return_data.size)) + 132]
        mem[mem[64] + 160 len ceil32(_24227)] = mem[(4 * ceil32(return_data.size)) + 164 len ceil32(_24227)]
        if ceil32(_24227) > _24227:
            mem[mem[64] + _24227 + 160] = 0
        mem[mem[64] + 96] = _23523
        return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
               address(ext_call.return_data[0]),
               128,
               _23523,
               mem[mem[64] + 128 len ceil32(_24227) + 32]
    mem[(4 * ceil32(return_data.size)) + 132] = return_data.size
    mem[(4 * ceil32(return_data.size)) + 164 len return_data.size] = ext_call.return_data[0 len return_data.size]
    if not ext_call.success:
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                gas gas_remaining wei
               args arg2
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
               address(ext_call.return_data[0]),
               128,
               ext_call.return_data[0],
               3,
               '???',
               0
    if return_data.size < 64:
        if 32 != return_data.size:
            require ext_code.size(poolInfo[arg1].field_1024)
            staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                    gas gas_remaining wei
                   args arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
                   address(ext_call.return_data[0]),
                   128,
                   ext_call.return_data[0],
                   3,
                   '???',
                   0
        require 0 < return_data.size
        require 0 < return_data.size
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 169] = arg2
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                gas gas_remaining wei
               args arg2
        mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 165] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 197] = address(ext_call.return_data[0])
        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 229] = 128
        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 293] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]
        mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]
        if ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]) > mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133]:
            mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] + 325] = 0
        return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
               address(ext_call.return_data[0]),
               Array(len=mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133], data=mem[(6 * ceil32(return_data.size)) + ceil32(return_data.size) + 325 len ceil32(mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133])]),
               ext_call.return_data[0]
    require return_data.size >= 32
    _11225 = mem[(4 * ceil32(return_data.size)) + 164]
    require mem[(4 * ceil32(return_data.size)) + 164] <= test266151307()
    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 195 < (4 * ceil32(return_data.size)) + return_data.size + 164
    _11798 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
    require mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164] <= test266151307()
    require (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 <= test266151307() and ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165 >= 133
    mem[64] = (4 * ceil32(return_data.size)) + ceil32(return_data.size) + ceil32(mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]) + 165
    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 133] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 164] + 164]
    require _11225 + _11798 + 64 <= return_data.size + 32
    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11798)] = mem[(4 * ceil32(return_data.size)) + _11225 + 196 len ceil32(_11798)]
    if ceil32(_11798) <= _11798:
        mem[mem[64] + 4] = arg2
        require ext_code.size(poolInfo[arg1].field_1024)
        staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
                gas gas_remaining wei
               args address(arg2)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _22996 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _23348 = mem[_22996]
        require mem[_22996] == mem[_22996]
        mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
        mem[mem[64] + 32] = address(ext_call.return_data[0])
        mem[mem[64] + 64] = 128
        mem[mem[64] + 128] = _11798
        mem[mem[64] + 160 len ceil32(_11798)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11798)]
        if ceil32(_11798) > _11798:
            mem[mem[64] + _11798 + 160] = 0
        mem[mem[64] + 96] = _23348
        return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
               address(ext_call.return_data[0]),
               Array(len=_11798, data=mem[mem[64] + 160 len ceil32(_11798)]),
               _23348
    mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + _11798 + 165] = 0
    mem[mem[64] + 4] = arg2
    require ext_code.size(poolInfo[arg1].field_1024)
    staticcall poolInfo[arg1].field_1024.pendingTokens(address arg1) with:
            gas gas_remaining wei
           args address(arg2)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _23172 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _23524 = mem[_23172]
    require mem[_23172] == mem[_23172]
    mem[mem[64]] = ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2
    mem[mem[64] + 32] = address(ext_call.return_data[0])
    mem[mem[64] + 64] = 128
    mem[mem[64] + 128] = _11798
    mem[mem[64] + 160 len ceil32(_11798)] = mem[(4 * ceil32(return_data.size)) + ceil32(return_data.size) + 165 len ceil32(_11798)]
    if ceil32(_11798) > _11798:
        mem[mem[64] + _11798 + 160] = 0
    mem[mem[64] + 96] = _23524
    return Mask(255, 1, ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (1000 * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (devPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (treasuryPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) - (investorPercent * (block.timestamp * sub_4a7d91a1 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_4a7d91a1 * poolInfo[arg1].field_256) / totalAllocPoint) / 1000 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256), 
           address(ext_call.return_data[0]),
           Array(len=_11798, data=mem[mem[64] + 160 len ceil32(_11798)]),
           _23524
}



}

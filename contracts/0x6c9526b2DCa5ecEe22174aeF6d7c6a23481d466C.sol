contract main {




// =====================  Runtime code  =====================


#
#  - claim(uint256 arg1)
#  - safeTransferFrom(address arg1, address arg2, uint256 arg3)
#  - nftListByOffset(uint256 arg1, uint256 arg2)
#  - safeMint()
#  - stakeListOffset(uint256 arg1, uint256 arg2)
#  - initialize()
#  - stake(uint256 arg1)
#  - stakeListByIds(uint256[] arg1)
#  - cancelStake(uint256 arg1)
#  - _fallback()
#
array of uint256 stor1;
array of struct stor101;
array of struct stor102;
mapping of address ownerOf;
mapping of uint256 balanceOf;
mapping of address approved;
mapping of uint8 stor106;
mapping of uint256 tokenOfOwnerByIndex;
mapping of uint256 stor152;
array of uint256 tokenByIndex;
mapping of uint256 stor154;
mapping of struct stor201;
address owner;
uint256 stor301;
mapping of struct stor302;
mapping of struct stor303;
mapping of uint256 stakeListLength;
address _pollenTokenAddress;
address sub_ca57e73bAddress;
uint256 stor313;
uint256 stor314;
uint256 stor315;
uint256 stor316;
uint256 stor317;
uint8 stor318;
uint256 stor318; offset 8
mapping of uint8 stor320;
uint8 paused;
array of uint256 stor51848699043762354786445001410105671568266765734117956169291548475795829136640;

function getApproved(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
    return approved[arg1]
}

function totalSupply() {
    return tokenByIndex.length
}

function tokenOfOwnerByIndex(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    if arg2 >= balanceOf[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Enumerable: owner index out of bounds'
    return tokenOfOwnerByIndex[address(arg1)][arg2]
}

function stakeListLength() {
    return stakeListLength[msg.sender]
}

function tokenByIndex(uint256 arg1) {
    require calldata.size - 4 >= 32
    if arg1 >= tokenByIndex.length:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Enumerable: global index out of bounds'
    return tokenByIndex[arg1]
}

function paused() {
    return bool(paused)
}

function ownerOf(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    return ownerOf[arg1]
}

function balanceOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    return balanceOf[address(arg1)]
}

function owner() {
    return owner
}

function nftListLength() {
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    return balanceOf[address(msg.sender)]
}

function _pollenToken() {
    return _pollenTokenAddress
}

function sub_ca57e73b(?) {
    return sub_ca57e73bAddress
}

function adminMap(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor320[arg1])
}

function isApprovedForAll(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return bool(stor106[address(arg1)][address(arg2)])
}

function _analysisInfo() {
    return stor313, stor314, stor315, stor316, stor317
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function updatePaused(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not stor320[msg.sender]:
        if owner != msg.sender:
            revert with 0, 'caller is not admin'
    paused = uint8(arg1)
}

function sub_1eaddaac(?) {
    require calldata.size - 4 >= 32
    require arg1 == bool(arg1)
    if not stor320[msg.sender]:
        if owner != msg.sender:
            revert with 0, 'caller is not admin'
    uint8(stor318.field_0) = uint8(bool(arg1))
}

function sub_2c40a15d(?) {
    require calldata.size - 4 >= 32
    require arg1 == bool(arg1)
    if not stor320[msg.sender]:
        if owner != msg.sender:
            revert with 0, 'caller is not admin'
    Mask(248, 0, stor318.field_8) = Mask(248, 0, bool(arg1))
}

function updateAdmin(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if not stor320[msg.sender]:
        if owner != msg.sender:
            revert with 0, 'caller is not admin'
    stor320[address(arg1)] = uint8(arg2)
}

function updatePollenToken(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not stor320[msg.sender]:
        if owner != msg.sender:
            revert with 0, 'caller is not admin'
    if _pollenTokenAddress == arg1:
        revert with 0, 'token is same'
    _pollenTokenAddress = arg1
}

function setApprovalForAll(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if msg.sender == arg1:
        revert with 0, 'ERC721: approve to caller'
    stor106[address(msg.sender)][address(arg1)] = uint8(arg2)
    emit ApprovalForAll(arg2, msg.sender, arg1);
}

function sub_a223dbba(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if not stor320[msg.sender]:
        if owner != msg.sender:
            revert with 0, 'caller is not admin'
    if sub_ca57e73bAddress == address(arg1):
        revert with 0, 'ClaimSwap is same'
    sub_ca57e73bAddress = address(arg1)
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    return 0x150b7a0200000000000000000000000000000000000000000000000000000000
}

function supportsInterface(bytes4 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == Mask(32, 224, arg1)
    if 0x780e9d6300000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if 0x80ac58cd00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if 0x5b5e139f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    return (Mask(32, 224, arg1) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if arg1 == ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approval to current owner'
    if ownerOf[arg2] != msg.sender:
        if not stor106[stor103[arg2]][address(msg.sender)]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        'ERC721: approve caller is not owner nor approved for all'
    approved[arg2] = arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg2], arg1, arg2);
}

function transferFrom(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor106[stor103[arg3]][address(msg.sender)]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer of token that is not own'
    if not arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer to the zero address'
    if paused:
        if not stor320[msg.sender]:
            if owner != msg.sender:
                revert with 0, 'paused'
    if not arg1:
        stor154[arg3] = tokenByIndex.length
        tokenByIndex.length++
        stor72A1[stor153.length] = arg3
    else:
        if arg1 != arg2:
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
            if balanceOf[address(arg1)] < 1:
                revert with 0, 17
            if balanceOf[address(arg1)] - 1 != stor152[arg3]:
                tokenOfOwnerByIndex[address(arg1)][stor152[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor104[address(arg1)] - 1]
                stor152[stor151[address(arg1)][stor104[address(arg1)] - 1]] = stor152[arg3]
            stor152[arg3] = 0
            tokenOfOwnerByIndex[address(arg1)][stor104[address(arg1)] - 1] = 0
    if arg2:
        if arg2 != arg1:
            if not arg2:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
            tokenOfOwnerByIndex[address(arg2)][stor104[address(arg2)]] = arg3
            stor152[arg3] = balanceOf[address(arg2)]
    else:
        if tokenByIndex.length < 1:
            revert with 0, 17
        if tokenByIndex.length - 1 >= tokenByIndex.length:
            revert with 0, 50
        if stor154[arg3] >= tokenByIndex.length:
            revert with 0, 50
        tokenByIndex[stor154[arg3]] = tokenByIndex[tokenByIndex.length]
        stor154[stor153[stor153.length]] = stor154[arg3]
        stor154[arg3] = 0
        if not tokenByIndex.length:
            revert with 0, 49
        tokenByIndex[tokenByIndex.length] = 0
        tokenByIndex.length--
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
}

function safeMint(address arg1, string arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 <= test266151307()
    require calldata.size > arg2 + 35
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg2.length)) + 97 < 96 or ceil32(ceil32(arg2.length)) + 97 > test266151307():
        revert with 0, 65
    require arg2 + arg2.length + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor301++
    if not arg1:
        revert with 0, 'ERC721: mint to the zero address'
    if ownerOf[stor301]:
        revert with 0, 'ERC721: token already minted'
    if paused:
        if not stor320[msg.sender]:
            if owner != msg.sender:
                revert with 0, 'paused'
    stor154[stor301] = tokenByIndex.length
    tokenByIndex.length++
    stor72A1[stor153.length] = stor301
    if arg1:
        if arg1:
            if not arg1:
                revert with 0, 'ERC721: balance query for the zero address'
            tokenOfOwnerByIndex[address(arg1)][stor104[address(arg1)]] = stor301
            stor152[stor301] = balanceOf[address(arg1)]
    else:
        if tokenByIndex.length < 1:
            revert with 0, 17
        if tokenByIndex.length - 1 >= tokenByIndex.length:
            revert with 0, 50
        if stor154[stor301] >= tokenByIndex.length:
            revert with 0, 50
        tokenByIndex[stor154[stor301]] = tokenByIndex[tokenByIndex.length]
        stor154[stor153[stor153.length]] = stor154[stor301]
        stor154[stor301] = 0
        if not tokenByIndex.length:
            revert with 0, 49
        tokenByIndex[tokenByIndex.length] = 0
        tokenByIndex.length--
    if balanceOf[address(arg1)] > -2:
        revert with 0, 17
    balanceOf[address(arg1)]++
    ownerOf[stor301] = arg1
    emit Transfer(0, arg1, stor301);
    if ext_code.size(arg1):
        call arg1.0x150b7a02 with:
             gas gas_remaining wei
            args msg.sender, 0, stor301, 128, 0
        if not ext_call.success:
            if not return_data.size:
                if not arg2.length:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                revert with arg2[all]
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
    if not ownerOf[stor301]:
        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
    if stor201[stor301].field_0:
        if stor201[stor301].field_0 == uint255(stor201[stor301].field_0) * 0.5 < 32:
            revert with 0, 34
        if arg2.length:
            stor201[stor301][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            stor201[stor301].field_0 = 0
            idx = 0
            while (uint255(stor201[stor301].field_0) * 0.5) + 31 / 32 > idx:
                stor201[stor301][idx].field_0 = 0
                idx = idx + 1
                continue 
    else:
        if stor201[stor301].field_0 == stor201[stor301].field_1 < 32:
            revert with 0, 34
        if arg2.length:
            stor201[stor301][].field_0 = Array(len=arg2.length, data=arg2[all])
        else:
            stor201[stor301].field_0 = 0
            idx = 0
            while stor201[stor301].field_1 + 31 / 32 > idx:
                stor201[stor301][idx].field_0 = 0
                idx = idx + 1
                continue 
}

function stakeDetails(uint256 arg1) {
    require calldata.size - 4 >= 32
    if stor303[arg1].field_1792:
        if stor303[arg1].field_1792 == uint255(stor303[arg1].field_1792) * 0.5 < 32:
            revert with 0, 34
        if stor303[arg1].field_1792:
            if stor303[arg1].field_1792 == uint255(stor303[arg1].field_1792) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor303[arg1].field_1792):
                if 31 >= uint255(stor303[arg1].field_1792) * 0.5:
                    mem[704] = 256 * stor303[arg1].field_1800
                else:
                    mem[704] = stor303[arg1][7].field_0
                    idx = 704
                    s = 0
                    while (uint255(stor303[arg1].field_1792) * 0.5) + 672 > idx:
                        mem[idx + 32] = stor303[arg1][s + 7].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if stor303[arg1].field_1792 == stor303[arg1].field_1793 < 32:
                revert with 0, 34
            if stor303[arg1].field_1793:
                if 31 >= stor303[arg1].field_1793:
                    mem[704] = 256 * stor303[arg1].field_1800
                else:
                    mem[704] = stor303[arg1][7].field_0
                    idx = 704
                    s = 0
                    while stor303[arg1].field_1793 + 672 > idx:
                        mem[idx + 32] = stor303[arg1][s + 7].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
        return 32, stor303[arg1].field_0, 
               stor303[arg1].field_256,
               stor303[arg1].field_512,
               stor303[arg1].field_768,
               stor303[arg1].field_1024,
               stor303[arg1].field_1280,
               stor303[arg1].field_1536,
               288,
               stor303[arg1].field_2048,
               2 * Mask(256, -1, stor303[arg1].field_1792),
               mem[704 len ceil32(uint255(stor303[arg1].field_1792) * 0.5)]
    if stor303[arg1].field_1792 == stor303[arg1].field_1793 < 32:
        revert with 0, 34
    if stor303[arg1].field_1792:
        if stor303[arg1].field_1792 == uint255(stor303[arg1].field_1792) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor303[arg1].field_1792):
            if 31 >= uint255(stor303[arg1].field_1792) * 0.5:
                mem[704] = 256 * stor303[arg1].field_1800
            else:
                mem[704] = stor303[arg1][7].field_0
                idx = 704
                s = 0
                while (uint255(stor303[arg1].field_1792) * 0.5) + 672 > idx:
                    mem[idx + 32] = stor303[arg1][s + 7].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
    else:
        if stor303[arg1].field_1792 == stor303[arg1].field_1793 < 32:
            revert with 0, 34
        if stor303[arg1].field_1793:
            if 31 >= stor303[arg1].field_1793:
                mem[704] = 256 * stor303[arg1].field_1800
            else:
                mem[704] = stor303[arg1][7].field_0
                idx = 704
                s = 0
                while stor303[arg1].field_1793 + 672 > idx:
                    mem[idx + 32] = stor303[arg1][s + 7].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
    return 32, stor303[arg1].field_0, 
           stor303[arg1].field_256,
           stor303[arg1].field_512,
           stor303[arg1].field_768,
           stor303[arg1].field_1024,
           stor303[arg1].field_1280,
           stor303[arg1].field_1536,
           288,
           stor303[arg1].field_2048,
           stor303[arg1].field_1792,
           mem[704 len ceil32(stor303[arg1].field_1793)]
}

function name() {
    if bool(stor101.length):
        if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor101.length):
            if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor101.length):
                if 31 < uint255(stor101.length) * 0.5:
                    mem[128] = uint256(stor101.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor101.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor101[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)])
                mem[128] = 256 * stor101.length.field_8
        else:
            if bool(stor101.length) == stor101.length.field_1 < 32:
                revert with 0, 34
            if stor101.length.field_1:
                if 31 < stor101.length.field_1:
                    mem[128] = uint256(stor101.field_0)
                    idx = 128
                    s = 0
                    while stor101.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor101[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)])
                mem[128] = 256 * stor101.length.field_8
        mem[ceil32(uint255(stor101.length) * 0.5) + 192 len ceil32(uint255(stor101.length) * 0.5)] = mem[128 len ceil32(uint255(stor101.length) * 0.5)]
        if ceil32(uint255(stor101.length) * 0.5) > uint255(stor101.length) * 0.5:
            mem[(uint255(stor101.length) * 0.5) + ceil32(uint255(stor101.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor101.length), data=mem[128 len ceil32(uint255(stor101.length) * 0.5)], mem[(2 * ceil32(uint255(stor101.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor101.length) * 0.5)]), 
    if bool(stor101.length) == stor101.length.field_1 < 32:
        revert with 0, 34
    if bool(stor101.length):
        if bool(stor101.length) == uint255(stor101.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor101.length):
            if 31 < uint255(stor101.length) * 0.5:
                mem[128] = uint256(stor101.field_0)
                idx = 128
                s = 0
                while (uint255(stor101.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor101[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1)])
            mem[128] = 256 * stor101.length.field_8
    else:
        if bool(stor101.length) == stor101.length.field_1 < 32:
            revert with 0, 34
        if stor101.length.field_1:
            if 31 < stor101.length.field_1:
                mem[128] = uint256(stor101.field_0)
                idx = 128
                s = 0
                while stor101.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor101[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1)])
            mem[128] = 256 * stor101.length.field_8
    mem[ceil32(stor101.length.field_1) + 192 len ceil32(stor101.length.field_1)] = mem[128 len ceil32(stor101.length.field_1)]
    if ceil32(stor101.length.field_1) > stor101.length.field_1:
        mem[stor101.length.field_1 + ceil32(stor101.length.field_1) + 192] = 0
    return Array(len=stor101.length % 128, data=mem[128 len ceil32(stor101.length.field_1)], mem[(2 * ceil32(stor101.length.field_1)) + 192 len 2 * ceil32(stor101.length.field_1)]), 
}

function symbol() {
    if bool(stor102.length):
        if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor102.length):
            if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor102.length):
                if 31 < uint255(stor102.length) * 0.5:
                    mem[128] = uint256(stor102.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor102.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor102[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)])
                mem[128] = 256 * stor102.length.field_8
        else:
            if bool(stor102.length) == stor102.length.field_1 < 32:
                revert with 0, 34
            if stor102.length.field_1:
                if 31 < stor102.length.field_1:
                    mem[128] = uint256(stor102.field_0)
                    idx = 128
                    s = 0
                    while stor102.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor102[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)])
                mem[128] = 256 * stor102.length.field_8
        mem[ceil32(uint255(stor102.length) * 0.5) + 192 len ceil32(uint255(stor102.length) * 0.5)] = mem[128 len ceil32(uint255(stor102.length) * 0.5)]
        if ceil32(uint255(stor102.length) * 0.5) > uint255(stor102.length) * 0.5:
            mem[(uint255(stor102.length) * 0.5) + ceil32(uint255(stor102.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor102.length), data=mem[128 len ceil32(uint255(stor102.length) * 0.5)], mem[(2 * ceil32(uint255(stor102.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor102.length) * 0.5)]), 
    if bool(stor102.length) == stor102.length.field_1 < 32:
        revert with 0, 34
    if bool(stor102.length):
        if bool(stor102.length) == uint255(stor102.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor102.length):
            if 31 < uint255(stor102.length) * 0.5:
                mem[128] = uint256(stor102.field_0)
                idx = 128
                s = 0
                while (uint255(stor102.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor102[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1)])
            mem[128] = 256 * stor102.length.field_8
    else:
        if bool(stor102.length) == stor102.length.field_1 < 32:
            revert with 0, 34
        if stor102.length.field_1:
            if 31 < stor102.length.field_1:
                mem[128] = uint256(stor102.field_0)
                idx = 128
                s = 0
                while stor102.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor102[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1)])
            mem[128] = 256 * stor102.length.field_8
    mem[ceil32(stor102.length.field_1) + 192 len ceil32(stor102.length.field_1)] = mem[128 len ceil32(stor102.length.field_1)]
    if ceil32(stor102.length.field_1) > stor102.length.field_1:
        mem[stor102.length.field_1 + ceil32(stor102.length.field_1) + 192] = 0
    return Array(len=stor102.length % 128, data=mem[128 len ceil32(stor102.length.field_1)], mem[(2 * ceil32(stor102.length.field_1)) + 192 len 2 * ceil32(stor102.length.field_1)]), 
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg4 <= test266151307()
    require calldata.size > arg4 + 35
    if arg4.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg4.length)) + 97 < 96 or ceil32(ceil32(arg4.length)) + 97 > test266151307():
        revert with 0, 65
    require arg4 + arg4.length + 36 <= calldata.size
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor106[stor103[arg3]][address(msg.sender)]:
                revert with 0, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0, 'ERC721: transfer of token that is not own'
    if not arg2:
        revert with 0, 'ERC721: transfer to the zero address'
    if paused:
        if not stor320[msg.sender]:
            if owner != msg.sender:
                revert with 0, 'paused'
    if not arg1:
        stor154[arg3] = tokenByIndex.length
        tokenByIndex.length++
        stor72A1[stor153.length] = arg3
    else:
        if arg1 != arg2:
            if not arg1:
                revert with 0, 'ERC721: balance query for the zero address'
            if balanceOf[address(arg1)] < 1:
                revert with 0, 17
            if balanceOf[address(arg1)] - 1 != stor152[arg3]:
                tokenOfOwnerByIndex[address(arg1)][stor152[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor104[address(arg1)] - 1]
                stor152[stor151[address(arg1)][stor104[address(arg1)] - 1]] = stor152[arg3]
            stor152[arg3] = 0
            tokenOfOwnerByIndex[address(arg1)][stor104[address(arg1)] - 1] = 0
    if arg2:
        if arg2 != arg1:
            if not arg2:
                revert with 0, 'ERC721: balance query for the zero address'
            tokenOfOwnerByIndex[address(arg2)][stor104[address(arg2)]] = arg3
            stor152[arg3] = balanceOf[address(arg2)]
    else:
        if tokenByIndex.length < 1:
            revert with 0, 17
        if tokenByIndex.length - 1 >= tokenByIndex.length:
            revert with 0, 50
        if stor154[arg3] >= tokenByIndex.length:
            revert with 0, 50
        tokenByIndex[stor154[arg3]] = tokenByIndex[tokenByIndex.length]
        stor154[stor153[stor153.length]] = stor154[arg3]
        stor154[arg3] = 0
        if not tokenByIndex.length:
            revert with 0, 49
        tokenByIndex[tokenByIndex.length] = 0
        tokenByIndex.length--
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
    if ext_code.size(arg2):
        call arg2.0x150b7a02 with:
             gas gas_remaining wei
            args msg.sender, address(arg1), arg3, Array(len=arg4.length, data=arg4[all])
        if not ext_call.success:
            if not return_data.size:
                if not arg4.length:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                revert with arg4[all]
            if not return_data.size:
                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
        if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
}

function tokenURI(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721URIStorage: URI query for nonexistent token'
    if stor201[arg1].field_0:
        if stor201[arg1].field_0 == uint255(stor201[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if stor201[arg1].field_0:
            if stor201[arg1].field_0 == uint255(stor201[arg1].field_0) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor201[arg1].field_0):
                if 31 >= uint255(stor201[arg1].field_0) * 0.5:
                    mem[128] = 256 * stor201[arg1].field_8
                else:
                    mem[128] = stor201[arg1].field_0
                    idx = 128
                    s = 0
                    while (uint255(stor201[arg1].field_0) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor201[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if stor201[arg1].field_0 == stor201[arg1].field_1 < 32:
                revert with 0, 34
            if stor201[arg1].field_1:
                if 31 >= stor201[arg1].field_1:
                    mem[128] = 256 * stor201[arg1].field_8
                else:
                    mem[128] = stor201[arg1].field_0
                    idx = 128
                    s = 0
                    while stor201[arg1].field_1 + 96 > idx:
                        mem[idx + 32] = stor201[arg1][s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
        if Mask(256, -1, stor201[arg1].field_0):
            mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 224] = 'https://files.catbox.moe/' << 56
            mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 249] = 0
            mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 249 len ceil32(uint255(stor201[arg1].field_0) * 0.5)] = mem[128 len ceil32(uint255(stor201[arg1].field_0) * 0.5)]
            mem[(uint255(stor201[arg1].field_0) * 0.5) + ceil32(uint255(stor201[arg1].field_0) * 0.5) + 249] = 32
            mem[(uint255(stor201[arg1].field_0) * 0.5) + ceil32(uint255(stor201[arg1].field_0) * 0.5) + 281] = mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 192]
            mem[(uint255(stor201[arg1].field_0) * 0.5) + ceil32(uint255(stor201[arg1].field_0) * 0.5) + 313 len ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 192])] = mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 192])]
            if ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 192]) <= mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 192]:
                return Array(len=mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 192], data=mem[(uint255(stor201[arg1].field_0) * 0.5) + ceil32(uint255(stor201[arg1].field_0) * 0.5) + 313 len ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 192])]), 
            mem[mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 192] + (uint255(stor201[arg1].field_0) * 0.5) + ceil32(uint255(stor201[arg1].field_0) * 0.5) + 313] = 0
            return 32, mem[(uint255(stor201[arg1].field_0) * 0.5) + ceil32(uint255(stor201[arg1].field_0) * 0.5) + 281 len ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 192]) + 32], 
        if not ownerOf[arg1]:
            revert with 0, 'ERC721Metadata: URI query for nonexistent token'
        if not arg1:
            mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 352] = 'https://files.catbox.moe/' << 56
            mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 377] = 0x3000000000000000000000000000000000000000000000000000000000000000
            mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 378] = 32
            mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 410] = mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 320]
            mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 442 len ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 320])] = mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 352 len ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 320])]
            if ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 320]) > mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 320]:
                mem[mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 320] + ceil32(uint255(stor201[arg1].field_0) * 0.5) + 442] = 0
            return Array(len=mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 320], data=mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 442 len ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 320])]), 
        s = 0
        idx = arg1
        while idx:
            if s == -1:
                revert with 0, 17
            s = s + 1
            idx = idx / 10
            continue 
        if s > test266151307():
            revert with 0, 65
        mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 256] = s
        if s:
            mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 288 len s] = call.data[calldata.size len s]
        t = s
        idx = arg1
        while idx:
            if t < 1:
                revert with 0, 17
            if 48 > !(idx % 10):
                revert with 0, 17
            if t - 1 >= mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 256]:
                revert with 0, 50
            mem[t + ceil32(uint255(stor201[arg1].field_0) * 0.5) + 287 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 320] = 'https://files.catbox.moe/' << 56
        mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 345] = 0
        mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 345 len ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 256])] = mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 288 len ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 256])]
        mem[mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 256] + ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 345] = 32
        mem[mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 256] + ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 377] = mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 288]
        mem[mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 256] + ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 409 len ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 288])] = mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 320 len ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 288])]
        if ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 288]) > mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 288]:
            mem[mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 288] + mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 256] + ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 409] = 0
        return Array(len=mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 288], data=mem[mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + 256] + ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 409 len ceil32(mem[ceil32(uint255(stor201[arg1].field_0) * 0.5) + ceil32(s) + 288])]), 
    if stor201[arg1].field_0 == stor201[arg1].field_1 < 32:
        revert with 0, 34
    mem[96] = stor201[arg1].field_1
    if stor201[arg1].field_0:
        if stor201[arg1].field_0 == uint255(stor201[arg1].field_0) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor201[arg1].field_0):
            if 31 >= uint255(stor201[arg1].field_0) * 0.5:
                mem[128] = 256 * stor201[arg1].field_8
            else:
                mem[128] = stor201[arg1].field_0
                idx = 128
                s = 0
                while (uint255(stor201[arg1].field_0) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor201[arg1][s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
    else:
        if stor201[arg1].field_0 == stor201[arg1].field_1 < 32:
            revert with 0, 34
        if stor201[arg1].field_1:
            if 31 >= stor201[arg1].field_1:
                mem[128] = 256 * stor201[arg1].field_8
            else:
                mem[128] = stor201[arg1].field_0
                idx = 128
                s = 0
                while stor201[arg1].field_1 + 96 > idx:
                    mem[idx + 32] = stor201[arg1][s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
    if stor201[arg1].field_1:
        mem[ceil32(stor201[arg1].field_1) + 224] = 'https://files.catbox.moe/' << 56
        mem[ceil32(stor201[arg1].field_1) + 249] = 0
        mem[ceil32(stor201[arg1].field_1) + 249 len ceil32(stor201[arg1].field_1)] = mem[128 len ceil32(stor201[arg1].field_1)]
        mem[stor201[arg1].field_1 + ceil32(stor201[arg1].field_1) + 249] = 32
        mem[stor201[arg1].field_1 + ceil32(stor201[arg1].field_1) + 281] = mem[ceil32(stor201[arg1].field_1) + 192]
        mem[stor201[arg1].field_1 + ceil32(stor201[arg1].field_1) + 313 len ceil32(mem[ceil32(stor201[arg1].field_1) + 192])] = mem[ceil32(stor201[arg1].field_1) + 224 len ceil32(mem[ceil32(stor201[arg1].field_1) + 192])]
        if ceil32(mem[ceil32(stor201[arg1].field_1) + 192]) <= mem[ceil32(stor201[arg1].field_1) + 192]:
            return Array(len=mem[ceil32(stor201[arg1].field_1) + 192], data=mem[stor201[arg1].field_1 + ceil32(stor201[arg1].field_1) + 313 len ceil32(mem[ceil32(stor201[arg1].field_1) + 192])]), 
        mem[mem[ceil32(stor201[arg1].field_1) + 192] + stor201[arg1].field_1 + ceil32(stor201[arg1].field_1) + 313] = 0
        return 32, mem[stor201[arg1].field_1 + ceil32(stor201[arg1].field_1) + 281 len ceil32(mem[ceil32(stor201[arg1].field_1) + 192]) + 32], 
    mem[0] = arg1
    mem[32] = 103
    if not ownerOf[arg1]:
        revert with 0, 'ERC721Metadata: URI query for nonexistent token'
    if not arg1:
        mem[ceil32(stor201[arg1].field_1) + 352] = 'https://files.catbox.moe/' << 56
        mem[ceil32(stor201[arg1].field_1) + 377] = 0x3000000000000000000000000000000000000000000000000000000000000000
        mem[ceil32(stor201[arg1].field_1) + 378] = 32
        mem[ceil32(stor201[arg1].field_1) + 410] = mem[ceil32(stor201[arg1].field_1) + 320]
        mem[ceil32(stor201[arg1].field_1) + 442 len ceil32(mem[ceil32(stor201[arg1].field_1) + 320])] = mem[ceil32(stor201[arg1].field_1) + 352 len ceil32(mem[ceil32(stor201[arg1].field_1) + 320])]
        if ceil32(mem[ceil32(stor201[arg1].field_1) + 320]) > mem[ceil32(stor201[arg1].field_1) + 320]:
            mem[mem[ceil32(stor201[arg1].field_1) + 320] + ceil32(stor201[arg1].field_1) + 442] = 0
        return Array(len=mem[ceil32(stor201[arg1].field_1) + 320], data=mem[ceil32(stor201[arg1].field_1) + 442 len ceil32(mem[ceil32(stor201[arg1].field_1) + 320])]), 
    s = 0
    idx = arg1
    while idx:
        if s == -1:
            revert with 0, 17
        s = s + 1
        idx = idx / 10
        continue 
    if s > test266151307():
        revert with 0, 65
    mem[ceil32(stor201[arg1].field_1) + 256] = s
    if s:
        mem[ceil32(stor201[arg1].field_1) + 288 len s] = call.data[calldata.size len s]
    t = s
    idx = arg1
    while idx:
        if t < 1:
            revert with 0, 17
        if 48 > !(idx % 10):
            revert with 0, 17
        if t - 1 >= mem[ceil32(stor201[arg1].field_1) + 256]:
            revert with 0, 50
        mem[t + ceil32(stor201[arg1].field_1) + 287 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
        t = t - 1
        idx = idx / 10
        continue 
    mem[ceil32(stor201[arg1].field_1) + ceil32(s) + 320] = 'https://files.catbox.moe/' << 56
    mem[ceil32(stor201[arg1].field_1) + ceil32(s) + 345] = 0
    mem[ceil32(stor201[arg1].field_1) + ceil32(s) + 345 len ceil32(mem[ceil32(stor201[arg1].field_1) + 256])] = mem[ceil32(stor201[arg1].field_1) + 288 len ceil32(mem[ceil32(stor201[arg1].field_1) + 256])]
    mem[64] = mem[ceil32(stor201[arg1].field_1) + 256] + ceil32(stor201[arg1].field_1) + ceil32(s) + 345
    mem[mem[ceil32(stor201[arg1].field_1) + 256] + ceil32(stor201[arg1].field_1) + ceil32(s) + 345] = 32
    mem[mem[ceil32(stor201[arg1].field_1) + 256] + ceil32(stor201[arg1].field_1) + ceil32(s) + 377] = mem[ceil32(stor201[arg1].field_1) + ceil32(s) + 288]
    mem[mem[ceil32(stor201[arg1].field_1) + 256] + ceil32(stor201[arg1].field_1) + ceil32(s) + 409 len ceil32(mem[ceil32(stor201[arg1].field_1) + ceil32(s) + 288])] = mem[ceil32(stor201[arg1].field_1) + ceil32(s) + 320 len ceil32(mem[ceil32(stor201[arg1].field_1) + ceil32(s) + 288])]
    if ceil32(mem[ceil32(stor201[arg1].field_1) + ceil32(s) + 288]) > mem[ceil32(stor201[arg1].field_1) + ceil32(s) + 288]:
        mem[mem[ceil32(stor201[arg1].field_1) + ceil32(s) + 288] + mem[ceil32(stor201[arg1].field_1) + 256] + ceil32(stor201[arg1].field_1) + ceil32(s) + 409] = 0
    return Array(len=mem[ceil32(stor201[arg1].field_1) + ceil32(s) + 288], data=mem[mem[ceil32(stor201[arg1].field_1) + 256] + ceil32(stor201[arg1].field_1) + ceil32(s) + 409 len ceil32(mem[ceil32(stor201[arg1].field_1) + ceil32(s) + 288])]), 
}

function nftDetails(uint256 arg1) {
    require calldata.size - 4 >= 32
    if stor302[arg1].field_512:
        if stor302[arg1].field_512 == uint255(stor302[arg1].field_512) * 0.5 < 32:
            revert with 0, 34
        if stor302[arg1].field_512:
            if stor302[arg1].field_512 == uint255(stor302[arg1].field_512) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, stor302[arg1].field_512):
                if stor302[arg1].field_768:
                    if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                        revert with 0, 34
                    if stor302[arg1].field_768:
                        if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor302[arg1].field_768):
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                            mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                        idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                        s = 0
                        while ceil32(uint255(stor302[arg1].field_512) * 0.5) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                            mem[idx + 32] = stor302[arg1][s + 3].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    else:
                        if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                            revert with 0, 34
                        if not stor302[arg1].field_769:
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if 31 >= stor302[arg1].field_769:
                            mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                        idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                        s = 0
                        while ceil32(uint255(stor302[arg1].field_512) * 0.5) + stor302[arg1].field_769 + 384 > idx:
                            mem[idx + 32] = stor302[arg1][s + 3].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                        mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                        mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                           2 * Mask(256, -1, stor302[arg1].field_512),
                           mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                           2 * Mask(256, -1, stor302[arg1].field_768),
                           mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                    revert with 0, 34
                if stor302[arg1].field_768:
                    if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[arg1].field_768):
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                    s = 0
                    while ceil32(uint255(stor302[arg1].field_512) * 0.5) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                        revert with 0, 34
                    if not stor302[arg1].field_769:
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    if 31 >= stor302[arg1].field_769:
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                    s = 0
                    while ceil32(uint255(stor302[arg1].field_512) * 0.5) + stor302[arg1].field_769 + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                    mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                    mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                       2 * Mask(256, -1, stor302[arg1].field_512),
                       mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                       stor302[arg1].field_768,
                       mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
            if 31 >= uint255(stor302[arg1].field_512) * 0.5:
                mem[384] = 256 * stor302[arg1].field_520
                if stor302[arg1].field_768:
                    if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                        revert with 0, 34
                    if stor302[arg1].field_768:
                        if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor302[arg1].field_768):
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                            mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                        idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                        s = 0
                        while ceil32(uint255(stor302[arg1].field_512) * 0.5) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                            mem[idx + 32] = stor302[arg1][s + 3].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    else:
                        if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                            revert with 0, 34
                        if not stor302[arg1].field_769:
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if 31 >= stor302[arg1].field_769:
                            mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                        idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                        s = 0
                        while ceil32(uint255(stor302[arg1].field_512) * 0.5) + stor302[arg1].field_769 + 384 > idx:
                            mem[idx + 32] = stor302[arg1][s + 3].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                        mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                        mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                           2 * Mask(256, -1, stor302[arg1].field_512),
                           mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                           2 * Mask(256, -1, stor302[arg1].field_768),
                           mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                    revert with 0, 34
                if stor302[arg1].field_768:
                    if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[arg1].field_768):
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                    s = 0
                    while ceil32(uint255(stor302[arg1].field_512) * 0.5) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                        revert with 0, 34
                    if not stor302[arg1].field_769:
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    if 31 >= stor302[arg1].field_769:
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                    s = 0
                    while ceil32(uint255(stor302[arg1].field_512) * 0.5) + stor302[arg1].field_769 + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                    mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                    mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                       2 * Mask(256, -1, stor302[arg1].field_512),
                       mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                       stor302[arg1].field_768,
                       mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
            mem[384] = stor302[arg1][2].field_0
            idx = 384
            s = 0
            while (uint255(stor302[arg1].field_512) * 0.5) + 352 > idx:
                mem[idx + 32] = stor302[arg1][s + 2].field_256
                idx = idx + 32
                s = s + 1
                continue 
        else:
            if stor302[arg1].field_512 == stor302[arg1].field_513 < 32:
                revert with 0, 34
            if not stor302[arg1].field_513:
                if stor302[arg1].field_768:
                    if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                        revert with 0, 34
                    if stor302[arg1].field_768:
                        if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor302[arg1].field_768):
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                            mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                        idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                        s = 0
                        while ceil32(uint255(stor302[arg1].field_512) * 0.5) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                            mem[idx + 32] = stor302[arg1][s + 3].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    else:
                        if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                            revert with 0, 34
                        if not stor302[arg1].field_769:
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if 31 >= stor302[arg1].field_769:
                            mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                        idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                        s = 0
                        while ceil32(uint255(stor302[arg1].field_512) * 0.5) + stor302[arg1].field_769 + 384 > idx:
                            mem[idx + 32] = stor302[arg1][s + 3].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                        mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                        mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                           2 * Mask(256, -1, stor302[arg1].field_512),
                           mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                           2 * Mask(256, -1, stor302[arg1].field_768),
                           mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                    revert with 0, 34
                if stor302[arg1].field_768:
                    if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[arg1].field_768):
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                    s = 0
                    while ceil32(uint255(stor302[arg1].field_512) * 0.5) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                        revert with 0, 34
                    if not stor302[arg1].field_769:
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    if 31 >= stor302[arg1].field_769:
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                    s = 0
                    while ceil32(uint255(stor302[arg1].field_512) * 0.5) + stor302[arg1].field_769 + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                    mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                    mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                       2 * Mask(256, -1, stor302[arg1].field_512),
                       mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                       stor302[arg1].field_768,
                       mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
            if 31 >= stor302[arg1].field_513:
                mem[384] = 256 * stor302[arg1].field_520
                if stor302[arg1].field_768:
                    if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                        revert with 0, 34
                    if stor302[arg1].field_768:
                        if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor302[arg1].field_768):
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                            mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                        idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                        s = 0
                        while ceil32(uint255(stor302[arg1].field_512) * 0.5) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                            mem[idx + 32] = stor302[arg1][s + 3].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    else:
                        if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                            revert with 0, 34
                        if not stor302[arg1].field_769:
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if 31 >= stor302[arg1].field_769:
                            mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                            if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                                mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                            return 32, stor302[arg1].field_0, 
                                   stor302[arg1].field_256,
                                   128,
                                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                                   2 * Mask(256, -1, stor302[arg1].field_512),
                                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                                   uint255(stor302[arg1].field_768) * 0.5,
                                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                        idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                        s = 0
                        while ceil32(uint255(stor302[arg1].field_512) * 0.5) + stor302[arg1].field_769 + 384 > idx:
                            mem[idx + 32] = stor302[arg1][s + 3].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                    if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                        mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                        mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                           2 * Mask(256, -1, stor302[arg1].field_512),
                           mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                           2 * Mask(256, -1, stor302[arg1].field_768),
                           mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                    revert with 0, 34
                if stor302[arg1].field_768:
                    if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[arg1].field_768):
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                    s = 0
                    while ceil32(uint255(stor302[arg1].field_512) * 0.5) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                        revert with 0, 34
                    if not stor302[arg1].field_769:
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    if 31 >= stor302[arg1].field_769:
                        mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                               2 * Mask(256, -1, stor302[arg1].field_512),
                               mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                               stor302[arg1].field_769,
                               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                    mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                    s = 0
                    while ceil32(uint255(stor302[arg1].field_512) * 0.5) + stor302[arg1].field_769 + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                    mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                    mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                       2 * Mask(256, -1, stor302[arg1].field_512),
                       mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                       stor302[arg1].field_768,
                       mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
            mem[384] = stor302[arg1][2].field_0
            idx = 384
            s = 0
            while stor302[arg1].field_513 + 352 > idx:
                mem[idx + 32] = stor302[arg1][s + 2].field_256
                idx = idx + 32
                s = s + 1
                continue 
        if stor302[arg1].field_768:
            if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                revert with 0, 34
            if stor302[arg1].field_768:
                if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, stor302[arg1].field_768):
                    if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                        mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                        mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                           2 * Mask(256, -1, stor302[arg1].field_512),
                           mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                           2 * Mask(256, -1, stor302[arg1].field_768),
                           mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                    mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                    if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                        mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                        mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                           2 * Mask(256, -1, stor302[arg1].field_512),
                           mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                           2 * Mask(256, -1, stor302[arg1].field_768),
                           mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                s = 0
                while ceil32(uint255(stor302[arg1].field_512) * 0.5) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                    mem[idx + 32] = stor302[arg1][s + 3].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            else:
                if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                    revert with 0, 34
                if not stor302[arg1].field_769:
                    if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                        mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                        mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                           2 * Mask(256, -1, stor302[arg1].field_512),
                           mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                           2 * Mask(256, -1, stor302[arg1].field_768),
                           mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if 31 >= stor302[arg1].field_769:
                    mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                    if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                        mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                    mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                        mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                           2 * Mask(256, -1, stor302[arg1].field_512),
                           mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                           2 * Mask(256, -1, stor302[arg1].field_768),
                           mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
                idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
                s = 0
                while ceil32(uint255(stor302[arg1].field_512) * 0.5) + stor302[arg1].field_769 + 384 > idx:
                    mem[idx + 32] = stor302[arg1][s + 3].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            if ceil32(uint255(stor302[arg1].field_512) * 0.5) <= uint255(stor302[arg1].field_512) * 0.5:
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                    mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                       2 * Mask(256, -1, stor302[arg1].field_512),
                       mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                       2 * Mask(256, -1, stor302[arg1].field_768),
                       mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
            mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
            return 32, stor302[arg1].field_0, 
                   stor302[arg1].field_256,
                   128,
                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                   2 * Mask(256, -1, stor302[arg1].field_512),
                   mem[384 len uint255(stor302[arg1].field_512) * 0.5],
                   0,
                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + (uint255(stor302[arg1].field_512) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) - (uint255(stor302[arg1].field_512) * 0.5)]
        if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
            revert with 0, 34
        if stor302[arg1].field_768:
            if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, stor302[arg1].field_768):
                if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                    mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                    mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                       2 * Mask(256, -1, stor302[arg1].field_512),
                       mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                       stor302[arg1].field_768,
                       mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
            if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                    mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                    mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                       2 * Mask(256, -1, stor302[arg1].field_512),
                       mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                       stor302[arg1].field_768,
                       mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
            mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
            idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
            s = 0
            while ceil32(uint255(stor302[arg1].field_512) * 0.5) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                mem[idx + 32] = stor302[arg1][s + 3].field_256
                idx = idx + 32
                s = s + 1
                continue 
        else:
            if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                revert with 0, 34
            if not stor302[arg1].field_769:
                if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                    mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                    mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                       2 * Mask(256, -1, stor302[arg1].field_512),
                       mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                       stor302[arg1].field_768,
                       mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
            if 31 >= stor302[arg1].field_769:
                mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = 256 * stor302[arg1].field_776
                if ceil32(uint255(stor302[arg1].field_512) * 0.5) > uint255(stor302[arg1].field_512) * 0.5:
                    mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
                if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                    mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                       2 * Mask(256, -1, stor302[arg1].field_512),
                       mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                       stor302[arg1].field_768,
                       mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
            mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416] = stor302[arg1][3].field_0
            idx = ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416
            s = 0
            while ceil32(uint255(stor302[arg1].field_512) * 0.5) + stor302[arg1].field_769 + 384 > idx:
                mem[idx + 32] = stor302[arg1][s + 3].field_256
                idx = idx + 32
                s = s + 1
                continue 
        if ceil32(uint255(stor302[arg1].field_512) * 0.5) <= uint255(stor302[arg1].field_512) * 0.5:
            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
            mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
            if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
            return 32, stor302[arg1].field_0, 
                   stor302[arg1].field_256,
                   128,
                   ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
                   2 * Mask(256, -1, stor302[arg1].field_512),
                   mem[384 len ceil32(uint255(stor302[arg1].field_512) * 0.5)],
                   stor302[arg1].field_768,
                   mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
        mem[(uint255(stor302[arg1].field_512) * 0.5) + ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + 608] = 0
        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
        mem[(2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + 416 len ceil32(stor302[arg1].field_769)]
        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
            mem[stor302[arg1].field_769 + (2 * ceil32(uint255(stor302[arg1].field_512) * 0.5)) + ceil32(stor302[arg1].field_769) + 640] = 0
        return 32, stor302[arg1].field_0, 
               stor302[arg1].field_256,
               128,
               ceil32(uint255(stor302[arg1].field_512) * 0.5) + 160,
               2 * Mask(256, -1, stor302[arg1].field_512),
               mem[384 len uint255(stor302[arg1].field_512) * 0.5],
               0,
               mem[ceil32(uint255(stor302[arg1].field_512) * 0.5) + ceil32(stor302[arg1].field_769) + (uint255(stor302[arg1].field_512) * 0.5) + 640 len ceil32(stor302[arg1].field_769) + ceil32(uint255(stor302[arg1].field_512) * 0.5) - (uint255(stor302[arg1].field_512) * 0.5)]
    if stor302[arg1].field_512 == stor302[arg1].field_513 < 32:
        revert with 0, 34
    if stor302[arg1].field_512:
        if stor302[arg1].field_512 == uint255(stor302[arg1].field_512) * 0.5 < 32:
            revert with 0, 34
        if not Mask(256, -1, stor302[arg1].field_512):
            if stor302[arg1].field_768:
                if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                    revert with 0, 34
                if stor302[arg1].field_768:
                    if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[arg1].field_768):
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                        mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(stor302[arg1].field_513) + 416
                    s = 0
                    while ceil32(stor302[arg1].field_513) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                        revert with 0, 34
                    if not stor302[arg1].field_769:
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if 31 >= stor302[arg1].field_769:
                        mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(stor302[arg1].field_513) + 416
                    s = 0
                    while ceil32(stor302[arg1].field_513) + stor302[arg1].field_769 + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                    mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                    mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(stor302[arg1].field_513) + 160,
                       stor302[arg1].field_512,
                       mem[384 len ceil32(stor302[arg1].field_513)],
                       2 * Mask(256, -1, stor302[arg1].field_768),
                       mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
            if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                revert with 0, 34
            if stor302[arg1].field_768:
                if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, stor302[arg1].field_768):
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                    mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                idx = ceil32(stor302[arg1].field_513) + 416
                s = 0
                while ceil32(stor302[arg1].field_513) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                    mem[idx + 32] = stor302[arg1][s + 3].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            else:
                if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                    revert with 0, 34
                if not stor302[arg1].field_769:
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                if 31 >= stor302[arg1].field_769:
                    mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                idx = ceil32(stor302[arg1].field_513) + 416
                s = 0
                while ceil32(stor302[arg1].field_513) + stor302[arg1].field_769 + 384 > idx:
                    mem[idx + 32] = stor302[arg1][s + 3].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
            if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
            return 32, stor302[arg1].field_0, 
                   stor302[arg1].field_256,
                   128,
                   ceil32(stor302[arg1].field_513) + 160,
                   stor302[arg1].field_512,
                   mem[384 len ceil32(stor302[arg1].field_513)],
                   stor302[arg1].field_768,
                   mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
        if 31 >= uint255(stor302[arg1].field_512) * 0.5:
            mem[384] = 256 * stor302[arg1].field_520
            if stor302[arg1].field_768:
                if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                    revert with 0, 34
                if stor302[arg1].field_768:
                    if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[arg1].field_768):
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                        mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(stor302[arg1].field_513) + 416
                    s = 0
                    while ceil32(stor302[arg1].field_513) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                        revert with 0, 34
                    if not stor302[arg1].field_769:
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if 31 >= stor302[arg1].field_769:
                        mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(stor302[arg1].field_513) + 416
                    s = 0
                    while ceil32(stor302[arg1].field_513) + stor302[arg1].field_769 + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                    mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                    mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(stor302[arg1].field_513) + 160,
                       stor302[arg1].field_512,
                       mem[384 len ceil32(stor302[arg1].field_513)],
                       2 * Mask(256, -1, stor302[arg1].field_768),
                       mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
            if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                revert with 0, 34
            if stor302[arg1].field_768:
                if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, stor302[arg1].field_768):
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                    mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                idx = ceil32(stor302[arg1].field_513) + 416
                s = 0
                while ceil32(stor302[arg1].field_513) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                    mem[idx + 32] = stor302[arg1][s + 3].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            else:
                if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                    revert with 0, 34
                if not stor302[arg1].field_769:
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                if 31 >= stor302[arg1].field_769:
                    mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                idx = ceil32(stor302[arg1].field_513) + 416
                s = 0
                while ceil32(stor302[arg1].field_513) + stor302[arg1].field_769 + 384 > idx:
                    mem[idx + 32] = stor302[arg1][s + 3].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
            if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
            return 32, stor302[arg1].field_0, 
                   stor302[arg1].field_256,
                   128,
                   ceil32(stor302[arg1].field_513) + 160,
                   stor302[arg1].field_512,
                   mem[384 len ceil32(stor302[arg1].field_513)],
                   stor302[arg1].field_768,
                   mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
        mem[384] = stor302[arg1][2].field_0
        idx = 384
        s = 0
        while (uint255(stor302[arg1].field_512) * 0.5) + 352 > idx:
            mem[idx + 32] = stor302[arg1][s + 2].field_256
            idx = idx + 32
            s = s + 1
            continue 
    else:
        if stor302[arg1].field_512 == stor302[arg1].field_513 < 32:
            revert with 0, 34
        if not stor302[arg1].field_513:
            if stor302[arg1].field_768:
                if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                    revert with 0, 34
                if stor302[arg1].field_768:
                    if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[arg1].field_768):
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                        mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(stor302[arg1].field_513) + 416
                    s = 0
                    while ceil32(stor302[arg1].field_513) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                        revert with 0, 34
                    if not stor302[arg1].field_769:
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if 31 >= stor302[arg1].field_769:
                        mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(stor302[arg1].field_513) + 416
                    s = 0
                    while ceil32(stor302[arg1].field_513) + stor302[arg1].field_769 + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                    mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                    mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(stor302[arg1].field_513) + 160,
                       stor302[arg1].field_512,
                       mem[384 len ceil32(stor302[arg1].field_513)],
                       2 * Mask(256, -1, stor302[arg1].field_768),
                       mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
            if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                revert with 0, 34
            if stor302[arg1].field_768:
                if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, stor302[arg1].field_768):
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                    mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                idx = ceil32(stor302[arg1].field_513) + 416
                s = 0
                while ceil32(stor302[arg1].field_513) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                    mem[idx + 32] = stor302[arg1][s + 3].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            else:
                if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                    revert with 0, 34
                if not stor302[arg1].field_769:
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                if 31 >= stor302[arg1].field_769:
                    mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                idx = ceil32(stor302[arg1].field_513) + 416
                s = 0
                while ceil32(stor302[arg1].field_513) + stor302[arg1].field_769 + 384 > idx:
                    mem[idx + 32] = stor302[arg1][s + 3].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
            if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
            return 32, stor302[arg1].field_0, 
                   stor302[arg1].field_256,
                   128,
                   ceil32(stor302[arg1].field_513) + 160,
                   stor302[arg1].field_512,
                   mem[384 len ceil32(stor302[arg1].field_513)],
                   stor302[arg1].field_768,
                   mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
        if 31 >= stor302[arg1].field_513:
            mem[384] = 256 * stor302[arg1].field_520
            if stor302[arg1].field_768:
                if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                    revert with 0, 34
                if stor302[arg1].field_768:
                    if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[arg1].field_768):
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                        mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(stor302[arg1].field_513) + 416
                    s = 0
                    while ceil32(stor302[arg1].field_513) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                else:
                    if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                        revert with 0, 34
                    if not stor302[arg1].field_769:
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    if 31 >= stor302[arg1].field_769:
                        mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                        if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                            mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                        return 32, stor302[arg1].field_0, 
                               stor302[arg1].field_256,
                               128,
                               ceil32(stor302[arg1].field_513) + 160,
                               stor302[arg1].field_512,
                               mem[384 len ceil32(stor302[arg1].field_513)],
                               uint255(stor302[arg1].field_768) * 0.5,
                               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                    mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                    idx = ceil32(stor302[arg1].field_513) + 416
                    s = 0
                    while ceil32(stor302[arg1].field_513) + stor302[arg1].field_769 + 384 > idx:
                        mem[idx + 32] = stor302[arg1][s + 3].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                    mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                    mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(stor302[arg1].field_513) + 160,
                       stor302[arg1].field_512,
                       mem[384 len ceil32(stor302[arg1].field_513)],
                       2 * Mask(256, -1, stor302[arg1].field_768),
                       mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
            if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                revert with 0, 34
            if stor302[arg1].field_768:
                if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                    revert with 0, 34
                if not Mask(256, -1, stor302[arg1].field_768):
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                    mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                idx = ceil32(stor302[arg1].field_513) + 416
                s = 0
                while ceil32(stor302[arg1].field_513) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                    mem[idx + 32] = stor302[arg1][s + 3].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            else:
                if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                    revert with 0, 34
                if not stor302[arg1].field_769:
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                if 31 >= stor302[arg1].field_769:
                    mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                    if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
                    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
                    return 32, stor302[arg1].field_0, 
                           stor302[arg1].field_256,
                           128,
                           ceil32(stor302[arg1].field_513) + 160,
                           stor302[arg1].field_512,
                           mem[384 len ceil32(stor302[arg1].field_513)],
                           stor302[arg1].field_769,
                           mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
                mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
                idx = ceil32(stor302[arg1].field_513) + 416
                s = 0
                while ceil32(stor302[arg1].field_513) + stor302[arg1].field_769 + 384 > idx:
                    mem[idx + 32] = stor302[arg1][s + 3].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
            if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
            if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
            return 32, stor302[arg1].field_0, 
                   stor302[arg1].field_256,
                   128,
                   ceil32(stor302[arg1].field_513) + 160,
                   stor302[arg1].field_512,
                   mem[384 len ceil32(stor302[arg1].field_513)],
                   stor302[arg1].field_768,
                   mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
        mem[384] = stor302[arg1][2].field_0
        idx = 384
        s = 0
        while stor302[arg1].field_513 + 352 > idx:
            mem[idx + 32] = stor302[arg1][s + 2].field_256
            idx = idx + 32
            s = s + 1
            continue 
    if stor302[arg1].field_768:
        if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
            revert with 0, 34
        if stor302[arg1].field_768:
            if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
                revert with 0, 34
            if not Mask(256, -1, stor302[arg1].field_768):
                if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                    mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                    mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(stor302[arg1].field_513) + 160,
                       stor302[arg1].field_512,
                       mem[384 len ceil32(stor302[arg1].field_513)],
                       2 * Mask(256, -1, stor302[arg1].field_768),
                       mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
            if 31 >= uint255(stor302[arg1].field_768) * 0.5:
                mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                    mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                    mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(stor302[arg1].field_513) + 160,
                       stor302[arg1].field_512,
                       mem[384 len ceil32(stor302[arg1].field_513)],
                       2 * Mask(256, -1, stor302[arg1].field_768),
                       mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
            mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
            idx = ceil32(stor302[arg1].field_513) + 416
            s = 0
            while ceil32(stor302[arg1].field_513) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
                mem[idx + 32] = stor302[arg1][s + 3].field_256
                idx = idx + 32
                s = s + 1
                continue 
        else:
            if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
                revert with 0, 34
            if not stor302[arg1].field_769:
                if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                    mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                    mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(stor302[arg1].field_513) + 160,
                       stor302[arg1].field_512,
                       mem[384 len ceil32(stor302[arg1].field_513)],
                       2 * Mask(256, -1, stor302[arg1].field_768),
                       mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
            if 31 >= stor302[arg1].field_769:
                mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
                if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                    mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
                mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
                if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                    mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
                return 32, stor302[arg1].field_0, 
                       stor302[arg1].field_256,
                       128,
                       ceil32(stor302[arg1].field_513) + 160,
                       stor302[arg1].field_512,
                       mem[384 len ceil32(stor302[arg1].field_513)],
                       2 * Mask(256, -1, stor302[arg1].field_768),
                       mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
            mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
            idx = ceil32(stor302[arg1].field_513) + 416
            s = 0
            while ceil32(stor302[arg1].field_513) + stor302[arg1].field_769 + 384 > idx:
                mem[idx + 32] = stor302[arg1][s + 3].field_256
                idx = idx + 32
                s = s + 1
                continue 
        if ceil32(stor302[arg1].field_513) <= stor302[arg1].field_513:
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
            if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
                mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
            return 32, stor302[arg1].field_0, 
                   stor302[arg1].field_256,
                   128,
                   ceil32(stor302[arg1].field_513) + 160,
                   stor302[arg1].field_512,
                   mem[384 len ceil32(stor302[arg1].field_513)],
                   2 * Mask(256, -1, stor302[arg1].field_768),
                   mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
        mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = 0
        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 608] = uint255(stor302[arg1].field_768) * 0.5
        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(uint255(stor302[arg1].field_768) * 0.5)]
        if ceil32(uint255(stor302[arg1].field_768) * 0.5) > uint255(stor302[arg1].field_768) * 0.5:
            mem[(uint255(stor302[arg1].field_768) * 0.5) + (2 * ceil32(stor302[arg1].field_513)) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + 640] = 0
        return 32, stor302[arg1].field_0, 
               stor302[arg1].field_256,
               128,
               ceil32(stor302[arg1].field_513) + 160,
               stor302[arg1].field_512,
               mem[384 len stor302[arg1].field_513],
               0,
               mem[ceil32(stor302[arg1].field_513) + ceil32(uint255(stor302[arg1].field_768) * 0.5) + stor302[arg1].field_513 + 640 len ceil32(uint255(stor302[arg1].field_768) * 0.5) + ceil32(stor302[arg1].field_513) - stor302[arg1].field_513]
    if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
        revert with 0, 34
    if stor302[arg1].field_768:
        if stor302[arg1].field_768 == uint255(stor302[arg1].field_768) * 0.5 < 32:
            revert with 0, 34
        if not Mask(256, -1, stor302[arg1].field_768):
            if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
            if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
            return 32, stor302[arg1].field_0, 
                   stor302[arg1].field_256,
                   128,
                   ceil32(stor302[arg1].field_513) + 160,
                   stor302[arg1].field_512,
                   mem[384 len ceil32(stor302[arg1].field_513)],
                   stor302[arg1].field_768,
                   mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
        if 31 >= uint255(stor302[arg1].field_768) * 0.5:
            mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
            if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
            if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
            return 32, stor302[arg1].field_0, 
                   stor302[arg1].field_256,
                   128,
                   ceil32(stor302[arg1].field_513) + 160,
                   stor302[arg1].field_512,
                   mem[384 len ceil32(stor302[arg1].field_513)],
                   stor302[arg1].field_768,
                   mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
        mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
        idx = ceil32(stor302[arg1].field_513) + 416
        s = 0
        while ceil32(stor302[arg1].field_513) + (uint255(stor302[arg1].field_768) * 0.5) + 384 > idx:
            mem[idx + 32] = stor302[arg1][s + 3].field_256
            idx = idx + 32
            s = s + 1
            continue 
    else:
        if stor302[arg1].field_768 == stor302[arg1].field_769 < 32:
            revert with 0, 34
        if not stor302[arg1].field_769:
            if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
            if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
            return 32, stor302[arg1].field_0, 
                   stor302[arg1].field_256,
                   128,
                   ceil32(stor302[arg1].field_513) + 160,
                   stor302[arg1].field_512,
                   mem[384 len ceil32(stor302[arg1].field_513)],
                   stor302[arg1].field_768,
                   mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
        if 31 >= stor302[arg1].field_769:
            mem[ceil32(stor302[arg1].field_513) + 416] = 256 * stor302[arg1].field_776
            if ceil32(stor302[arg1].field_513) > stor302[arg1].field_513:
                mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
            mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
            if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
                mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
            return 32, stor302[arg1].field_0, 
                   stor302[arg1].field_256,
                   128,
                   ceil32(stor302[arg1].field_513) + 160,
                   stor302[arg1].field_512,
                   mem[384 len ceil32(stor302[arg1].field_513)],
                   stor302[arg1].field_768,
                   mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
        mem[ceil32(stor302[arg1].field_513) + 416] = stor302[arg1][3].field_0
        idx = ceil32(stor302[arg1].field_513) + 416
        s = 0
        while ceil32(stor302[arg1].field_513) + stor302[arg1].field_769 + 384 > idx:
            mem[idx + 32] = stor302[arg1][s + 3].field_256
            idx = idx + 32
            s = s + 1
            continue 
    if ceil32(stor302[arg1].field_513) <= stor302[arg1].field_513:
        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
        mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
        if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
            mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
        return 32, stor302[arg1].field_0, 
               stor302[arg1].field_256,
               128,
               ceil32(stor302[arg1].field_513) + 160,
               stor302[arg1].field_512,
               mem[384 len ceil32(stor302[arg1].field_513)],
               stor302[arg1].field_768,
               mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
    mem[stor302[arg1].field_513 + ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + 608] = 0
    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 608] = stor302[arg1].field_769
    mem[(2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640 len ceil32(stor302[arg1].field_769)] = mem[ceil32(stor302[arg1].field_513) + 416 len ceil32(stor302[arg1].field_769)]
    if ceil32(stor302[arg1].field_769) > stor302[arg1].field_769:
        mem[stor302[arg1].field_769 + (2 * ceil32(stor302[arg1].field_513)) + ceil32(stor302[arg1].field_769) + 640] = 0
    return 32, stor302[arg1].field_0, 
           stor302[arg1].field_256,
           128,
           ceil32(stor302[arg1].field_513) + 160,
           stor302[arg1].field_512,
           mem[384 len stor302[arg1].field_513],
           0,
           mem[ceil32(stor302[arg1].field_513) + ceil32(stor302[arg1].field_769) + stor302[arg1].field_513 + 640 len ceil32(stor302[arg1].field_769) + ceil32(stor302[arg1].field_513) - stor302[arg1].field_513]
}

function nftListByIds(uint256[] arg1) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    mem[64] = (32 * arg1.length) + 128
    if not arg1.length:
        idx = 0
        while idx < arg1.length:
            _487 = mem[64]
            mem[64] = mem[64] + 128
            mem[_487] = 0
            mem[_487 + 32] = 0
            mem[_487 + 64] = 96
            mem[_487 + 96] = 96
            mem[0] = cd[((32 * idx) + arg1 + 36)]
            mem[32] = 302
            _489 = mem[64]
            mem[64] = mem[64] + 128
            mem[_489] = stor302[cd[((32 * idx) + arg1 + 36)]].field_0
            mem[_489 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]].field_256
            if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                    revert with 0, 34
                _499 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) + 32
                mem[_499] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_489 + 64] = _499
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _523 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_523] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_523 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_523 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _523 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _523 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_523 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_523 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _523 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _523 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_489 + 96] = _523
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _526 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_526] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_526 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_526 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _526 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _526 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_526 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_526 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _526 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _526 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_489 + 96] = _526
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_499 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_489 + 64] = _499
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _532 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_532] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_532 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_532 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _532 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _532 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_532 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_532 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _532 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _532 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _532
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _538 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_538] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_538 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_538 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _538 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _538 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_538 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_538 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _538 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _538 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _538
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_499 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _499 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _499 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_489 + 64] = _499
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _1006 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_1006] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1006 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1006 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1006 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1006 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1006 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1006 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1006 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1006 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _1006
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _1012 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_1012] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1012 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1012 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1012 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1012 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1012 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1012 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1012 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1012 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _1012
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_489 + 64] = _499
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _527 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_527] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_527 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_527 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _527 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _527 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_527 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_527 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _527 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _527 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_489 + 96] = _527
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _533 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_533] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_533 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_533 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _533 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _533 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_533 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_533 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _533 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _533 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_489 + 96] = _533
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_499 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_489 + 64] = _499
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _539 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_539] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_539 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_539 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _539 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _539 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_539 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_539 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _539 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _539 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _539
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _544 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_544] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_544 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_544 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _544 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _544 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_544 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_544 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _544 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _544 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _544
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_499 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _499 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _499 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_489 + 64] = _499
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _1007 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_1007] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1007 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1007 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1007 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1007 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1007 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1007 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1007 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1007 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _1007
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _1013 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_1013] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1013 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1013 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1013 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1013 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1013 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1013 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1013 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1013 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _1013
            else:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                    revert with 0, 34
                _502 = mem[64]
                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_513) + 32
                mem[_502] = stor302[cd[((32 * idx) + arg1 + 36)]].field_513
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_489 + 64] = _502
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _528 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_528] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_528 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_528 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _528 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _528 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_528 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_528 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _528 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _528 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_489 + 96] = _528
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _534 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_534] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_534 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_534 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _534 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _534 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_534 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_534 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _534 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _534 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_489 + 96] = _534
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_502 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_489 + 64] = _502
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _540 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_540] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_540 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_540 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _540 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _540 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_540 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_540 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _540 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _540 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _540
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _545 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_545] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_545 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_545 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _545 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _545 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_545 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_545 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _545 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _545 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _545
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_502 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _502 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _502 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_489 + 64] = _502
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _1008 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_1008] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1008 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1008 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1008 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1008 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1008 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1008 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1008 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1008 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _1008
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _1014 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_1014] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1014 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1014 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1014 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1014 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1014 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1014 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1014 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1014 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _1014
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_489 + 64] = _502
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _535 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_535] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_535 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_535 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _535 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _535 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_535 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_535 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _535 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _535 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_489 + 96] = _535
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _541 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_541] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_541 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_541 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _541 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _541 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_541 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_541 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _541 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _541 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_489 + 96] = _541
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_502 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_489 + 64] = _502
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _546 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_546] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_546 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_546 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _546 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _546 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_546 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_546 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _546 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _546 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _546
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _553 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_553] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_553 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_553 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _553 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _553 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_553 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_553 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _553 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _553 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _553
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_502 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _502 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _502 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_489 + 64] = _502
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _1009 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_1009] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1009 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1009 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1009 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1009 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1009 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1009 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1009 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1009 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _1009
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _1015 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_1015] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1015 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1015 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1015 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1015 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1015 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1015 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1015 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1015 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_489 + 96] = _1015
            if idx >= mem[96]:
                revert with 0, 50
            mem[(32 * idx) + 128] = _489
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _484 = mem[64]
        mem[mem[64]] = 32
        _486 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + 64
        u = mem[64] + (32 * mem[96]) + 64
        while idx < _486:
            mem[t] = u + -_484 - 64
            _965 = mem[s]
            mem[u] = mem[mem[s]]
            mem[u + 32] = mem[_965 + 32]
            _970 = mem[_965 + 64]
            mem[u + 64] = 128
            _971 = mem[_970]
            mem[u + 128] = mem[_970]
            v = 0
            while v < _971:
                mem[v + u + 160] = mem[v + _970 + 32]
                v = v + 32
                continue 
            if ceil32(_971) <= _971:
                _1585 = mem[_965 + 96]
                mem[u + 96] = ceil32(_971) + 160
                _1589 = mem[_1585]
                mem[ceil32(_971) + u + 160] = mem[_1585]
                v = 0
                while v < _1589:
                    mem[v + ceil32(_971) + u + 192] = mem[v + _1585 + 32]
                    v = v + 32
                    continue 
                if ceil32(_1589) > _1589:
                    mem[_1589 + ceil32(_971) + u + 192] = 0
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_1589) + ceil32(_971) + u + 192
                continue 
            mem[_971 + u + 160] = 0
            _1586 = mem[_965 + 96]
            mem[u + 96] = ceil32(_971) + 160
            _1590 = mem[_1586]
            mem[ceil32(_971) + u + 160] = mem[_1586]
            v = 0
            while v < _1590:
                mem[v + ceil32(_971) + u + 192] = mem[v + _1586 + 32]
                v = v + 32
                continue 
            if ceil32(_1590) > _1590:
                mem[_1590 + ceil32(_971) + u + 192] = 0
            idx = idx + 1
            s = s + 32
            t = t + 32
            u = ceil32(_1590) + ceil32(_971) + u + 192
            continue 
        return memory
          from mem[64]
           len u - mem[64]
    mem[64] = (32 * arg1.length) + 256
    mem[(32 * arg1.length) + 128] = 0
    mem[(32 * arg1.length) + 160] = 0
    mem[(32 * arg1.length) + 192] = 96
    mem[(32 * arg1.length) + 224] = 96
    mem[var17002] = var17001
    if not var17003 - 1:
        idx = 0
        while idx < arg1.length:
            _1584 = mem[64]
            mem[64] = mem[64] + 128
            mem[_1584] = 0
            mem[_1584 + 32] = 0
            mem[_1584 + 64] = 96
            mem[_1584 + 96] = 96
            mem[0] = cd[((32 * idx) + arg1 + 36)]
            mem[32] = 302
            _1588 = mem[64]
            mem[64] = mem[64] + 128
            mem[_1588] = stor302[cd[((32 * idx) + arg1 + 36)]].field_0
            mem[_1588 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]].field_256
            if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                    revert with 0, 34
                _1604 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) + 32
                mem[_1604] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_1588 + 64] = _1604
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _1628 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_1628] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_1628 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1628 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1628 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1628 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_1628 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1628 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1628 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1628 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_1588 + 96] = _1628
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _1632 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_1632] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_1632 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1632 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1632 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1632 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_1632 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1632 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1632 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1632 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_1588 + 96] = _1632
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_1604 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_1588 + 64] = _1604
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _1637 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_1637] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1637 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1637 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1637 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1637 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1637 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1637 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1637 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1637 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _1637
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _1642 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_1642] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1642 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1642 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1642 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1642 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1642 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1642 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1642 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1642 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _1642
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_1604 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _1604 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _1604 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_1588 + 64] = _1604
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _2113 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_2113] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2113 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2113 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2113 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2113 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2113 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2113 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2113 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2113 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _2113
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _2120 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_2120] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2120 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2120 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2120 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2120 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2120 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2120 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2120 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2120 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _2120
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_1588 + 64] = _1604
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _1633 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_1633] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_1633 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1633 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1633 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1633 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_1633 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1633 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1633 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1633 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_1588 + 96] = _1633
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _1638 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_1638] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_1638 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1638 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1638 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1638 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_1638 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1638 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1638 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1638 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_1588 + 96] = _1638
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_1604 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_1588 + 64] = _1604
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _1643 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_1643] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1643 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1643 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1643 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1643 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1643 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1643 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1643 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1643 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _1643
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _1650 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_1650] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1650 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1650 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1650 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1650 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1650 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1650 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1650 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1650 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _1650
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_1604 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _1604 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _1604 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_1588 + 64] = _1604
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _2114 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_2114] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2114 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2114 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2114 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2114 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2114 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2114 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2114 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2114 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _2114
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _2121 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_2121] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2121 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2121 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2121 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2121 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2121 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2121 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2121 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2121 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _2121
            else:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                    revert with 0, 34
                _1606 = mem[64]
                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_513) + 32
                mem[_1606] = stor302[cd[((32 * idx) + arg1 + 36)]].field_513
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_1588 + 64] = _1606
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _1634 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_1634] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_1634 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1634 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1634 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1634 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_1634 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1634 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1634 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1634 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_1588 + 96] = _1634
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _1639 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_1639] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_1639 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1639 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1639 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1639 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_1639 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1639 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1639 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1639 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_1588 + 96] = _1639
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_1606 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_1588 + 64] = _1606
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _1644 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_1644] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1644 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1644 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1644 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1644 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1644 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1644 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1644 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1644 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _1644
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _1651 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_1651] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1651 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1651 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1651 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1651 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1651 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1651 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1651 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1651 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _1651
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_1606 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _1606 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _1606 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_1588 + 64] = _1606
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _2115 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_2115] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2115 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2115 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2115 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2115 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2115 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2115 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2115 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2115 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _2115
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _2122 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_2122] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2122 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2122 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2122 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2122 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2122 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2122 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2122 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2122 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _2122
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_1588 + 64] = _1606
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _1640 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_1640] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_1640 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1640 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1640 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1640 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_1640 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1640 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1640 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1640 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_1588 + 96] = _1640
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _1645 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_1645] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_1645 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1645 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1645 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1645 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_1645 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_1645 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _1645 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _1645 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_1588 + 96] = _1645
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_1606 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_1588 + 64] = _1606
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _1652 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_1652] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1652 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1652 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1652 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1652 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1652 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1652 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1652 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1652 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _1652
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _1659 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_1659] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_1659 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1659 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1659 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1659 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_1659 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_1659 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _1659 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _1659 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _1659
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_1606 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _1606 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _1606 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_1588 + 64] = _1606
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _2116 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_2116] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2116 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2116 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2116 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2116 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2116 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2116 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2116 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2116 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _2116
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _2123 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_2123] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2123 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2123 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2123 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2123 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2123 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2123 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2123 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2123 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_1588 + 96] = _2123
            if idx >= mem[96]:
                revert with 0, 50
            mem[(32 * idx) + 128] = _1588
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _1566 = mem[64]
        mem[mem[64]] = 32
        _1583 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + 64
        u = mem[64] + (32 * mem[96]) + 64
        while idx < _1583:
            mem[t] = u + -_1566 - 64
            _2071 = mem[s]
            mem[u] = mem[mem[s]]
            mem[u + 32] = mem[_2071 + 32]
            _2075 = mem[_2071 + 64]
            mem[u + 64] = 128
            _2076 = mem[_2075]
            mem[u + 128] = mem[_2075]
            v = 0
            while v < _2076:
                mem[v + u + 160] = mem[v + _2075 + 32]
                v = v + 32
                continue 
            if ceil32(_2076) <= _2076:
                _2692 = mem[_2071 + 96]
                mem[u + 96] = ceil32(_2076) + 160
                _2695 = mem[_2692]
                mem[ceil32(_2076) + u + 160] = mem[_2692]
                v = 0
                while v < _2695:
                    mem[v + ceil32(_2076) + u + 192] = mem[v + _2692 + 32]
                    v = v + 32
                    continue 
                if ceil32(_2695) > _2695:
                    mem[_2695 + ceil32(_2076) + u + 192] = 0
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_2695) + ceil32(_2076) + u + 192
                continue 
            mem[_2076 + u + 160] = 0
            _2693 = mem[_2071 + 96]
            mem[u + 96] = ceil32(_2076) + 160
            _2696 = mem[_2693]
            mem[ceil32(_2076) + u + 160] = mem[_2693]
            v = 0
            while v < _2696:
                mem[v + ceil32(_2076) + u + 192] = mem[v + _2693 + 32]
                v = v + 32
                continue 
            if ceil32(_2696) > _2696:
                mem[_2696 + ceil32(_2076) + u + 192] = 0
            idx = idx + 1
            s = s + 32
            t = t + 32
            u = ceil32(_2696) + ceil32(_2076) + u + 192
            continue 
        return memory
          from mem[64]
           len u - mem[64]
    mem[64] = (32 * arg1.length) + 384
    mem[(32 * arg1.length) + 256] = 0
    mem[(32 * arg1.length) + 288] = 0
    mem[(32 * arg1.length) + 320] = 96
    mem[(32 * arg1.length) + 352] = 96
    mem[var21002] = var21001
    if not var21003 - 1:
        idx = 0
        while idx < arg1.length:
            _2673 = mem[64]
            mem[64] = mem[64] + 128
            mem[_2673] = 0
            mem[_2673 + 32] = 0
            mem[_2673 + 64] = 96
            mem[_2673 + 96] = 96
            mem[0] = cd[((32 * idx) + arg1 + 36)]
            mem[32] = 302
            _2691 = mem[64]
            mem[64] = mem[64] + 128
            mem[_2691] = stor302[cd[((32 * idx) + arg1 + 36)]].field_0
            mem[_2691 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]].field_256
            if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                    revert with 0, 34
                _2707 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) + 32
                mem[_2707] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_2691 + 64] = _2707
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _2733 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_2733] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_2733 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2733 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2733 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2733 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_2733 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2733 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2733 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2733 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_2691 + 96] = _2733
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _2737 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_2737] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_2737 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2737 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2737 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2737 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_2737 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2737 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2737 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2737 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_2691 + 96] = _2737
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_2707 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_2691 + 64] = _2707
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _2742 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_2742] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2742 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2742 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2742 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2742 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2742 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2742 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2742 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2742 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _2742
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _2747 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_2747] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2747 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2747 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2747 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2747 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2747 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2747 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2747 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2747 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _2747
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_2707 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _2707 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _2707 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_2691 + 64] = _2707
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _3218 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_3218] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3218 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3218 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3218 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3218 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3218 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3218 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3218 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3218 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _3218
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _3225 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_3225] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3225 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3225 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3225 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3225 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3225 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3225 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3225 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3225 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _3225
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_2691 + 64] = _2707
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _2738 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_2738] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_2738 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2738 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2738 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2738 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_2738 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2738 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2738 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2738 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_2691 + 96] = _2738
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _2743 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_2743] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_2743 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2743 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2743 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2743 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_2743 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2743 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2743 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2743 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_2691 + 96] = _2743
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_2707 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_2691 + 64] = _2707
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _2748 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_2748] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2748 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2748 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2748 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2748 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2748 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2748 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2748 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2748 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _2748
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _2755 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_2755] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2755 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2755 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2755 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2755 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2755 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2755 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2755 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2755 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _2755
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_2707 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _2707 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _2707 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_2691 + 64] = _2707
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _3219 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_3219] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3219 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3219 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3219 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3219 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3219 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3219 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3219 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3219 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _3219
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _3226 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_3226] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3226 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3226 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3226 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3226 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3226 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3226 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3226 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3226 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _3226
            else:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                    revert with 0, 34
                _2711 = mem[64]
                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_513) + 32
                mem[_2711] = stor302[cd[((32 * idx) + arg1 + 36)]].field_513
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_2691 + 64] = _2711
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _2739 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_2739] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_2739 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2739 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2739 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2739 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_2739 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2739 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2739 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2739 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_2691 + 96] = _2739
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _2744 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_2744] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_2744 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2744 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2744 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2744 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_2744 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2744 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2744 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2744 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_2691 + 96] = _2744
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_2711 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_2691 + 64] = _2711
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _2749 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_2749] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2749 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2749 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2749 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2749 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2749 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2749 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2749 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2749 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _2749
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _2756 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_2756] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2756 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2756 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2756 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2756 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2756 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2756 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2756 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2756 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _2756
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_2711 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _2711 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _2711 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_2691 + 64] = _2711
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _3220 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_3220] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3220 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3220 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3220 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3220 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3220 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3220 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3220 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3220 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _3220
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _3227 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_3227] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3227 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3227 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3227 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3227 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3227 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3227 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3227 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3227 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _3227
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_2691 + 64] = _2711
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _2745 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_2745] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_2745 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2745 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2745 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2745 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_2745 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2745 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2745 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2745 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_2691 + 96] = _2745
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _2750 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_2750] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_2750 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2750 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2750 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2750 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_2750 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_2750 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _2750 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _2750 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_2691 + 96] = _2750
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_2711 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_2691 + 64] = _2711
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _2757 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_2757] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2757 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2757 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2757 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2757 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2757 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2757 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2757 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2757 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _2757
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _2764 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_2764] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_2764 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2764 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2764 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2764 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_2764 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_2764 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _2764 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _2764 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _2764
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_2711 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _2711 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _2711 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_2691 + 64] = _2711
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _3221 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_3221] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3221 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3221 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3221 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3221 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3221 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3221 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3221 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3221 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _3221
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _3228 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_3228] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3228 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3228 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3228 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3228 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3228 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3228 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3228 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3228 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_2691 + 96] = _3228
            if idx >= mem[96]:
                revert with 0, 50
            mem[(32 * idx) + 128] = _2691
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _2671 = mem[64]
        mem[mem[64]] = 32
        _2672 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + 64
        u = mem[64] + (32 * mem[96]) + 64
        while idx < _2672:
            mem[t] = u + -_2671 - 64
            _3174 = mem[s]
            mem[u] = mem[mem[s]]
            mem[u + 32] = mem[_3174 + 32]
            _3180 = mem[_3174 + 64]
            mem[u + 64] = 128
            _3181 = mem[_3180]
            mem[u + 128] = mem[_3180]
            v = 0
            while v < _3181:
                mem[v + u + 160] = mem[v + _3180 + 32]
                v = v + 32
                continue 
            if ceil32(_3181) <= _3181:
                _3797 = mem[_3174 + 96]
                mem[u + 96] = ceil32(_3181) + 160
                _3800 = mem[_3797]
                mem[ceil32(_3181) + u + 160] = mem[_3797]
                v = 0
                while v < _3800:
                    mem[v + ceil32(_3181) + u + 192] = mem[v + _3797 + 32]
                    v = v + 32
                    continue 
                if ceil32(_3800) > _3800:
                    mem[_3800 + ceil32(_3181) + u + 192] = 0
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_3800) + ceil32(_3181) + u + 192
                continue 
            mem[_3181 + u + 160] = 0
            _3798 = mem[_3174 + 96]
            mem[u + 96] = ceil32(_3181) + 160
            _3801 = mem[_3798]
            mem[ceil32(_3181) + u + 160] = mem[_3798]
            v = 0
            while v < _3801:
                mem[v + ceil32(_3181) + u + 192] = mem[v + _3798 + 32]
                v = v + 32
                continue 
            if ceil32(_3801) > _3801:
                mem[_3801 + ceil32(_3181) + u + 192] = 0
            idx = idx + 1
            s = s + 32
            t = t + 32
            u = ceil32(_3801) + ceil32(_3181) + u + 192
            continue 
        return memory
          from mem[64]
           len u - mem[64]
    mem[64] = (32 * arg1.length) + 512
    mem[(32 * arg1.length) + 384] = 0
    mem[(32 * arg1.length) + 416] = 0
    mem[(32 * arg1.length) + 448] = 96
    mem[(32 * arg1.length) + 480] = 96
    mem[var25002] = var25001
    if not var25003 - 1:
        idx = 0
        while idx < arg1.length:
            _3778 = mem[64]
            mem[64] = mem[64] + 128
            mem[_3778] = 0
            mem[_3778 + 32] = 0
            mem[_3778 + 64] = 96
            mem[_3778 + 96] = 96
            mem[0] = cd[((32 * idx) + arg1 + 36)]
            mem[32] = 302
            _3796 = mem[64]
            mem[64] = mem[64] + 128
            mem[_3796] = stor302[cd[((32 * idx) + arg1 + 36)]].field_0
            mem[_3796 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]].field_256
            if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                    revert with 0, 34
                _3812 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) + 32
                mem[_3812] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_3796 + 64] = _3812
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _3838 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_3838] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_3838 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3838 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3838 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3838 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_3838 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3838 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3838 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3838 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_3796 + 96] = _3838
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _3842 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_3842] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_3842 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3842 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3842 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3842 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_3842 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3842 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3842 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3842 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_3796 + 96] = _3842
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_3812 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_3796 + 64] = _3812
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _3847 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_3847] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3847 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3847 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3847 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3847 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3847 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3847 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3847 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3847 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _3847
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _3852 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_3852] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3852 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3852 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3852 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3852 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3852 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3852 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3852 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3852 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _3852
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_3812 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _3812 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _3812 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_3796 + 64] = _3812
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _4323 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_4323] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4323 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4323 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4323 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4323 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4323 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4323 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4323 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4323 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _4323
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _4330 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_4330] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4330 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4330 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4330 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4330 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4330 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4330 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4330 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4330 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _4330
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_3796 + 64] = _3812
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _3843 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_3843] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_3843 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3843 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3843 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3843 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_3843 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3843 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3843 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3843 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_3796 + 96] = _3843
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _3848 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_3848] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_3848 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3848 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3848 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3848 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_3848 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3848 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3848 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3848 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_3796 + 96] = _3848
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_3812 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_3796 + 64] = _3812
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _3853 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_3853] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3853 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3853 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3853 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3853 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3853 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3853 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3853 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3853 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _3853
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _3860 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_3860] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3860 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3860 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3860 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3860 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3860 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3860 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3860 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3860 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _3860
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_3812 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _3812 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _3812 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_3796 + 64] = _3812
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _4324 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_4324] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4324 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4324 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4324 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4324 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4324 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4324 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4324 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4324 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _4324
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _4331 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_4331] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4331 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4331 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4331 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4331 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4331 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4331 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4331 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4331 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _4331
            else:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                    revert with 0, 34
                _3816 = mem[64]
                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_513) + 32
                mem[_3816] = stor302[cd[((32 * idx) + arg1 + 36)]].field_513
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_3796 + 64] = _3816
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _3844 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_3844] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_3844 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3844 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3844 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3844 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_3844 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3844 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3844 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3844 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_3796 + 96] = _3844
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _3849 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_3849] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_3849 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3849 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3849 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3849 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_3849 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3849 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3849 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3849 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_3796 + 96] = _3849
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_3816 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_3796 + 64] = _3816
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _3854 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_3854] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3854 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3854 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3854 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3854 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3854 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3854 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3854 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3854 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _3854
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _3861 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_3861] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3861 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3861 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3861 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3861 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3861 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3861 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3861 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3861 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _3861
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_3816 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _3816 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _3816 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_3796 + 64] = _3816
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _4325 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_4325] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4325 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4325 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4325 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4325 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4325 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4325 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4325 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4325 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _4325
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _4332 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_4332] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4332 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4332 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4332 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4332 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4332 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4332 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4332 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4332 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _4332
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_3796 + 64] = _3816
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _3850 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_3850] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_3850 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3850 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3850 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3850 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_3850 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3850 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3850 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3850 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_3796 + 96] = _3850
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _3855 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_3855] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_3855 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3855 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3855 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3855 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_3855 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_3855 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _3855 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _3855 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_3796 + 96] = _3855
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_3816 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_3796 + 64] = _3816
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _3862 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_3862] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3862 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3862 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3862 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3862 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3862 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3862 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3862 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3862 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _3862
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _3869 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_3869] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_3869 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3869 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3869 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3869 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_3869 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_3869 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _3869 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _3869 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _3869
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_3816 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _3816 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _3816 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_3796 + 64] = _3816
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _4326 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_4326] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4326 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4326 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4326 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4326 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4326 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4326 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4326 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4326 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _4326
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _4333 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_4333] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4333 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4333 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4333 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4333 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4333 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4333 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4333 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4333 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_3796 + 96] = _4333
            if idx >= mem[96]:
                revert with 0, 50
            mem[(32 * idx) + 128] = _3796
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _3776 = mem[64]
        mem[mem[64]] = 32
        _3777 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + 64
        u = mem[64] + (32 * mem[96]) + 64
        while idx < _3777:
            mem[t] = u + -_3776 - 64
            _4279 = mem[s]
            mem[u] = mem[mem[s]]
            mem[u + 32] = mem[_4279 + 32]
            _4285 = mem[_4279 + 64]
            mem[u + 64] = 128
            _4286 = mem[_4285]
            mem[u + 128] = mem[_4285]
            v = 0
            while v < _4286:
                mem[v + u + 160] = mem[v + _4285 + 32]
                v = v + 32
                continue 
            if ceil32(_4286) <= _4286:
                _4902 = mem[_4279 + 96]
                mem[u + 96] = ceil32(_4286) + 160
                _4905 = mem[_4902]
                mem[ceil32(_4286) + u + 160] = mem[_4902]
                v = 0
                while v < _4905:
                    mem[v + ceil32(_4286) + u + 192] = mem[v + _4902 + 32]
                    v = v + 32
                    continue 
                if ceil32(_4905) > _4905:
                    mem[_4905 + ceil32(_4286) + u + 192] = 0
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_4905) + ceil32(_4286) + u + 192
                continue 
            mem[_4286 + u + 160] = 0
            _4903 = mem[_4279 + 96]
            mem[u + 96] = ceil32(_4286) + 160
            _4906 = mem[_4903]
            mem[ceil32(_4286) + u + 160] = mem[_4903]
            v = 0
            while v < _4906:
                mem[v + ceil32(_4286) + u + 192] = mem[v + _4903 + 32]
                v = v + 32
                continue 
            if ceil32(_4906) > _4906:
                mem[_4906 + ceil32(_4286) + u + 192] = 0
            idx = idx + 1
            s = s + 32
            t = t + 32
            u = ceil32(_4906) + ceil32(_4286) + u + 192
            continue 
        return memory
          from mem[64]
           len u - mem[64]
    mem[64] = (32 * arg1.length) + 640
    mem[(32 * arg1.length) + 512] = 0
    mem[(32 * arg1.length) + 544] = 0
    mem[(32 * arg1.length) + 576] = 96
    mem[(32 * arg1.length) + 608] = 96
    mem[var29002] = var29001
    if not var29003 - 1:
        idx = 0
        while idx < arg1.length:
            _4883 = mem[64]
            mem[64] = mem[64] + 128
            mem[_4883] = 0
            mem[_4883 + 32] = 0
            mem[_4883 + 64] = 96
            mem[_4883 + 96] = 96
            mem[0] = cd[((32 * idx) + arg1 + 36)]
            mem[32] = 302
            _4901 = mem[64]
            mem[64] = mem[64] + 128
            mem[_4901] = stor302[cd[((32 * idx) + arg1 + 36)]].field_0
            mem[_4901 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]].field_256
            if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                    revert with 0, 34
                _4917 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) + 32
                mem[_4917] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_4901 + 64] = _4917
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _4943 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_4943] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_4943 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4943 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4943 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4943 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_4943 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4943 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4943 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4943 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_4901 + 96] = _4943
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _4947 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_4947] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_4947 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4947 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4947 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4947 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_4947 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4947 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4947 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4947 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_4901 + 96] = _4947
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_4917 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_4901 + 64] = _4917
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _4952 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_4952] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4952 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4952 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4952 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4952 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4952 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4952 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4952 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4952 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _4952
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _4957 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_4957] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4957 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4957 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4957 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4957 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4957 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4957 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4957 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4957 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _4957
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_4917 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _4917 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _4917 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_4901 + 64] = _4917
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _5428 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_5428] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_5428 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5428 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5428 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5428 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_5428 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5428 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5428 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5428 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _5428
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _5435 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_5435] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_5435 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5435 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5435 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5435 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_5435 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5435 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5435 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5435 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _5435
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_4901 + 64] = _4917
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _4948 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_4948] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_4948 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4948 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4948 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4948 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_4948 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4948 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4948 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4948 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_4901 + 96] = _4948
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _4953 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_4953] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_4953 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4953 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4953 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4953 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_4953 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4953 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4953 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4953 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_4901 + 96] = _4953
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_4917 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_4901 + 64] = _4917
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _4958 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_4958] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4958 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4958 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4958 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4958 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4958 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4958 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4958 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4958 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _4958
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _4965 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_4965] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4965 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4965 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4965 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4965 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4965 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4965 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4965 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4965 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _4965
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_4917 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _4917 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _4917 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_4901 + 64] = _4917
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _5429 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_5429] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_5429 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5429 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5429 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5429 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_5429 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5429 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5429 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5429 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _5429
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _5436 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_5436] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_5436 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5436 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5436 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5436 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_5436 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5436 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5436 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5436 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _5436
            else:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                    revert with 0, 34
                _4921 = mem[64]
                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_513) + 32
                mem[_4921] = stor302[cd[((32 * idx) + arg1 + 36)]].field_513
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_4901 + 64] = _4921
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _4949 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_4949] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_4949 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4949 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4949 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4949 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_4949 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4949 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4949 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4949 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_4901 + 96] = _4949
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _4954 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_4954] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_4954 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4954 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4954 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4954 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_4954 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4954 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4954 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4954 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_4901 + 96] = _4954
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_4921 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_4901 + 64] = _4921
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _4959 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_4959] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4959 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4959 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4959 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4959 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4959 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4959 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4959 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4959 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _4959
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _4966 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_4966] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4966 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4966 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4966 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4966 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4966 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4966 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4966 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4966 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _4966
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_4921 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _4921 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _4921 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_4901 + 64] = _4921
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _5430 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_5430] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_5430 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5430 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5430 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5430 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_5430 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5430 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5430 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5430 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _5430
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _5437 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_5437] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_5437 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5437 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5437 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5437 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_5437 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5437 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5437 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5437 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _5437
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_4901 + 64] = _4921
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _4955 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_4955] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_4955 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4955 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4955 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4955 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_4955 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4955 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4955 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4955 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_4901 + 96] = _4955
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _4960 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_4960] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_4960 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4960 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4960 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4960 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_4960 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_4960 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _4960 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _4960 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_4901 + 96] = _4960
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_4921 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_4901 + 64] = _4921
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _4967 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_4967] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4967 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4967 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4967 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4967 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4967 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4967 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4967 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4967 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _4967
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _4974 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_4974] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_4974 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4974 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4974 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4974 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_4974 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_4974 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _4974 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _4974 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _4974
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_4921 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _4921 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _4921 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_4901 + 64] = _4921
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _5431 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_5431] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_5431 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5431 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5431 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5431 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_5431 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5431 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5431 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5431 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _5431
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _5438 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_5438] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_5438 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5438 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5438 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5438 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_5438 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_5438 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _5438 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _5438 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_4901 + 96] = _5438
            if idx >= mem[96]:
                revert with 0, 50
            mem[(32 * idx) + 128] = _4901
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _4881 = mem[64]
        mem[mem[64]] = 32
        _4882 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + 64
        u = mem[64] + (32 * mem[96]) + 64
        while idx < _4882:
            mem[t] = u + -_4881 - 64
            _5384 = mem[s]
            mem[u] = mem[mem[s]]
            mem[u + 32] = mem[_5384 + 32]
            _5390 = mem[_5384 + 64]
            mem[u + 64] = 128
            _5391 = mem[_5390]
            mem[u + 128] = mem[_5390]
            v = 0
            while v < _5391:
                mem[v + u + 160] = mem[v + _5390 + 32]
                v = v + 32
                continue 
            if ceil32(_5391) <= _5391:
                _6007 = mem[_5384 + 96]
                mem[u + 96] = ceil32(_5391) + 160
                _6010 = mem[_6007]
                mem[ceil32(_5391) + u + 160] = mem[_6007]
                v = 0
                while v < _6010:
                    mem[v + ceil32(_5391) + u + 192] = mem[v + _6007 + 32]
                    v = v + 32
                    continue 
                if ceil32(_6010) > _6010:
                    mem[_6010 + ceil32(_5391) + u + 192] = 0
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_6010) + ceil32(_5391) + u + 192
                continue 
            mem[_5391 + u + 160] = 0
            _6008 = mem[_5384 + 96]
            mem[u + 96] = ceil32(_5391) + 160
            _6011 = mem[_6008]
            mem[ceil32(_5391) + u + 160] = mem[_6008]
            v = 0
            while v < _6011:
                mem[v + ceil32(_5391) + u + 192] = mem[v + _6008 + 32]
                v = v + 32
                continue 
            if ceil32(_6011) > _6011:
                mem[_6011 + ceil32(_5391) + u + 192] = 0
            idx = idx + 1
            s = s + 32
            t = t + 32
            u = ceil32(_6011) + ceil32(_5391) + u + 192
            continue 
        return memory
          from mem[64]
           len u - mem[64]
    mem[64] = (32 * arg1.length) + 768
    mem[(32 * arg1.length) + 640] = 0
    mem[(32 * arg1.length) + 672] = 0
    mem[(32 * arg1.length) + 704] = 96
    mem[(32 * arg1.length) + 736] = 96
    mem[var33002] = var33001
    if not var33003 - 1:
        idx = 0
        while idx < arg1.length:
            _5988 = mem[64]
            mem[64] = mem[64] + 128
            mem[_5988] = 0
            mem[_5988 + 32] = 0
            mem[_5988 + 64] = 96
            mem[_5988 + 96] = 96
            mem[0] = cd[((32 * idx) + arg1 + 36)]
            mem[32] = 302
            _6006 = mem[64]
            mem[64] = mem[64] + 128
            mem[_6006] = stor302[cd[((32 * idx) + arg1 + 36)]].field_0
            mem[_6006 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]].field_256
            if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                    revert with 0, 34
                _6022 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) + 32
                mem[_6022] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_6006 + 64] = _6022
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _6048 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_6048] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_6048 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6048 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6048 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6048 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_6048 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6048 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6048 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6048 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_6006 + 96] = _6048
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _6052 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_6052] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_6052 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6052 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6052 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6052 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_6052 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6052 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6052 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6052 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_6006 + 96] = _6052
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_6022 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_6006 + 64] = _6022
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _6057 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_6057] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6057 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6057 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6057 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6057 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6057 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6057 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6057 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6057 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6057
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _6062 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_6062] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6062 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6062 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6062 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6062 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6062 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6062 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6062 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6062 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6062
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_6022 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _6022 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _6022 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_6006 + 64] = _6022
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _6533 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_6533] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6533 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6533 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6533 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6533 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6533 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6533 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6533 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6533 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6533
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _6540 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_6540] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6540 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6540 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6540 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6540 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6540 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6540 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6540 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6540 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6540
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_6006 + 64] = _6022
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _6053 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_6053] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_6053 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6053 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6053 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6053 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_6053 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6053 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6053 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6053 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_6006 + 96] = _6053
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _6058 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_6058] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_6058 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6058 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6058 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6058 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_6058 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6058 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6058 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6058 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_6006 + 96] = _6058
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_6022 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_6006 + 64] = _6022
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _6063 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_6063] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6063 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6063 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6063 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6063 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6063 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6063 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6063 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6063 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6063
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _6070 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_6070] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6070 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6070 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6070 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6070 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6070 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6070 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6070 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6070 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6070
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_6022 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _6022 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _6022 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_6006 + 64] = _6022
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _6534 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_6534] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6534 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6534 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6534 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6534 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6534 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6534 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6534 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6534 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6534
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _6541 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_6541] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6541 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6541 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6541 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6541 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6541 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6541 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6541 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6541 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6541
            else:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                    revert with 0, 34
                _6026 = mem[64]
                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_513) + 32
                mem[_6026] = stor302[cd[((32 * idx) + arg1 + 36)]].field_513
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_6006 + 64] = _6026
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _6054 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_6054] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_6054 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6054 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6054 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6054 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_6054 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6054 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6054 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6054 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_6006 + 96] = _6054
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _6059 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_6059] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_6059 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6059 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6059 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6059 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_6059 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6059 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6059 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6059 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_6006 + 96] = _6059
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_6026 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_6006 + 64] = _6026
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _6064 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_6064] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6064 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6064 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6064 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6064 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6064 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6064 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6064 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6064 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6064
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _6071 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_6071] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6071 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6071 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6071 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6071 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6071 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6071 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6071 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6071 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6071
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_6026 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _6026 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _6026 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_6006 + 64] = _6026
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _6535 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_6535] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6535 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6535 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6535 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6535 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6535 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6535 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6535 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6535 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6535
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _6542 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_6542] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6542 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6542 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6542 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6542 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6542 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6542 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6542 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6542 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6542
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_6006 + 64] = _6026
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _6060 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_6060] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_6060 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6060 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6060 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6060 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_6060 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6060 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6060 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6060 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_6006 + 96] = _6060
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _6065 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_6065] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_6065 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6065 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6065 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6065 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_6065 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_6065 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _6065 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _6065 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_6006 + 96] = _6065
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_6026 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_6006 + 64] = _6026
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _6072 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_6072] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6072 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6072 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6072 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6072 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6072 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6072 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6072 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6072 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6072
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _6079 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_6079] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6079 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6079 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6079 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6079 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6079 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6079 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6079 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6079 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6079
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_6026 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _6026 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _6026 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_6006 + 64] = _6026
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _6536 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_6536] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6536 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6536 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6536 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6536 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6536 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6536 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6536 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6536 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6536
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _6543 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_6543] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_6543 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6543 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6543 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6543 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_6543 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_6543 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _6543 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _6543 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_6006 + 96] = _6543
            if idx >= mem[96]:
                revert with 0, 50
            mem[(32 * idx) + 128] = _6006
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _5986 = mem[64]
        mem[mem[64]] = 32
        _5987 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + 64
        u = mem[64] + (32 * mem[96]) + 64
        while idx < _5987:
            mem[t] = u + -_5986 - 64
            _6489 = mem[s]
            mem[u] = mem[mem[s]]
            mem[u + 32] = mem[_6489 + 32]
            _6495 = mem[_6489 + 64]
            mem[u + 64] = 128
            _6496 = mem[_6495]
            mem[u + 128] = mem[_6495]
            v = 0
            while v < _6496:
                mem[v + u + 160] = mem[v + _6495 + 32]
                v = v + 32
                continue 
            if ceil32(_6496) <= _6496:
                _7112 = mem[_6489 + 96]
                mem[u + 96] = ceil32(_6496) + 160
                _7115 = mem[_7112]
                mem[ceil32(_6496) + u + 160] = mem[_7112]
                v = 0
                while v < _7115:
                    mem[v + ceil32(_6496) + u + 192] = mem[v + _7112 + 32]
                    v = v + 32
                    continue 
                if ceil32(_7115) > _7115:
                    mem[_7115 + ceil32(_6496) + u + 192] = 0
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_7115) + ceil32(_6496) + u + 192
                continue 
            mem[_6496 + u + 160] = 0
            _7113 = mem[_6489 + 96]
            mem[u + 96] = ceil32(_6496) + 160
            _7116 = mem[_7113]
            mem[ceil32(_6496) + u + 160] = mem[_7113]
            v = 0
            while v < _7116:
                mem[v + ceil32(_6496) + u + 192] = mem[v + _7113 + 32]
                v = v + 32
                continue 
            if ceil32(_7116) > _7116:
                mem[_7116 + ceil32(_6496) + u + 192] = 0
            idx = idx + 1
            s = s + 32
            t = t + 32
            u = ceil32(_7116) + ceil32(_6496) + u + 192
            continue 
        return memory
          from mem[64]
           len u - mem[64]
    mem[64] = (32 * arg1.length) + 896
    mem[(32 * arg1.length) + 768] = 0
    mem[(32 * arg1.length) + 800] = 0
    mem[(32 * arg1.length) + 832] = 96
    mem[(32 * arg1.length) + 864] = 96
    mem[var37002] = var37001
    if not var37003 - 1:
        idx = 0
        while idx < arg1.length:
            _7093 = mem[64]
            mem[64] = mem[64] + 128
            mem[_7093] = 0
            mem[_7093 + 32] = 0
            mem[_7093 + 64] = 96
            mem[_7093 + 96] = 96
            mem[0] = cd[((32 * idx) + arg1 + 36)]
            mem[32] = 302
            _7111 = mem[64]
            mem[64] = mem[64] + 128
            mem[_7111] = stor302[cd[((32 * idx) + arg1 + 36)]].field_0
            mem[_7111 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]].field_256
            if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                    revert with 0, 34
                _7127 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) + 32
                mem[_7127] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_7111 + 64] = _7127
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _7153 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_7153] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_7153 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7153 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7153 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7153 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_7153 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7153 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7153 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7153 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_7111 + 96] = _7153
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _7157 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_7157] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_7157 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7157 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7157 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7157 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_7157 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7157 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7157 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7157 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_7111 + 96] = _7157
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_7127 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_7111 + 64] = _7127
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _7162 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_7162] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7162 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7162 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7162 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7162 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7162 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7162 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7162 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7162 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7162
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _7167 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_7167] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7167 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7167 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7167 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7167 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7167 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7167 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7167 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7167 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7167
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_7127 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _7127 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _7127 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_7111 + 64] = _7127
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _7638 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_7638] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7638 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7638 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7638 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7638 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7638 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7638 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7638 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7638 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7638
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _7645 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_7645] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7645 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7645 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7645 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7645 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7645 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7645 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7645 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7645 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7645
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_7111 + 64] = _7127
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _7158 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_7158] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_7158 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7158 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7158 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7158 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_7158 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7158 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7158 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7158 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_7111 + 96] = _7158
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _7163 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_7163] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_7163 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7163 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7163 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7163 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_7163 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7163 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7163 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7163 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_7111 + 96] = _7163
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_7127 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_7111 + 64] = _7127
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _7168 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_7168] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7168 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7168 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7168 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7168 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7168 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7168 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7168 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7168 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7168
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _7175 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_7175] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7175 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7175 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7175 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7175 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7175 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7175 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7175 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7175 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7175
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_7127 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _7127 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _7127 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_7111 + 64] = _7127
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _7639 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_7639] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7639 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7639 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7639 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7639 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7639 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7639 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7639 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7639 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7639
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _7646 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_7646] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7646 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7646 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7646 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7646 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7646 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7646 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7646 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7646 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7646
            else:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                    revert with 0, 34
                _7131 = mem[64]
                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_513) + 32
                mem[_7131] = stor302[cd[((32 * idx) + arg1 + 36)]].field_513
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_7111 + 64] = _7131
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _7159 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_7159] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_7159 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7159 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7159 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7159 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_7159 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7159 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7159 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7159 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_7111 + 96] = _7159
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _7164 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_7164] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_7164 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7164 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7164 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7164 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_7164 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7164 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7164 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7164 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_7111 + 96] = _7164
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_7131 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_7111 + 64] = _7131
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _7169 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_7169] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7169 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7169 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7169 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7169 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7169 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7169 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7169 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7169 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7169
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _7176 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_7176] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7176 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7176 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7176 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7176 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7176 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7176 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7176 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7176 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7176
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_7131 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _7131 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _7131 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_7111 + 64] = _7131
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _7640 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_7640] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7640 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7640 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7640 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7640 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7640 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7640 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7640 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7640 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7640
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _7647 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_7647] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7647 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7647 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7647 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7647 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7647 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7647 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7647 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7647 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7647
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_7111 + 64] = _7131
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _7165 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_7165] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_7165 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7165 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7165 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7165 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_7165 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7165 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7165 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7165 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_7111 + 96] = _7165
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _7170 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_7170] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_7170 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7170 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7170 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7170 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_7170 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_7170 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _7170 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _7170 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_7111 + 96] = _7170
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_7131 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_7111 + 64] = _7131
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _7177 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_7177] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7177 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7177 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7177 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7177 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7177 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7177 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7177 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7177 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7177
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _7184 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_7184] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7184 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7184 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7184 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7184 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7184 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7184 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7184 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7184 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7184
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_7131 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _7131 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _7131 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_7111 + 64] = _7131
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _7641 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_7641] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7641 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7641 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7641 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7641 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7641 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7641 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7641 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7641 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7641
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _7648 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_7648] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_7648 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7648 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7648 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7648 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_7648 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_7648 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _7648 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _7648 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_7111 + 96] = _7648
            if idx >= mem[96]:
                revert with 0, 50
            mem[(32 * idx) + 128] = _7111
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _7091 = mem[64]
        mem[mem[64]] = 32
        _7092 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + 64
        u = mem[64] + (32 * mem[96]) + 64
        while idx < _7092:
            mem[t] = u + -_7091 - 64
            _7594 = mem[s]
            mem[u] = mem[mem[s]]
            mem[u + 32] = mem[_7594 + 32]
            _7600 = mem[_7594 + 64]
            mem[u + 64] = 128
            _7601 = mem[_7600]
            mem[u + 128] = mem[_7600]
            v = 0
            while v < _7601:
                mem[v + u + 160] = mem[v + _7600 + 32]
                v = v + 32
                continue 
            if ceil32(_7601) <= _7601:
                _8217 = mem[_7594 + 96]
                mem[u + 96] = ceil32(_7601) + 160
                _8220 = mem[_8217]
                mem[ceil32(_7601) + u + 160] = mem[_8217]
                v = 0
                while v < _8220:
                    mem[v + ceil32(_7601) + u + 192] = mem[v + _8217 + 32]
                    v = v + 32
                    continue 
                if ceil32(_8220) > _8220:
                    mem[_8220 + ceil32(_7601) + u + 192] = 0
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_8220) + ceil32(_7601) + u + 192
                continue 
            mem[_7601 + u + 160] = 0
            _8218 = mem[_7594 + 96]
            mem[u + 96] = ceil32(_7601) + 160
            _8221 = mem[_8218]
            mem[ceil32(_7601) + u + 160] = mem[_8218]
            v = 0
            while v < _8221:
                mem[v + ceil32(_7601) + u + 192] = mem[v + _8218 + 32]
                v = v + 32
                continue 
            if ceil32(_8221) > _8221:
                mem[_8221 + ceil32(_7601) + u + 192] = 0
            idx = idx + 1
            s = s + 32
            t = t + 32
            u = ceil32(_8221) + ceil32(_7601) + u + 192
            continue 
        return memory
          from mem[64]
           len u - mem[64]
    mem[64] = (32 * arg1.length) + 1024
    mem[(32 * arg1.length) + 896] = 0
    mem[(32 * arg1.length) + 928] = 0
    mem[(32 * arg1.length) + 960] = 96
    mem[(32 * arg1.length) + 992] = 96
    mem[var41002] = var41001
    if not var41003 - 1:
        idx = 0
        while idx < arg1.length:
            _8198 = mem[64]
            mem[64] = mem[64] + 128
            mem[_8198] = 0
            mem[_8198 + 32] = 0
            mem[_8198 + 64] = 96
            mem[_8198 + 96] = 96
            mem[0] = cd[((32 * idx) + arg1 + 36)]
            mem[32] = 302
            _8216 = mem[64]
            mem[64] = mem[64] + 128
            mem[_8216] = stor302[cd[((32 * idx) + arg1 + 36)]].field_0
            mem[_8216 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]].field_256
            if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                    revert with 0, 34
                _8232 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) + 32
                mem[_8232] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_8216 + 64] = _8232
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _8258 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_8258] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_8258 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8258 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8258 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8258 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_8258 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8258 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8258 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8258 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_8216 + 96] = _8258
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _8262 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_8262] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_8262 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8262 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8262 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8262 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_8262 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8262 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8262 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8262 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_8216 + 96] = _8262
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_8232 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_8216 + 64] = _8232
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _8267 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_8267] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8267 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8267 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8267 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8267 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8267 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8267 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8267 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8267 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8267
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _8272 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_8272] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8272 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8272 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8272 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8272 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8272 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8272 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8272 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8272 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8272
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_8232 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _8232 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _8232 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_8216 + 64] = _8232
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _8743 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_8743] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8743 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8743 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8743 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8743 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8743 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8743 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8743 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8743 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8743
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _8750 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_8750] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8750 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8750 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8750 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8750 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8750 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8750 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8750 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8750 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8750
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_8216 + 64] = _8232
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _8263 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_8263] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_8263 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8263 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8263 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8263 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_8263 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8263 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8263 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8263 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_8216 + 96] = _8263
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _8268 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_8268] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_8268 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8268 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8268 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8268 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_8268 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8268 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8268 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8268 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_8216 + 96] = _8268
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_8232 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_8216 + 64] = _8232
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _8273 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_8273] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8273 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8273 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8273 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8273 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8273 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8273 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8273 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8273 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8273
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _8280 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_8280] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8280 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8280 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8280 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8280 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8280 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8280 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8280 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8280 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8280
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_8232 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _8232 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _8232 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_8216 + 64] = _8232
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _8744 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_8744] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8744 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8744 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8744 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8744 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8744 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8744 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8744 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8744 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8744
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _8751 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_8751] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8751 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8751 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8751 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8751 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8751 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8751 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8751 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8751 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8751
            else:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                    revert with 0, 34
                _8236 = mem[64]
                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_513) + 32
                mem[_8236] = stor302[cd[((32 * idx) + arg1 + 36)]].field_513
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_8216 + 64] = _8236
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _8264 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_8264] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_8264 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8264 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8264 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8264 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_8264 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8264 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8264 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8264 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_8216 + 96] = _8264
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _8269 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_8269] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_8269 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8269 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8269 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8269 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_8269 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8269 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8269 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8269 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_8216 + 96] = _8269
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_8236 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_8216 + 64] = _8236
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _8274 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_8274] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8274 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8274 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8274 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8274 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8274 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8274 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8274 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8274 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8274
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _8281 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_8281] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8281 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8281 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8281 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8281 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8281 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8281 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8281 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8281 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8281
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_8236 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _8236 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _8236 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_8216 + 64] = _8236
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _8745 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_8745] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8745 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8745 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8745 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8745 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8745 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8745 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8745 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8745 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8745
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _8752 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_8752] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8752 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8752 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8752 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8752 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8752 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8752 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8752 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8752 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8752
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_8216 + 64] = _8236
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _8270 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_8270] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_8270 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8270 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8270 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8270 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_8270 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8270 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8270 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8270 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_8216 + 96] = _8270
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _8275 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_8275] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_8275 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8275 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8275 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8275 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_8275 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_8275 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _8275 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _8275 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_8216 + 96] = _8275
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_8236 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_8216 + 64] = _8236
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _8282 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_8282] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8282 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8282 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8282 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8282 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8282 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8282 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8282 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8282 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8282
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _8289 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_8289] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8289 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8289 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8289 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8289 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8289 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8289 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8289 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8289 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8289
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_8236 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _8236 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _8236 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_8216 + 64] = _8236
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _8746 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_8746] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8746 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8746 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8746 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8746 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8746 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8746 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8746 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8746 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8746
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _8753 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_8753] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_8753 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8753 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8753 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8753 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_8753 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_8753 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _8753 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _8753 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_8216 + 96] = _8753
            if idx >= mem[96]:
                revert with 0, 50
            mem[(32 * idx) + 128] = _8216
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _8196 = mem[64]
        mem[mem[64]] = 32
        _8197 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + 64
        u = mem[64] + (32 * mem[96]) + 64
        while idx < _8197:
            mem[t] = u + -_8196 - 64
            _8699 = mem[s]
            mem[u] = mem[mem[s]]
            mem[u + 32] = mem[_8699 + 32]
            _8705 = mem[_8699 + 64]
            mem[u + 64] = 128
            _8706 = mem[_8705]
            mem[u + 128] = mem[_8705]
            v = 0
            while v < _8706:
                mem[v + u + 160] = mem[v + _8705 + 32]
                v = v + 32
                continue 
            if ceil32(_8706) <= _8706:
                _9322 = mem[_8699 + 96]
                mem[u + 96] = ceil32(_8706) + 160
                _9325 = mem[_9322]
                mem[ceil32(_8706) + u + 160] = mem[_9322]
                v = 0
                while v < _9325:
                    mem[v + ceil32(_8706) + u + 192] = mem[v + _9322 + 32]
                    v = v + 32
                    continue 
                if ceil32(_9325) > _9325:
                    mem[_9325 + ceil32(_8706) + u + 192] = 0
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_9325) + ceil32(_8706) + u + 192
                continue 
            mem[_8706 + u + 160] = 0
            _9323 = mem[_8699 + 96]
            mem[u + 96] = ceil32(_8706) + 160
            _9326 = mem[_9323]
            mem[ceil32(_8706) + u + 160] = mem[_9323]
            v = 0
            while v < _9326:
                mem[v + ceil32(_8706) + u + 192] = mem[v + _9323 + 32]
                v = v + 32
                continue 
            if ceil32(_9326) > _9326:
                mem[_9326 + ceil32(_8706) + u + 192] = 0
            idx = idx + 1
            s = s + 32
            t = t + 32
            u = ceil32(_9326) + ceil32(_8706) + u + 192
            continue 
        return memory
          from mem[64]
           len u - mem[64]
    mem[64] = (32 * arg1.length) + 1152
    mem[(32 * arg1.length) + 1024] = 0
    mem[(32 * arg1.length) + 1056] = 0
    mem[(32 * arg1.length) + 1088] = 96
    mem[(32 * arg1.length) + 1120] = 96
    mem[var45002] = var45001
    if var45003 - 1:
        mem[64] = (32 * arg1.length) + 1280
        mem[var49002] = var49001
        if not var49003 - 1:
            idx = 0
            while idx < arg1.length:
                _10408 = mem[64]
                mem[64] = mem[64] + 128
                mem[_10408] = 0
                mem[_10408 + 32] = 0
                mem[_10408 + 64] = 96
                mem[_10408 + 96] = 96
                mem[0] = cd[((32 * idx) + arg1 + 36)]
                mem[32] = 302
                _10426 = mem[64]
                mem[64] = mem[64] + 128
                mem[_10426] = stor302[cd[((32 * idx) + arg1 + 36)]].field_0
                mem[_10426 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]].field_256
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    _10442 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) + 32
                    mem[_10442] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                            mem[_10426 + 64] = _10442
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _10468 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_10468] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        mem[_10426 + 96] = _10468
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        # nil
                                    else:
                                        mem[_10468 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10468
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_10426 + 96] = _10468
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        # nil
                                    else:
                                        mem[_10468 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10468
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _10472 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_10472] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        mem[_10426 + 96] = _10472
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        # nil
                                    else:
                                        mem[_10472 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10472
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_10426 + 96] = _10472
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        # nil
                                    else:
                                        mem[_10472 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10472
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                                # nil
                            else:
                                mem[_10442 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                                mem[_10426 + 64] = _10442
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    _10477 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                    mem[_10477] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                            revert with 0, 34
                                        if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                            mem[_10426 + 96] = _10477
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            # nil
                                        else:
                                            mem[_10477 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10477
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                            revert with 0, 34
                                        if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_10426 + 96] = _10477
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            # nil
                                        else:
                                            mem[_10477 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10477
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    _10482 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                    mem[_10482] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                            revert with 0, 34
                                        if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                            mem[_10426 + 96] = _10482
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            # nil
                                        else:
                                            mem[_10482 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10482
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                            revert with 0, 34
                                        if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_10426 + 96] = _10482
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            # nil
                                        else:
                                            mem[_10482 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10482
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                    else:
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                            revert with 0, 34
                        if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_10426 + 64] = _10442
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _10473 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_10473] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        mem[_10426 + 96] = _10473
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        # nil
                                    else:
                                        mem[_10473 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10473
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_10426 + 96] = _10473
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        # nil
                                    else:
                                        mem[_10473 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10473
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _10478 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_10478] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        mem[_10426 + 96] = _10478
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        # nil
                                    else:
                                        mem[_10478 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10478
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_10426 + 96] = _10478
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        # nil
                                    else:
                                        mem[_10478 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10478
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                                # nil
                            else:
                                mem[_10442 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                                mem[_10426 + 64] = _10442
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    _10483 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                    mem[_10483] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                            revert with 0, 34
                                        if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                            mem[_10426 + 96] = _10483
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            # nil
                                        else:
                                            mem[_10483 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10483
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                            revert with 0, 34
                                        if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_10426 + 96] = _10483
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            # nil
                                        else:
                                            mem[_10483 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10483
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    _10490 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                    mem[_10490] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                            revert with 0, 34
                                        if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                            mem[_10426 + 96] = _10490
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            # nil
                                        else:
                                            mem[_10490 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10490
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                            revert with 0, 34
                                        if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_10426 + 96] = _10490
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            # nil
                                        else:
                                            mem[_10490 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10490
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    _10446 = mem[64]
                    mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_513) + 32
                    mem[_10446] = stor302[cd[((32 * idx) + arg1 + 36)]].field_513
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                            revert with 0, 34
                        if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                            mem[_10426 + 64] = _10446
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _10474 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_10474] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        mem[_10426 + 96] = _10474
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        # nil
                                    else:
                                        mem[_10474 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10474
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_10426 + 96] = _10474
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        # nil
                                    else:
                                        mem[_10474 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10474
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _10479 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_10479] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        mem[_10426 + 96] = _10479
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        # nil
                                    else:
                                        mem[_10479 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10479
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_10426 + 96] = _10479
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        # nil
                                    else:
                                        mem[_10479 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10479
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                                # nil
                            else:
                                mem[_10446 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                                mem[_10426 + 64] = _10446
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    _10484 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                    mem[_10484] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                            revert with 0, 34
                                        if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                            mem[_10426 + 96] = _10484
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            # nil
                                        else:
                                            mem[_10484 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10484
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                            revert with 0, 34
                                        if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_10426 + 96] = _10484
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            # nil
                                        else:
                                            mem[_10484 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10484
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    _10491 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                    mem[_10491] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                            revert with 0, 34
                                        if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                            mem[_10426 + 96] = _10491
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            # nil
                                        else:
                                            mem[_10491 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10491
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                            revert with 0, 34
                                        if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_10426 + 96] = _10491
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            # nil
                                        else:
                                            mem[_10491 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10491
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                    else:
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                            revert with 0, 34
                        if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_10426 + 64] = _10446
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _10480 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_10480] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        mem[_10426 + 96] = _10480
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        # nil
                                    else:
                                        mem[_10480 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10480
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_10426 + 96] = _10480
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        # nil
                                    else:
                                        mem[_10480 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10480
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _10485 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_10485] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        mem[_10426 + 96] = _10485
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        # nil
                                    else:
                                        mem[_10485 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10485
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_10426 + 96] = _10485
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        # nil
                                    else:
                                        mem[_10485 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        mem[_10426 + 96] = _10485
                                        if idx >= mem[96]:
                                            revert with 0, 50
                                        mem[(32 * idx) + 128] = _10426
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                        else:
                            if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                                # nil
                            else:
                                mem[_10446 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                                mem[_10426 + 64] = _10446
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    _10492 = mem[64]
                                    mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                    mem[_10492] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                            revert with 0, 34
                                        if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                            mem[_10426 + 96] = _10492
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            # nil
                                        else:
                                            mem[_10492 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10492
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                            revert with 0, 34
                                        if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_10426 + 96] = _10492
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            # nil
                                        else:
                                            mem[_10492 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10492
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    _10499 = mem[64]
                                    mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                    mem[_10499] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                            revert with 0, 34
                                        if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                            mem[_10426 + 96] = _10499
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            # nil
                                        else:
                                            mem[_10499 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10499
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                            revert with 0, 34
                                        if not stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_10426 + 96] = _10499
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
                                        if 31 < stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            # nil
                                        else:
                                            mem[_10499 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                            mem[_10426 + 96] = _10499
                                            if idx >= mem[96]:
                                                revert with 0, 50
                                            mem[(32 * idx) + 128] = _10426
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            continue 
        # nil
    else:
        idx = 0
        while idx < arg1.length:
            _9303 = mem[64]
            mem[64] = mem[64] + 128
            mem[_9303] = 0
            mem[_9303 + 32] = 0
            mem[_9303 + 64] = 96
            mem[_9303 + 96] = 96
            mem[0] = cd[((32 * idx) + arg1 + 36)]
            mem[32] = 302
            _9321 = mem[64]
            mem[64] = mem[64] + 128
            mem[_9321] = stor302[cd[((32 * idx) + arg1 + 36)]].field_0
            mem[_9321 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]].field_256
            if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                    revert with 0, 34
                _9337 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) + 32
                mem[_9337] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_9321 + 64] = _9337
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _9363 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_9363] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_9363 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9363 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9363 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9363 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_9363 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9363 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9363 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9363 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_9321 + 96] = _9363
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _9367 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_9367] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_9367 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9367 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9367 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9367 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_9367 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9367 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9367 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9367 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_9321 + 96] = _9367
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_9337 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_9321 + 64] = _9337
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _9372 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_9372] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9372 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9372 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9372 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9372 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9372 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9372 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9372 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9372 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9372
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _9377 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_9377] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9377 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9377 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9377 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9377 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9377 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9377 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9377 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9377 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9377
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_9337 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _9337 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _9337 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_9321 + 64] = _9337
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _9848 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_9848] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9848 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9848 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9848 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9848 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9848 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9848 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9848 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9848 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9848
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _9855 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_9855] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9855 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9855 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9855 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9855 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9855 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9855 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9855 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9855 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9855
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_9321 + 64] = _9337
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _9368 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_9368] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_9368 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9368 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9368 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9368 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_9368 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9368 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9368 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9368 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_9321 + 96] = _9368
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _9373 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_9373] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_9373 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9373 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9373 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9373 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_9373 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9373 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9373 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9373 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_9321 + 96] = _9373
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_9337 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_9321 + 64] = _9337
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _9378 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_9378] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9378 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9378 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9378 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9378 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9378 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9378 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9378 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9378 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9378
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _9385 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_9385] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9385 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9385 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9385 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9385 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9385 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9385 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9385 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9385 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9385
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_9337 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _9337 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _9337 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_9321 + 64] = _9337
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _9849 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_9849] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9849 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9849 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9849 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9849 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9849 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9849 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9849 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9849 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9849
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _9856 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_9856] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9856 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9856 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9856 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9856 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9856 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9856 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9856 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9856 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9856
            else:
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                    revert with 0, 34
                _9341 = mem[64]
                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_513) + 32
                mem[_9341] = stor302[cd[((32 * idx) + arg1 + 36)]].field_513
                if stor302[cd[((32 * idx) + arg1 + 36)]].field_512:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5 < 32:
                        revert with 0, 34
                    if not Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_512):
                        mem[_9321 + 64] = _9341
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _9369 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_9369] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_9369 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9369 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9369 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9369 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_9369 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9369 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9369 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9369 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_9321 + 96] = _9369
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _9374 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_9374] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_9374 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9374 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9374 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9374 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_9374 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9374 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9374 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9374 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_9321 + 96] = _9374
                    else:
                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5:
                            mem[_9341 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_9321 + 64] = _9341
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _9379 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_9379] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9379 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9379 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9379 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9379 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9379 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9379 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9379 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9379 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9379
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _9386 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_9386] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9386 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9386 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9386 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9386 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9386 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9386 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9386 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9386 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9386
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_9341 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _9341 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _9341 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_512) * 0.5) > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_9321 + 64] = _9341
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _9850 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_9850] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9850 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9850 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9850 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9850 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9850 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9850 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9850 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9850 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9850
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _9857 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_9857] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9857 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9857 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9857 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9857 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9857 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9857 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9857 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9857 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9857
                else:
                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_512 == stor302[cd[((32 * idx) + arg1 + 36)]].field_513 < 32:
                        revert with 0, 34
                    if not stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                        mem[_9321 + 64] = _9341
                        if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                revert with 0, 34
                            _9375 = mem[64]
                            mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                            mem[_9375] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_9375 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9375 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9375 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9375 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_9375 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9375 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9375 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9375 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_9321 + 96] = _9375
                        else:
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                revert with 0, 34
                            _9380 = mem[64]
                            mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                            mem[_9380] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                    if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                        mem[_9380 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9380 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9380 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9380 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                    if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        mem[_9380 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                    else:
                                        mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                        mem[_9380 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                        s = _9380 + 32
                                        t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                        while _9380 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                            mem[s + 32] = stor1[t]
                                            s = s + 32
                                            t = t + 1
                                            continue 
                            mem[_9321 + 96] = _9380
                    else:
                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_513:
                            mem[_9341 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_520
                            mem[_9321 + 64] = _9341
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _9387 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_9387] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9387 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9387 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9387 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9387 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9387 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9387 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9387 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9387 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9387
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _9394 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_9394] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9394 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9394 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9394 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9394 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9394 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9394 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9394 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9394 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9394
                        else:
                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2
                            mem[_9341 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][2].field_0
                            s = _9341 + 32
                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 2)
                            while _9341 + stor302[cd[((32 * idx) + arg1 + 36)]].field_513 > s:
                                mem[s + 32] = stor1[t]
                                s = s + 32
                                t = t + 1
                                continue 
                            mem[_9321 + 64] = _9341
                            if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                    revert with 0, 34
                                _9851 = mem[64]
                                mem[64] = mem[64] + ceil32(uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) + 32
                                mem[_9851] = uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9851 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9851 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9851 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9851 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9851 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9851 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9851 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9851 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9851
                            else:
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                    revert with 0, 34
                                _9858 = mem[64]
                                mem[64] = mem[64] + ceil32(stor302[cd[((32 * idx) + arg1 + 36)]].field_769) + 32
                                mem[_9858] = stor302[cd[((32 * idx) + arg1 + 36)]].field_769
                                if stor302[cd[((32 * idx) + arg1 + 36)]].field_768:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5 < 32:
                                        revert with 0, 34
                                    if Mask(256, -1, stor302[cd[((32 * idx) + arg1 + 36)]].field_768):
                                        if 31 >= uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5:
                                            mem[_9858 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9858 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9858 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9858 + (uint255(stor302[cd[((32 * idx) + arg1 + 36)]].field_768) * 0.5) > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                else:
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_768 == stor302[cd[((32 * idx) + arg1 + 36)]].field_769 < 32:
                                        revert with 0, 34
                                    if stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                        if 31 >= stor302[cd[((32 * idx) + arg1 + 36)]].field_769:
                                            mem[_9858 + 32] = 256 * stor302[cd[((32 * idx) + arg1 + 36)]].field_776
                                        else:
                                            mem[0] = sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3
                                            mem[_9858 + 32] = stor302[cd[((32 * idx) + arg1 + 36)]][3].field_0
                                            s = _9858 + 32
                                            t = sha3(sha3(cd[((32 * idx) + arg1 + 36)], 302) + 3)
                                            while _9858 + stor302[cd[((32 * idx) + arg1 + 36)]].field_769 > s:
                                                mem[s + 32] = stor1[t]
                                                s = s + 32
                                                t = t + 1
                                                continue 
                                mem[_9321 + 96] = _9858
            if idx >= mem[96]:
                revert with 0, 50
            mem[(32 * idx) + 128] = _9321
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        mem[mem[64] + 32] = mem[96]
        if var70001 >= mem[96]:
            return memory
              from mem[64]
               len var70005 - mem[64]
        mem[var70004] = var70005 + -mem[64] - 64
        _9804 = mem[var70002]
        mem[var70005] = mem[mem[var70002]]
        mem[var70005 + 32] = mem[_9804 + 32]
        _9810 = mem[_9804 + 64]
        mem[var70005 + 64] = 128
        # nil
}



}

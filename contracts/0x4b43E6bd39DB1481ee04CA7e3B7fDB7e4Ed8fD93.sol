contract main {




// =====================  Runtime code  =====================


#
#  - sub_00000003(?)
#  - sub_1299400b(?)
#  - getFeeRewardsStake(address arg1, address arg2, bool arg3)
#  - sub_2596daf4(?)
#  - sub_653be935(?)
#
mapping of uint8 stor0;

function _fallback() payable {
  stop
}

function transferOwner(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if not stor0[msg.sender]:
        revert with 0, 'O'
    stor0[address(arg1)] = 1
    stor0[arg2] = 0
}

function withdrawBase(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not stor0[msg.sender]:
        revert with 0, 'O'
    call msg.sender with:
       value arg1 wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function withdrawWrapped(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not stor0[msg.sender]:
        revert with 0, 'O'
    if not stor0[address(arg2)]:
        revert with 0, 'O'
    require ext_code.size(arg1)
    call arg1.withdraw(uint256 arg1) with:
         gas gas_remaining wei
        args arg3
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    call arg2 with:
       value arg3 wei
         gas 2300 * is_zero(value) wei
}

function sub_bde4e54c(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if not stor0[msg.sender]:
        revert with 0, 'O'
    if not stor0[msg.sender]:
        revert with 0, 'O'
    if not stor0[address(msg.sender)]:
        revert with 0, 'O'
    require ext_code.size(address(arg1))
    call address(arg1).withdraw(uint256 arg1) with:
         gas gas_remaining wei
        args arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    call msg.sender with:
       value arg2 wei
         gas 2300 * is_zero(value) wei
}

function sub_6e636994(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if not stor0[msg.sender]:
        revert with 0, 'O'
    if not stor0[address(arg2)]:
        revert with 0, 'O'
    require ext_code.size(address(arg1))
    call address(arg1).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args address(arg2), arg3
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function addOwners(address[] arg1) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    if 0x1039184e2c81b8be5f57d939c0c42c1bb287d71b != msg.sender:
        revert with 0, 'O'
    idx = 0
    while idx < arg1.length:
        require cd[((32 * idx) + arg1 + 36)] == address(cd[((32 * idx) + arg1 + 36)])
        mem[0] = address(cd[((32 * idx) + arg1 + 36)])
        mem[32] = 0
        stor0[address(cd[((32 * idx) + arg1 + 36)])] = 1
        idx = idx + 1
        continue 
}

function sub_e2da3653(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if not stor0[msg.sender]:
        revert with 0, 'O'
    if not stor0[msg.sender]:
        revert with 0, 'O'
    if not stor0[address(msg.sender)]:
        revert with 0, 'O'
    require ext_code.size(address(arg1))
    call address(arg1).transfer(address arg1, uint256 arg2) with:
         gas gas_remaining wei
        args msg.sender, arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function sub_00007046(?) {
    if 0x4bad9f1a15bd17e78b59e086aa4092a3ce0de5c2 != msg.sender:
        if 0xd966d085127a3bfa686afa4ee0c52dbe4e962ef4 != msg.sender:
            if 0x71e5581ea04d93336fd6d2557c56f5c6ab2bea8 != msg.sender:
                if 0x90f729f31e20c58b93a7092f1e10bdae9cc4d82b != msg.sender:
                    if 0xd794ad6fe0cdfcb15597da157077e6d245479f4a != msg.sender:
                        if 0xb48b978ab606fb6065097a7403e47e58ca464462 != msg.sender:
                            if 0xac1afe8faad8b5a75bd0f7fedeec0e798675ee49 != msg.sender:
                                if 0xc577ccd813957558ea7eca6f14ba9b90c58377c0 != msg.sender:
                                    if 0x60befe4438001c95ec75d09aedfac0dd4c10820b != msg.sender:
                                        revert with 0, 'O'
    staticcall mem[0 len 12], call.data[32 len 20].getReserves() with:
            gas 5000 wei
    if bool(call.data[52 len 1]) == 1:
        if (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[52 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[52 len 1] / 2 * mem[0 len 18], call.data[4 len 14]) >= mem[0 len 18], call.data[18 len 14]:
            call 0xd586e7f844cea2f87f50152665bcbc2c279d8d70.transfer(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args mem[0 len 12], call.data[32 len 20], mem[0 len 18], call.data[4 len 14]
            if bool(call.data[52 len 1]) == 1 == 1:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[52 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[52 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), this.address, 128, 0
            else:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[52 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[52 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), 0, this.address, 128, 0
            require ext_call.success
    else:
        if (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[52 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[52 len 1] / 2 * mem[0 len 18], call.data[4 len 14]) >= mem[0 len 18], call.data[18 len 14]:
            call 0xd586e7f844cea2f87f50152665bcbc2c279d8d70.transfer(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args mem[0 len 12], call.data[32 len 20], mem[0 len 18], call.data[4 len 14]
            if bool(call.data[52 len 1]) == 1 == 1:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[52 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[52 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), this.address, 128, 0
            else:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[52 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[52 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), 0, this.address, 128, 0
            require ext_call.success
}

function sub_0000df2c(?) {
    if 0x4bad9f1a15bd17e78b59e086aa4092a3ce0de5c2 != msg.sender:
        if 0xd966d085127a3bfa686afa4ee0c52dbe4e962ef4 != msg.sender:
            if 0x71e5581ea04d93336fd6d2557c56f5c6ab2bea8 != msg.sender:
                if 0x90f729f31e20c58b93a7092f1e10bdae9cc4d82b != msg.sender:
                    if 0xd794ad6fe0cdfcb15597da157077e6d245479f4a != msg.sender:
                        if 0xb48b978ab606fb6065097a7403e47e58ca464462 != msg.sender:
                            if 0xac1afe8faad8b5a75bd0f7fedeec0e798675ee49 != msg.sender:
                                if 0xc577ccd813957558ea7eca6f14ba9b90c58377c0 != msg.sender:
                                    if 0x60befe4438001c95ec75d09aedfac0dd4c10820b != msg.sender:
                                        revert with 0, 'O'
    staticcall mem[0 len 12], call.data[32 len 20].getReserves() with:
            gas 5000 wei
    if bool(call.data[92 len 1]) == 1:
        if (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[92 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[92 len 1] / 2 * mem[0 len 18], call.data[4 len 14]) < mem[0 len 18], call.data[18 len 14]:
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
        else:
            call 0xd586e7f844cea2f87f50152665bcbc2c279d8d70.transfer(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args mem[0 len 12], call.data[32 len 20], mem[0 len 18], call.data[4 len 14]
            if bool(call.data[92 len 1]) == 1 == 1:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[92 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[92 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), this.address, 128, 0
            else:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[92 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[92 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), 0, this.address, 128, 0
            require ext_call.success
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[72 len 20] with:
                 gas gas_remaining wei
    else:
        if (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[92 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[92 len 1] / 2 * mem[0 len 18], call.data[4 len 14]) < mem[0 len 18], call.data[18 len 14]:
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
        else:
            call 0xd586e7f844cea2f87f50152665bcbc2c279d8d70.transfer(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args mem[0 len 12], call.data[32 len 20], mem[0 len 18], call.data[4 len 14]
            if bool(call.data[92 len 1]) == 1 == 1:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[92 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[92 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), this.address, 128, 0
            else:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[92 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[92 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), 0, this.address, 128, 0
            require ext_call.success
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[72 len 20] with:
                 gas gas_remaining wei
}

function sub_00001678(?) {
    if 0x4bad9f1a15bd17e78b59e086aa4092a3ce0de5c2 != msg.sender:
        if 0xd966d085127a3bfa686afa4ee0c52dbe4e962ef4 != msg.sender:
            if 0x71e5581ea04d93336fd6d2557c56f5c6ab2bea8 != msg.sender:
                if 0x90f729f31e20c58b93a7092f1e10bdae9cc4d82b != msg.sender:
                    if 0xd794ad6fe0cdfcb15597da157077e6d245479f4a != msg.sender:
                        if 0xb48b978ab606fb6065097a7403e47e58ca464462 != msg.sender:
                            if 0xac1afe8faad8b5a75bd0f7fedeec0e798675ee49 != msg.sender:
                                if 0xc577ccd813957558ea7eca6f14ba9b90c58377c0 != msg.sender:
                                    if 0x60befe4438001c95ec75d09aedfac0dd4c10820b != msg.sender:
                                        revert with 0, 'O'
    staticcall mem[0 len 12], call.data[32 len 20].getReserves() with:
            gas 5000 wei
    if bool(call.data[112 len 1]) == 1:
        if (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[112 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[112 len 1] / 2 * mem[0 len 18], call.data[4 len 14]) < mem[0 len 18], call.data[18 len 14]:
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
        else:
            call 0xd586e7f844cea2f87f50152665bcbc2c279d8d70.transfer(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args mem[0 len 12], call.data[32 len 20], mem[0 len 18], call.data[4 len 14]
            if bool(call.data[112 len 1]) == 1 == 1:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[112 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[112 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), this.address, 128, 0
            else:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[112 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[112 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), 0, this.address, 128, 0
            require ext_call.success
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[72 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[92 len 20] with:
                 gas gas_remaining wei
    else:
        if (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[112 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[112 len 1] / 2 * mem[0 len 18], call.data[4 len 14]) < mem[0 len 18], call.data[18 len 14]:
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
        else:
            call 0xd586e7f844cea2f87f50152665bcbc2c279d8d70.transfer(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args mem[0 len 12], call.data[32 len 20], mem[0 len 18], call.data[4 len 14]
            if bool(call.data[112 len 1]) == 1 == 1:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[112 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[112 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), this.address, 128, 0
            else:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[112 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[112 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), 0, this.address, 128, 0
            require ext_call.success
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[72 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[92 len 20] with:
                 gas gas_remaining wei
}

function pendingOfWithFees(uint256 arg1) {
    if 0x4bad9f1a15bd17e78b59e086aa4092a3ce0de5c2 != msg.sender:
        if 0xd966d085127a3bfa686afa4ee0c52dbe4e962ef4 != msg.sender:
            if 0x71e5581ea04d93336fd6d2557c56f5c6ab2bea8 != msg.sender:
                if 0x90f729f31e20c58b93a7092f1e10bdae9cc4d82b != msg.sender:
                    if 0xd794ad6fe0cdfcb15597da157077e6d245479f4a != msg.sender:
                        if 0xb48b978ab606fb6065097a7403e47e58ca464462 != msg.sender:
                            if 0xac1afe8faad8b5a75bd0f7fedeec0e798675ee49 != msg.sender:
                                if 0xc577ccd813957558ea7eca6f14ba9b90c58377c0 != msg.sender:
                                    if 0x60befe4438001c95ec75d09aedfac0dd4c10820b != msg.sender:
                                        revert with 0, 'O'
    staticcall mem[0 len 12], call.data[32 len 20].getReserves() with:
            gas 5000 wei
    if bool(call.data[132 len 1]) == 1:
        if (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[132 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[132 len 1] / 2 * mem[0 len 18], call.data[4 len 14]) < mem[0 len 18], call.data[18 len 14]:
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
        else:
            call 0xd586e7f844cea2f87f50152665bcbc2c279d8d70.transfer(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args mem[0 len 12], call.data[32 len 20], mem[0 len 18], call.data[4 len 14]
            if bool(call.data[132 len 1]) == 1 == 1:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[132 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[132 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), this.address, 128, 0
            else:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[132 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[132 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), 0, this.address, 128, 0
            require ext_call.success
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[72 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[92 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[112 len 20] with:
                 gas gas_remaining wei
    else:
        if (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[132 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[132 len 1] / 2 * mem[0 len 18], call.data[4 len 14]) < mem[0 len 18], call.data[18 len 14]:
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
        else:
            call 0xd586e7f844cea2f87f50152665bcbc2c279d8d70.transfer(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args mem[0 len 12], call.data[32 len 20], mem[0 len 18], call.data[4 len 14]
            if bool(call.data[132 len 1]) == 1 == 1:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[132 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[132 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), this.address, 128, 0
            else:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[132 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[132 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), 0, this.address, 128, 0
            require ext_call.success
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[72 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[92 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[112 len 20] with:
                 gas gas_remaining wei
}

function sub_0000eff0(?) {
    if 0x4bad9f1a15bd17e78b59e086aa4092a3ce0de5c2 != msg.sender:
        if 0xd966d085127a3bfa686afa4ee0c52dbe4e962ef4 != msg.sender:
            if 0x71e5581ea04d93336fd6d2557c56f5c6ab2bea8 != msg.sender:
                if 0x90f729f31e20c58b93a7092f1e10bdae9cc4d82b != msg.sender:
                    if 0xd794ad6fe0cdfcb15597da157077e6d245479f4a != msg.sender:
                        if 0xb48b978ab606fb6065097a7403e47e58ca464462 != msg.sender:
                            if 0xac1afe8faad8b5a75bd0f7fedeec0e798675ee49 != msg.sender:
                                if 0xc577ccd813957558ea7eca6f14ba9b90c58377c0 != msg.sender:
                                    if 0x60befe4438001c95ec75d09aedfac0dd4c10820b != msg.sender:
                                        revert with 0, 'O'
    staticcall mem[0 len 12], call.data[32 len 20].getReserves() with:
            gas 5000 wei
    if bool(call.data[152 len 1]) == 1:
        if (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[152 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[152 len 1] / 2 * mem[0 len 18], call.data[4 len 14]) < mem[0 len 18], call.data[18 len 14]:
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
        else:
            call 0xd586e7f844cea2f87f50152665bcbc2c279d8d70.transfer(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args mem[0 len 12], call.data[32 len 20], mem[0 len 18], call.data[4 len 14]
            if bool(call.data[152 len 1]) == 1 == 1:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[152 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[152 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), this.address, 128, 0
            else:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) - (mem[32 len 31], call.data[152 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[32]) / (10000 * ext_call.return_data[0]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[152 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), 0, this.address, 128, 0
            require ext_call.success
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[72 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[92 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[112 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[132 len 20] with:
                 gas gas_remaining wei
    else:
        if (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[152 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[152 len 1] / 2 * mem[0 len 18], call.data[4 len 14]) < mem[0 len 18], call.data[18 len 14]:
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
        else:
            call 0xd586e7f844cea2f87f50152665bcbc2c279d8d70.transfer(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args mem[0 len 12], call.data[32 len 20], mem[0 len 18], call.data[4 len 14]
            if bool(call.data[152 len 1]) == 1 == 1:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[152 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[152 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), this.address, 128, 0
            else:
                call mem[0 len 12], call.data[32 len 20].swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args (10000 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) - (mem[32 len 31], call.data[152 len 1] / 2 * mem[0 len 18], call.data[4 len 14] * ext_call.return_data[0]) / (10000 * ext_call.return_data[32]) + (10000 * mem[0 len 18], call.data[4 len 14]) - (mem[32 len 31], call.data[152 len 1] / 2 * mem[0 len 18], call.data[4 len 14]), 0, this.address, 128, 0
            require ext_call.success
            call mem[0 len 12], call.data[52 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[72 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[92 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[112 len 20] with:
                 gas gas_remaining wei
            call mem[0 len 12], call.data[132 len 20] with:
                 gas gas_remaining wei
}

function sub_c9e3b802(?) {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    if not stor0[msg.sender]:
        revert with 0, 'O'
    mem[100] = this.address
    require ext_code.size(address(arg1))
    staticcall address(arg1).balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 1:
        revert with 0, 'N'
    mem[ceil32(return_data.size) + 96] = 68
    mem[ceil32(return_data.size) + 132 len 28] = address(arg3) << 64
    mem[ceil32(return_data.size) + 128 len 4] = transfer(address arg1, uint256 arg2)
    mem[ceil32(return_data.size) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[ceil32(return_data.size) + 196 len 28]
    call address(arg1).mem[ceil32(return_data.size) + 196 len 4] with:
         gas gas_remaining wei
        args mem[ceil32(return_data.size) + 200 len 64]
    if not return_data.size:
        if not ext_call.success:
            revert with 0, 'ST'
        if not ext_call.return_data[0]:
            require ext_code.size(address(arg3))
            staticcall address(arg3).getReserves() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            require ext_code.size(address(arg1))
            staticcall address(arg1).balanceOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg3)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if address(arg1) < address(arg2):
                if address(arg1) == address(arg1):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
            else:
                if address(arg1) == address(arg2):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
        else:
            require ext_call.return_data[0] >= 32
            require 0, mem[132 len 28] == bool(0, mem[132 len 28])
            if not 0, mem[132 len 28]:
                revert with 0, 'ST'
            require ext_code.size(address(arg3))
            staticcall address(arg3).getReserves() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            require ext_code.size(address(arg1))
            staticcall address(arg1).balanceOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg3)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if address(arg1) < address(arg2):
                if address(arg1) == address(arg1):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
            else:
                if address(arg1) == address(arg2):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
    else:
        mem[ceil32(return_data.size) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            revert with 0, 'ST'
        if not return_data.size:
            require ext_code.size(address(arg3))
            staticcall address(arg3).getReserves() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            require ext_code.size(address(arg1))
            staticcall address(arg1).balanceOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg3)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if address(arg1) < address(arg2):
                if address(arg1) == address(arg1):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
            else:
                if address(arg1) == address(arg2):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
        else:
            require return_data.size >= 32
            require mem[ceil32(return_data.size) + 228] == bool(mem[ceil32(return_data.size) + 228])
            if not mem[ceil32(return_data.size) + 228]:
                revert with 0, 'ST'
            require ext_code.size(address(arg3))
            staticcall address(arg3).getReserves() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            require ext_code.size(address(arg1))
            staticcall address(arg1).balanceOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg3)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if address(arg1) < address(arg2):
                if address(arg1) == address(arg1):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
            else:
                if address(arg1) == address(arg2):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_fa7d3744(?) {
    require calldata.size - 4 >= 224
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require arg7 == address(arg7)
    if not stor0[msg.sender]:
        revert with 0, 'O'
    mem[100] = this.address
    require ext_code.size(address(arg1))
    staticcall address(arg1).balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 1:
        revert with 0, 'N'
    mem[ceil32(return_data.size) + 100] = this.address
    require ext_code.size(address(arg2))
    staticcall address(arg2).balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[(2 * ceil32(return_data.size)) + 100] = address(arg7)
    require ext_code.size(address(arg1))
    staticcall address(arg1).balanceOf(address arg1) with:
            gas gas_remaining wei
           args address(arg7)
    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[(4 * ceil32(return_data.size)) + 96] = 68
    mem[(4 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
    mem[(4 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
    mem[(4 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(4 * ceil32(return_data.size)) + 196 len 28]
    call address(arg1).mem[(4 * ceil32(return_data.size)) + 196 len 4] with:
         gas gas_remaining wei
        args mem[(4 * ceil32(return_data.size)) + 200 len 64]
    if not return_data.size:
        if not ext_call.success:
            revert with 0, 'ST'
        if not ext_call.return_data[0]:
            require ext_code.size(address(arg3))
            staticcall address(arg3).getReserves() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            require ext_code.size(address(arg1))
            staticcall address(arg1).balanceOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg3)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if address(arg1) < address(arg2):
                if address(arg1) == address(arg1):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
            else:
                if address(arg1) == address(arg2):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
        else:
            require ext_call.return_data[0] >= 32
            require 0, mem[132 len 28] == bool(0, mem[132 len 28])
            if not 0, mem[132 len 28]:
                revert with 0, 'ST'
            require ext_code.size(address(arg3))
            staticcall address(arg3).getReserves() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            require ext_code.size(address(arg1))
            staticcall address(arg1).balanceOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg3)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if address(arg1) < address(arg2):
                if address(arg1) == address(arg1):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
            else:
                if address(arg1) == address(arg2):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
    else:
        mem[(4 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            revert with 0, 'ST'
        if not return_data.size:
            require ext_code.size(address(arg3))
            staticcall address(arg3).getReserves() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            require ext_code.size(address(arg1))
            staticcall address(arg1).balanceOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg3)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if address(arg1) < address(arg2):
                if address(arg1) == address(arg1):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
            else:
                if address(arg1) == address(arg2):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
        else:
            require return_data.size >= 32
            require mem[(4 * ceil32(return_data.size)) + 228] == bool(mem[(4 * ceil32(return_data.size)) + 228])
            if not mem[(4 * ceil32(return_data.size)) + 228]:
                revert with 0, 'ST'
            require ext_code.size(address(arg3))
            staticcall address(arg3).getReserves() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            require ext_code.size(address(arg1))
            staticcall address(arg1).balanceOf(address arg1) with:
                    gas gas_remaining wei
                   args address(arg3)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if address(arg1) < address(arg2):
                if address(arg1) == address(arg1):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
            else:
                if address(arg1) == address(arg2):
                    if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not Mask(144, 112, ext_call.return_data[0]):
                        require Mask(112, 0, ext_call.return_data[0])
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[0])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                    else:
                        if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[0]):
                                if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                else:
                    if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                        revert with 0, 'SafeMath#sub: UNDERFLOW'
                    if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                        require Mask(112, 0, ext_call.return_data[32])
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require 10000 * Mask(112, 0, ext_call.return_data[32])
                        require ext_code.size(address(arg3))
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not Mask(112, 0, ext_call.return_data[32]):
                                if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#add: OVERFLOW'
                                require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                require ext_code.size(address(arg3))
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(address(arg2))
    staticcall address(arg2).balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if 0 < arg5:
        if ext_call.return_data[0] < arg6:
            revert with 0, 'I'
}

function sub_bd698099(?) {
    require calldata.size - 4 >= 160
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    if not stor0[msg.sender]:
        revert with 0, 'O'
    mem[100] = this.address
    require ext_code.size(address(arg1))
    staticcall address(arg1).balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if arg4 >= ext_call.return_data[0]:
        revert with 0, 'N'
    require ext_code.size(address(arg3))
    staticcall address(arg3).getReserves() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if address(arg1) < address(arg2):
        if address(arg1) == address(arg1):
            if not arg4:
                require ext_call.return_data[18 len 14]
                if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                    revert with 0, 'SafeMath#mul: OVERFLOW'
                if 10000 * ext_call.return_data[18 len 14] < 10000 * ext_call.return_data[18 len 14]:
                    revert with 0, 'SafeMath#add: OVERFLOW'
                require 10000 * ext_call.return_data[18 len 14]
                mem[(2 * ceil32(return_data.size)) + 96] = 68
                mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not ext_call.return_data[0]:
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                    else:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                else:
                    mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not return_data.size:
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                        if not mem[(2 * ceil32(return_data.size)) + 228]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                return (0 / 10000 * Mask(112, 0, ext_call.return_data[0]))
            if (10000 * arg4) - (arg5 * arg4) / arg4 != -arg5 + 10000:
                revert with 0, 'SafeMath#mul: OVERFLOW'
            if not (10000 * arg4) - (arg5 * arg4):
                if not ext_call.return_data[18 len 14]:
                    if (10000 * arg4) - (arg5 * arg4) < 0:
                        revert with 0, 'SafeMath#add: OVERFLOW'
                    require (10000 * arg4) - (arg5 * arg4)
                    mem[(2 * ceil32(return_data.size)) + 96] = 68
                    mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                    mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                    mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                    call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                         gas gas_remaining wei
                        args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not ext_call.return_data[0]:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                        else:
                            require ext_call.return_data[0] >= 32
                            require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                            if not 0, mem[132 len 28]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                    else:
                        mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not return_data.size:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                        else:
                            require return_data.size >= 32
                            require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                            if not mem[(2 * ceil32(return_data.size)) + 228]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    return (0 / (10000 * arg4) - (arg5 * arg4))
                if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                    revert with 0, 'SafeMath#mul: OVERFLOW'
                if (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[18 len 14]) < 10000 * ext_call.return_data[18 len 14]:
                    revert with 0, 'SafeMath#add: OVERFLOW'
                require (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[18 len 14])
                mem[(2 * ceil32(return_data.size)) + 96] = 68
                mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not ext_call.return_data[0]:
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                    else:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                else:
                    mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not return_data.size:
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                    else:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                        if not mem[(2 * ceil32(return_data.size)) + 228]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                return (0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])))
            if (10000 * arg4 * ext_call.return_data[50 len 14]) - (arg5 * arg4 * ext_call.return_data[50 len 14]) / (10000 * arg4) - (arg5 * arg4) != ext_call.return_data[50 len 14]:
                revert with 0, 'SafeMath#mul: OVERFLOW'
            if not ext_call.return_data[18 len 14]:
                if (10000 * arg4) - (arg5 * arg4) < 0:
                    revert with 0, 'SafeMath#add: OVERFLOW'
                require (10000 * arg4) - (arg5 * arg4)
                mem[(2 * ceil32(return_data.size)) + 96] = 68
                mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not ext_call.return_data[0]:
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                    else:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                else:
                    mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                        if not mem[(2 * ceil32(return_data.size)) + 228]:
                            revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                return ((10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4))
            if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                revert with 0, 'SafeMath#mul: OVERFLOW'
            if (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[18 len 14]) < 10000 * ext_call.return_data[18 len 14]:
                revert with 0, 'SafeMath#add: OVERFLOW'
            require (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[18 len 14])
            mem[(2 * ceil32(return_data.size)) + 96] = 68
            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                 gas gas_remaining wei
                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'ST'
                if not ext_call.return_data[0]:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                else:
                    require ext_call.return_data[0] >= 32
                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                    if not 0, mem[132 len 28]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
            else:
                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, 'ST'
                if not return_data.size:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                else:
                    require return_data.size >= 32
                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            return ((10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])))
        if not arg4:
            require ext_call.return_data[50 len 14]
            if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                revert with 0, 'SafeMath#mul: OVERFLOW'
            if 10000 * ext_call.return_data[50 len 14] < 10000 * ext_call.return_data[50 len 14]:
                revert with 0, 'SafeMath#add: OVERFLOW'
            require 10000 * ext_call.return_data[50 len 14]
            mem[(2 * ceil32(return_data.size)) + 96] = 68
            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                 gas gas_remaining wei
                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'ST'
                if not ext_call.return_data[0]:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                else:
                    require ext_call.return_data[0] >= 32
                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                    if not 0, mem[132 len 28]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
            else:
                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, 'ST'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                        revert with 0, 'ST'
                require ext_code.size(address(arg3))
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            return (0 / 10000 * Mask(112, 0, ext_call.return_data[32]))
        if (10000 * arg4) - (arg5 * arg4) / arg4 != -arg5 + 10000:
            revert with 0, 'SafeMath#mul: OVERFLOW'
        if not (10000 * arg4) - (arg5 * arg4):
            if not ext_call.return_data[50 len 14]:
                if (10000 * arg4) - (arg5 * arg4) < 0:
                    revert with 0, 'SafeMath#add: OVERFLOW'
                require (10000 * arg4) - (arg5 * arg4)
                mem[(2 * ceil32(return_data.size)) + 96] = 68
                mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                else:
                    mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not return_data.size:
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                    else:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                        if not mem[(2 * ceil32(return_data.size)) + 228]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                return (0 / (10000 * arg4) - (arg5 * arg4))
            if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                revert with 0, 'SafeMath#mul: OVERFLOW'
            if (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[50 len 14]) < 10000 * ext_call.return_data[50 len 14]:
                revert with 0, 'SafeMath#add: OVERFLOW'
            require (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[50 len 14])
            mem[(2 * ceil32(return_data.size)) + 96] = 68
            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                 gas gas_remaining wei
                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'ST'
                if not ext_call.return_data[0]:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                else:
                    require ext_call.return_data[0] >= 32
                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                    if not 0, mem[132 len 28]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
            else:
                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, 'ST'
                if not return_data.size:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                else:
                    require return_data.size >= 32
                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            return (0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])))
        if (10000 * arg4 * ext_call.return_data[18 len 14]) - (arg5 * arg4 * ext_call.return_data[18 len 14]) / (10000 * arg4) - (arg5 * arg4) != ext_call.return_data[18 len 14]:
            revert with 0, 'SafeMath#mul: OVERFLOW'
        if not ext_call.return_data[50 len 14]:
            if (10000 * arg4) - (arg5 * arg4) < 0:
                revert with 0, 'SafeMath#add: OVERFLOW'
            require (10000 * arg4) - (arg5 * arg4)
            mem[(2 * ceil32(return_data.size)) + 96] = 68
            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                 gas gas_remaining wei
                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'ST'
                if not ext_call.return_data[0]:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                else:
                    require ext_call.return_data[0] >= 32
                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                    if not 0, mem[132 len 28]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
            else:
                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, 'ST'
                if not return_data.size:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                else:
                    require return_data.size >= 32
                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            return ((10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4))
        if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
            revert with 0, 'SafeMath#mul: OVERFLOW'
        if (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[50 len 14]) < 10000 * ext_call.return_data[50 len 14]:
            revert with 0, 'SafeMath#add: OVERFLOW'
        require (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[50 len 14])
        mem[(2 * ceil32(return_data.size)) + 96] = 68
        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
        call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
             gas gas_remaining wei
            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, 'ST'
            if not ext_call.return_data[0]:
                require ext_code.size(address(arg3))
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                else:
                    if address(arg1) == address(arg2):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
            else:
                require ext_call.return_data[0] >= 32
                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                if not 0, mem[132 len 28]:
                    revert with 0, 'ST'
                require ext_code.size(address(arg3))
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
        else:
            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'ST'
            if not return_data.size:
                require ext_code.size(address(arg3))
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
            else:
                require return_data.size >= 32
                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                if not mem[(2 * ceil32(return_data.size)) + 228]:
                    revert with 0, 'ST'
                require ext_code.size(address(arg3))
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
    else:
        if address(arg1) == address(arg2):
            if not arg4:
                require ext_call.return_data[18 len 14]
                if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                    revert with 0, 'SafeMath#mul: OVERFLOW'
                if 10000 * ext_call.return_data[18 len 14] < 10000 * ext_call.return_data[18 len 14]:
                    revert with 0, 'SafeMath#add: OVERFLOW'
                require 10000 * ext_call.return_data[18 len 14]
                mem[(2 * ceil32(return_data.size)) + 96] = 68
                mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not ext_call.return_data[0]:
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                    else:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                else:
                    mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not return_data.size:
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                        if not mem[(2 * ceil32(return_data.size)) + 228]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                return (0 / 10000 * Mask(112, 0, ext_call.return_data[0]))
            if (10000 * arg4) - (arg5 * arg4) / arg4 != -arg5 + 10000:
                revert with 0, 'SafeMath#mul: OVERFLOW'
            if not (10000 * arg4) - (arg5 * arg4):
                if not ext_call.return_data[18 len 14]:
                    if (10000 * arg4) - (arg5 * arg4) < 0:
                        revert with 0, 'SafeMath#add: OVERFLOW'
                    require (10000 * arg4) - (arg5 * arg4)
                    mem[(2 * ceil32(return_data.size)) + 96] = 68
                    mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                    mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                    mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                    call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                         gas gas_remaining wei
                        args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not ext_call.return_data[0]:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                        else:
                            require ext_call.return_data[0] >= 32
                            require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                            if not 0, mem[132 len 28]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                    else:
                        mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not return_data.size:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                        else:
                            require return_data.size >= 32
                            require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                            if not mem[(2 * ceil32(return_data.size)) + 228]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    return (0 / (10000 * arg4) - (arg5 * arg4))
                if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                    revert with 0, 'SafeMath#mul: OVERFLOW'
                if (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[18 len 14]) < 10000 * ext_call.return_data[18 len 14]:
                    revert with 0, 'SafeMath#add: OVERFLOW'
                require (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[18 len 14])
                mem[(2 * ceil32(return_data.size)) + 96] = 68
                mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                else:
                    mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not return_data.size:
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                    else:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                        if not mem[(2 * ceil32(return_data.size)) + 228]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                return (0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])))
            if (10000 * arg4 * ext_call.return_data[50 len 14]) - (arg5 * arg4 * ext_call.return_data[50 len 14]) / (10000 * arg4) - (arg5 * arg4) != ext_call.return_data[50 len 14]:
                revert with 0, 'SafeMath#mul: OVERFLOW'
            if not ext_call.return_data[18 len 14]:
                if (10000 * arg4) - (arg5 * arg4) < 0:
                    revert with 0, 'SafeMath#add: OVERFLOW'
                require (10000 * arg4) - (arg5 * arg4)
                mem[(2 * ceil32(return_data.size)) + 96] = 68
                mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not ext_call.return_data[0]:
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                    else:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                else:
                    mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not return_data.size:
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                    else:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                        if not mem[(2 * ceil32(return_data.size)) + 228]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                return ((10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4))
            if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                revert with 0, 'SafeMath#mul: OVERFLOW'
            if (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[18 len 14]) < 10000 * ext_call.return_data[18 len 14]:
                revert with 0, 'SafeMath#add: OVERFLOW'
            require (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[18 len 14])
            mem[(2 * ceil32(return_data.size)) + 96] = 68
            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                 gas gas_remaining wei
                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'ST'
                if not ext_call.return_data[0]:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                else:
                    require ext_call.return_data[0] >= 32
                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                    if not 0, mem[132 len 28]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
            else:
                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, 'ST'
                if not return_data.size:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                else:
                    require return_data.size >= 32
                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            return ((10000 * arg4 * Mask(112, 0, ext_call.return_data[32])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])))
        if not arg4:
            require ext_call.return_data[50 len 14]
            if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                revert with 0, 'SafeMath#mul: OVERFLOW'
            if 10000 * ext_call.return_data[50 len 14] < 10000 * ext_call.return_data[50 len 14]:
                revert with 0, 'SafeMath#add: OVERFLOW'
            require 10000 * ext_call.return_data[50 len 14]
            mem[(2 * ceil32(return_data.size)) + 96] = 68
            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                 gas gas_remaining wei
                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'ST'
                if not ext_call.return_data[0]:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                else:
                    require ext_call.return_data[0] >= 32
                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                    if not 0, mem[132 len 28]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
            else:
                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, 'ST'
                if not return_data.size:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                else:
                    require return_data.size >= 32
                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            return (0 / 10000 * Mask(112, 0, ext_call.return_data[32]))
        if (10000 * arg4) - (arg5 * arg4) / arg4 != -arg5 + 10000:
            revert with 0, 'SafeMath#mul: OVERFLOW'
        if not (10000 * arg4) - (arg5 * arg4):
            if not ext_call.return_data[50 len 14]:
                if (10000 * arg4) - (arg5 * arg4) < 0:
                    revert with 0, 'SafeMath#add: OVERFLOW'
                require (10000 * arg4) - (arg5 * arg4)
                mem[(2 * ceil32(return_data.size)) + 96] = 68
                mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not ext_call.return_data[0]:
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                    else:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                else:
                    mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not return_data.size:
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                    else:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                        if not mem[(2 * ceil32(return_data.size)) + 228]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                return (0 / (10000 * arg4) - (arg5 * arg4))
            if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                revert with 0, 'SafeMath#mul: OVERFLOW'
            if (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[50 len 14]) < 10000 * ext_call.return_data[50 len 14]:
                revert with 0, 'SafeMath#add: OVERFLOW'
            require (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[50 len 14])
            mem[(2 * ceil32(return_data.size)) + 96] = 68
            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                 gas gas_remaining wei
                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'ST'
                if not ext_call.return_data[0]:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                else:
                    require ext_call.return_data[0] >= 32
                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                    if not 0, mem[132 len 28]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
            else:
                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, 'ST'
                if not return_data.size:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                else:
                    require return_data.size >= 32
                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            return (0 / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])))
        if (10000 * arg4 * ext_call.return_data[18 len 14]) - (arg5 * arg4 * ext_call.return_data[18 len 14]) / (10000 * arg4) - (arg5 * arg4) != ext_call.return_data[18 len 14]:
            revert with 0, 'SafeMath#mul: OVERFLOW'
        if not ext_call.return_data[50 len 14]:
            if (10000 * arg4) - (arg5 * arg4) < 0:
                revert with 0, 'SafeMath#add: OVERFLOW'
            require (10000 * arg4) - (arg5 * arg4)
            mem[(2 * ceil32(return_data.size)) + 96] = 68
            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                 gas gas_remaining wei
                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'ST'
                if not ext_call.return_data[0]:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                else:
                    require ext_call.return_data[0] >= 32
                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                    if not 0, mem[132 len 28]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
            else:
                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    revert with 0, 'ST'
                if not return_data.size:
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
                else:
                    require return_data.size >= 32
                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                        revert with 0, 'ST'
                    require ext_code.size(address(arg3))
                    if address(arg1) < address(arg2):
                        if address(arg1) == address(arg1):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0, None
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if address(arg1) == address(arg2):
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), address(this.address), 128, 0
                        else:
                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4), 0, address(this.address), 128, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            return ((10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4))
        if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
            revert with 0, 'SafeMath#mul: OVERFLOW'
        if (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[50 len 14]) < 10000 * ext_call.return_data[50 len 14]:
            revert with 0, 'SafeMath#add: OVERFLOW'
        require (10000 * arg4) - (arg5 * arg4) + (10000 * ext_call.return_data[50 len 14])
        mem[(2 * ceil32(return_data.size)) + 96] = 68
        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg4, mem[(2 * ceil32(return_data.size)) + 196 len 28]
        call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
             gas gas_remaining wei
            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, 'ST'
            if not ext_call.return_data[0]:
                require ext_code.size(address(arg3))
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                else:
                    if address(arg1) == address(arg2):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
            else:
                require ext_call.return_data[0] >= 32
                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                if not 0, mem[132 len 28]:
                    revert with 0, 'ST'
                require ext_code.size(address(arg3))
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
        else:
            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'ST'
            if not return_data.size:
                require ext_code.size(address(arg3))
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
            else:
                require return_data.size >= 32
                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                if not mem[(2 * ceil32(return_data.size)) + 228]:
                    revert with 0, 'ST'
                require ext_code.size(address(arg3))
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                else:
                    if address(arg1) == address(arg2):
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                    else:
                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    return ((10000 * arg4 * Mask(112, 0, ext_call.return_data[0])) - (arg5 * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg4) - (arg5 * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])))
}

function sendGobbets(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == address(arg3)
    if not stor0[msg.sender]:
        revert with 0, 'O'
    mem[100] = this.address
    require ext_code.size(arg1)
    staticcall arg1.balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 1:
        revert with 0, 'N'
    require ext_code.size(address(arg3))
    staticcall address(arg3).getReserves() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if arg1 < arg2:
        if arg1 == arg1:
            if not ext_call.return_data[0] - 1:
                require ext_call.return_data[18 len 14]
                if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                    revert with 0, 'SafeMath#mul: OVERFLOW'
                if 10000 * ext_call.return_data[18 len 14] < 10000 * ext_call.return_data[18 len 14]:
                    revert with 0, 'SafeMath#add: OVERFLOW'
                require 10000 * ext_call.return_data[18 len 14]
                mem[(2 * ceil32(return_data.size)) + 96] = 68
                mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not ext_call.return_data[0]:
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                else:
                    mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not return_data.size:
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                    else:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                        if not mem[(2 * ceil32(return_data.size)) + 228]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
            else:
                if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 / ext_call.return_data[0] - 1 != -cd[100] + 10000:
                    revert with 0, 'SafeMath#mul: OVERFLOW'
                if not (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000:
                    if not ext_call.return_data[18 len 14]:
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 < 0:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                    else:
                        if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[18 len 14]) - 10000 < 10000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[18 len 14]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                else:
                    if (-10000 * ext_call.return_data[50 len 14]) + (10000 * ext_call.return_data[0] * ext_call.return_data[50 len 14]) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * ext_call.return_data[50 len 14]) - (ext_call.return_data[0] * cd[100] * ext_call.return_data[50 len 14]) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if not ext_call.return_data[18 len 14]:
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 < 0:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if ext_call.return_data[0]:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if arg1 < arg2:
                                if arg1 == arg1:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                if arg1 == arg2:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                    else:
                        if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[18 len 14]) - 10000 < 10000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[18 len 14]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
        else:
            if not ext_call.return_data[0] - 1:
                require ext_call.return_data[50 len 14]
                if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                    revert with 0, 'SafeMath#mul: OVERFLOW'
                if 10000 * ext_call.return_data[50 len 14] < 10000 * ext_call.return_data[50 len 14]:
                    revert with 0, 'SafeMath#add: OVERFLOW'
                require 10000 * ext_call.return_data[50 len 14]
                mem[(2 * ceil32(return_data.size)) + 96] = 68
                mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not ext_call.return_data[0]:
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                else:
                    mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not return_data.size:
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                        if not mem[(2 * ceil32(return_data.size)) + 228]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
            else:
                if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 / ext_call.return_data[0] - 1 != -cd[100] + 10000:
                    revert with 0, 'SafeMath#mul: OVERFLOW'
                if not (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000:
                    if not ext_call.return_data[50 len 14]:
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 < 0:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                    else:
                        if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[50 len 14]) - 10000 < 10000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[50 len 14]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                else:
                    if (-10000 * ext_call.return_data[18 len 14]) + (10000 * ext_call.return_data[0] * ext_call.return_data[18 len 14]) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * ext_call.return_data[18 len 14]) - (ext_call.return_data[0] * cd[100] * ext_call.return_data[18 len 14]) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if not ext_call.return_data[50 len 14]:
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 < 0:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                    else:
                        if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[50 len 14]) - 10000 < 10000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[50 len 14]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
    else:
        if arg1 == arg2:
            if not ext_call.return_data[0] - 1:
                require ext_call.return_data[18 len 14]
                if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                    revert with 0, 'SafeMath#mul: OVERFLOW'
                if 10000 * ext_call.return_data[18 len 14] < 10000 * ext_call.return_data[18 len 14]:
                    revert with 0, 'SafeMath#add: OVERFLOW'
                require 10000 * ext_call.return_data[18 len 14]
                mem[(2 * ceil32(return_data.size)) + 96] = 68
                mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not ext_call.return_data[0]:
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                else:
                    mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not return_data.size:
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                        if not mem[(2 * ceil32(return_data.size)) + 228]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
            else:
                if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 / ext_call.return_data[0] - 1 != -cd[100] + 10000:
                    revert with 0, 'SafeMath#mul: OVERFLOW'
                if not (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000:
                    if not ext_call.return_data[18 len 14]:
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 < 0:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                    else:
                        if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[18 len 14]) - 10000 < 10000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[18 len 14]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                else:
                    if (-10000 * ext_call.return_data[50 len 14]) + (10000 * ext_call.return_data[0] * ext_call.return_data[50 len 14]) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * ext_call.return_data[50 len 14]) - (ext_call.return_data[0] * cd[100] * ext_call.return_data[50 len 14]) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 != ext_call.return_data[50 len 14]:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if not ext_call.return_data[18 len 14]:
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 < 0:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                    else:
                        if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[18 len 14]) - 10000 < 10000 * ext_call.return_data[18 len 14]:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[18 len 14]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
        else:
            if not ext_call.return_data[0] - 1:
                require ext_call.return_data[50 len 14]
                if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                    revert with 0, 'SafeMath#mul: OVERFLOW'
                if 10000 * ext_call.return_data[50 len 14] < 10000 * ext_call.return_data[50 len 14]:
                    revert with 0, 'SafeMath#add: OVERFLOW'
                require 10000 * ext_call.return_data[50 len 14]
                mem[(2 * ceil32(return_data.size)) + 96] = 68
                mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                     gas gas_remaining wei
                    args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                if not return_data.size:
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not ext_call.return_data[0]:
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                else:
                    mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        revert with 0, 'ST'
                    if not return_data.size:
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                    else:
                        require return_data.size >= 32
                        require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                        if not mem[(2 * ceil32(return_data.size)) + 228]:
                            revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if arg1 < arg2:
                            if arg1 == arg1:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if arg1 == arg2:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
            else:
                if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 / ext_call.return_data[0] - 1 != -cd[100] + 10000:
                    revert with 0, 'SafeMath#mul: OVERFLOW'
                if not (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000:
                    if not ext_call.return_data[50 len 14]:
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 < 0:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                    else:
                        if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[50 len 14]) - 10000 < 10000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[50 len 14]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                else:
                    if (-10000 * ext_call.return_data[18 len 14]) + (10000 * ext_call.return_data[0] * ext_call.return_data[18 len 14]) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * ext_call.return_data[18 len 14]) - (ext_call.return_data[0] * cd[100] * ext_call.return_data[18 len 14]) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 != ext_call.return_data[18 len 14]:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if not ext_call.return_data[50 len 14]:
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000 < 0:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) - 10000, 0, address(this.address), 128, 0
                    else:
                        if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[50 len 14]) - 10000 < 10000 * ext_call.return_data[50 len 14]:
                            revert with 0, 'SafeMath#add: OVERFLOW'
                        require (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * ext_call.return_data[50 len 14]) - 10000
                        mem[(2 * ceil32(return_data.size)) + 96] = 68
                        mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                        mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                        mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                        call arg1.mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                             gas gas_remaining wei
                            args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not ext_call.return_data[0]:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                            else:
                                require ext_call.return_data[0] >= 32
                                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                if not 0, mem[132 len 28]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                        else:
                            mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                revert with 0, 'ST'
                            if not return_data.size:
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                            else:
                                require return_data.size >= 32
                                require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                if not mem[(2 * ceil32(return_data.size)) + 228]:
                                    revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if arg1 < arg2:
                                    if arg1 == arg1:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    if arg1 == arg2:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * cd[100] * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * cd[100] * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * cd[100]) + (-1 * ext_call.return_data[0] * cd[100]) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_255b782d(?) {
    require calldata.size - 4 >= 160
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    if not stor0[msg.sender]:
        revert with 0, 'O'
    mem[100] = this.address
    require ext_code.size(address(arg1))
    staticcall address(arg1).balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 1:
        revert with 0, 'N'
    mem[ceil32(return_data.size) + 96] = 68
    mem[ceil32(return_data.size) + 132 len 28] = address(arg3) << 64
    mem[ceil32(return_data.size) + 128 len 4] = transfer(address arg1, uint256 arg2)
    if (97 * ext_call.return_data[0]) - 97 / 100 <= arg5:
        mem[ceil32(return_data.size) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[ceil32(return_data.size) + 196 len 28]
        call address(arg1).mem[ceil32(return_data.size) + 196 len 4] with:
             gas gas_remaining wei
            args mem[ceil32(return_data.size) + 200 len 64]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, 'ST'
            if not ext_call.return_data[0]:
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
            else:
                require ext_call.return_data[0] >= 32
                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                if not 0, mem[132 len 28]:
                    revert with 0, 'ST'
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
        else:
            mem[ceil32(return_data.size) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'ST'
            if not return_data.size:
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
            else:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 228] == bool(mem[ceil32(return_data.size) + 228])
                if not mem[ceil32(return_data.size) + 228]:
                    revert with 0, 'ST'
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
    else:
        mem[ceil32(return_data.size) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[ceil32(return_data.size) + 196 len 28]
        call address(arg1).mem[ceil32(return_data.size) + 196 len 4] with:
             gas gas_remaining wei
            args mem[ceil32(return_data.size) + 200 len 64]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, 'ST'
            if not ext_call.return_data[0]:
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
            else:
                require ext_call.return_data[0] >= 32
                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                if not 0, mem[132 len 28]:
                    revert with 0, 'ST'
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
        else:
            mem[ceil32(return_data.size) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'ST'
            if not return_data.size:
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
            else:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 228] == bool(mem[ceil32(return_data.size) + 228])
                if not mem[ceil32(return_data.size) + 228]:
                    revert with 0, 'ST'
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_959bf26f(?) {
    require calldata.size - 4 >= 256
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require arg7 == address(arg7)
    if not stor0[msg.sender]:
        revert with 0, 'O'
    mem[100] = this.address
    require ext_code.size(address(arg1))
    staticcall address(arg1).balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 1:
        revert with 0, 'N'
    mem[ceil32(return_data.size) + 100] = this.address
    require ext_code.size(address(arg2))
    staticcall address(arg2).balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[(2 * ceil32(return_data.size)) + 100] = address(arg7)
    require ext_code.size(address(arg1))
    staticcall address(arg1).balanceOf(address arg1) with:
            gas gas_remaining wei
           args address(arg7)
    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[(4 * ceil32(return_data.size)) + 96] = 68
    mem[(4 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
    mem[(4 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
    if (97 * ext_call.return_data[0]) - 97 / 100 <= arg8:
        mem[(4 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(4 * ceil32(return_data.size)) + 196 len 28]
        call address(arg1).mem[(4 * ceil32(return_data.size)) + 196 len 4] with:
             gas gas_remaining wei
            args mem[(4 * ceil32(return_data.size)) + 200 len 64]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, 'ST'
            if not ext_call.return_data[0]:
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
            else:
                require ext_call.return_data[0] >= 32
                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                if not 0, mem[132 len 28]:
                    revert with 0, 'ST'
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
        else:
            mem[(4 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'ST'
            if not return_data.size:
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
            else:
                require return_data.size >= 32
                require mem[(4 * ceil32(return_data.size)) + 228] == bool(mem[(4 * ceil32(return_data.size)) + 228])
                if not mem[(4 * ceil32(return_data.size)) + 228]:
                    revert with 0, 'ST'
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
    else:
        mem[(4 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg8, mem[(4 * ceil32(return_data.size)) + 196 len 28]
        call address(arg1).mem[(4 * ceil32(return_data.size)) + 196 len 4] with:
             gas gas_remaining wei
            args mem[(4 * ceil32(return_data.size)) + 200 len 64]
        if not return_data.size:
            if not ext_call.success:
                revert with 0, 'ST'
            if not ext_call.return_data[0]:
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
            else:
                require ext_call.return_data[0] >= 32
                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                if not 0, mem[132 len 28]:
                    revert with 0, 'ST'
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
        else:
            mem[(4 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                revert with 0, 'ST'
            if not return_data.size:
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
            else:
                require return_data.size >= 32
                require mem[(4 * ceil32(return_data.size)) + 228] == bool(mem[(4 * ceil32(return_data.size)) + 228])
                if not mem[(4 * ceil32(return_data.size)) + 228]:
                    revert with 0, 'ST'
                require ext_code.size(address(arg3))
                staticcall address(arg3).getReserves() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 96
                require ext_call.return_data[0] == ext_call.return_data[18 len 14]
                require ext_call.return_data[32] == ext_call.return_data[50 len 14]
                require ext_call.return_data[64] == ext_call.return_data[92 len 4]
                require ext_code.size(address(arg1))
                staticcall address(arg1).balanceOf(address arg1) with:
                        gas gas_remaining wei
                       args address(arg3)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if address(arg1) < address(arg2):
                    if address(arg1) == address(arg1):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                else:
                    if address(arg1) == address(arg2):
                        if Mask(112, 0, ext_call.return_data[0]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not Mask(144, 112, ext_call.return_data[0]):
                            require Mask(112, 0, ext_call.return_data[0])
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[0]) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[0])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) / Mask(144, 112, ext_call.return_data[0]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) != Mask(112, 0, ext_call.return_data[32]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[0]):
                                    if (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * Mask(144, 112, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[0]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (10000 * Mask(112, 0, ext_call.return_data[0]) * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) + (Mask(112, 0, ext_call.return_data[0]) * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[0]) * arg4), 0, address(this.address), 128, 0
                    else:
                        if Mask(112, 0, ext_call.return_data[32]) > ext_call.return_data[0]:
                            revert with 0, 'SafeMath#sub: UNDERFLOW'
                        if not ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]):
                            require Mask(112, 0, ext_call.return_data[32])
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if 10000 * Mask(112, 0, ext_call.return_data[32]) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require 10000 * Mask(112, 0, ext_call.return_data[32])
                            require ext_code.size(address(arg3))
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) / ext_call.return_data[0] - Mask(112, 0, ext_call.return_data[32]) != -arg4 + 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if not (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4):
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                            else:
                                if (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) != Mask(112, 0, ext_call.return_data[0]):
                                    revert with 0, 'SafeMath#mul: OVERFLOW'
                                if not Mask(112, 0, ext_call.return_data[32]):
                                    if (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 0:
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (10000 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
                                else:
                                    if 10000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 10000:
                                        revert with 0, 'SafeMath#mul: OVERFLOW'
                                    if (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4) < 10000 * Mask(112, 0, ext_call.return_data[32]):
                                        revert with 0, 'SafeMath#add: OVERFLOW'
                                    require (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4)
                                    require ext_code.size(address(arg3))
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (10000 * Mask(112, 0, ext_call.return_data[32]) * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) + (Mask(112, 0, ext_call.return_data[32]) * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) - (ext_call.return_data[0] * arg4) + (Mask(112, 0, ext_call.return_data[32]) * arg4), 0, address(this.address), 128, 0, None
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(address(arg2))
    staticcall address(arg2).balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if 0 < arg5:
        if ext_call.return_data[0] < arg6:
            revert with 0, 'I'
}

function sub_2a8b05dd(?) {
    require calldata.size - 4 >= 160
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    if not stor0[msg.sender]:
        revert with 0, 'O'
    mem[100] = this.address
    require ext_code.size(address(arg1))
    staticcall address(arg1).balanceOf(address arg1) with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 1:
        revert with 0, 'N'
    require ext_code.size(address(arg3))
    staticcall address(arg3).getReserves() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if (97 * ext_call.return_data[0]) - 97 / 100 <= arg5:
        if address(arg1) < address(arg2):
            if address(arg1) == address(arg1):
                if not ext_call.return_data[0] - 1:
                    require ext_call.return_data[18 len 14]
                    if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if 10000 * ext_call.return_data[18 len 14] < 10000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'SafeMath#add: OVERFLOW'
                    require 10000 * ext_call.return_data[18 len 14]
                    mem[(2 * ceil32(return_data.size)) + 96] = 68
                    mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                    mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                    mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                    call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                         gas gas_remaining wei
                        args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not ext_call.return_data[0]:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            require ext_call.return_data[0] >= 32
                            require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                            if not 0, mem[132 len 28]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not return_data.size:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            require return_data.size >= 32
                            require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                            if not mem[(2 * ceil32(return_data.size)) + 228]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                else:
                    if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 / ext_call.return_data[0] - 1 != -arg4 + 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if not (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000:
                        if not ext_call.return_data[18 len 14]:
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                        else:
                            if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[18 len 14]) - 10000 < 10000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[18 len 14]) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                    else:
                        if (-10000 * ext_call.return_data[50 len 14]) + (10000 * ext_call.return_data[0] * ext_call.return_data[50 len 14]) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * ext_call.return_data[50 len 14]) - (ext_call.return_data[0] * arg4 * ext_call.return_data[50 len 14]) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not ext_call.return_data[18 len 14]:
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                        else:
                            if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[18 len 14]) - 10000 < 10000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[18 len 14]) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
            else:
                if not ext_call.return_data[0] - 1:
                    require ext_call.return_data[50 len 14]
                    if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if 10000 * ext_call.return_data[50 len 14] < 10000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'SafeMath#add: OVERFLOW'
                    require 10000 * ext_call.return_data[50 len 14]
                    mem[(2 * ceil32(return_data.size)) + 96] = 68
                    mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                    mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                    mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                    call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                         gas gas_remaining wei
                        args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                            if not 0, mem[132 len 28]:
                                revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                    else:
                        mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not return_data.size:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            require return_data.size >= 32
                            require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                            if not mem[(2 * ceil32(return_data.size)) + 228]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                else:
                    if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 / ext_call.return_data[0] - 1 != -arg4 + 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if not (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000:
                        if not ext_call.return_data[50 len 14]:
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                        else:
                            if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[50 len 14]) - 10000 < 10000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[50 len 14]) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                    else:
                        if (-10000 * ext_call.return_data[18 len 14]) + (10000 * ext_call.return_data[0] * ext_call.return_data[18 len 14]) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * ext_call.return_data[18 len 14]) - (ext_call.return_data[0] * arg4 * ext_call.return_data[18 len 14]) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not ext_call.return_data[50 len 14]:
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                        else:
                            if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[50 len 14]) - 10000 < 10000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[50 len 14]) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
        else:
            if address(arg1) == address(arg2):
                if not ext_call.return_data[0] - 1:
                    require ext_call.return_data[18 len 14]
                    if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if 10000 * ext_call.return_data[18 len 14] < 10000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'SafeMath#add: OVERFLOW'
                    require 10000 * ext_call.return_data[18 len 14]
                    mem[(2 * ceil32(return_data.size)) + 96] = 68
                    mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                    mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                    mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                    call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                         gas gas_remaining wei
                        args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not ext_call.return_data[0]:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            require ext_call.return_data[0] >= 32
                            require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                            if not 0, mem[132 len 28]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                    else:
                        mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not return_data.size:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            require return_data.size >= 32
                            require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                            if not mem[(2 * ceil32(return_data.size)) + 228]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                else:
                    if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 / ext_call.return_data[0] - 1 != -arg4 + 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if not (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000:
                        if not ext_call.return_data[18 len 14]:
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                        else:
                            if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[18 len 14]) - 10000 < 10000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[18 len 14]) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if return_data.size:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if address(arg1) < address(arg2):
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                    else:
                        if (-10000 * ext_call.return_data[50 len 14]) + (10000 * ext_call.return_data[0] * ext_call.return_data[50 len 14]) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * ext_call.return_data[50 len 14]) - (ext_call.return_data[0] * arg4 * ext_call.return_data[50 len 14]) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 != ext_call.return_data[50 len 14]:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not ext_call.return_data[18 len 14]:
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                        else:
                            if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[18 len 14]) - 10000 < 10000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[18 len 14]) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[32])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[32])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[32])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[32])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[0])) - 10000, 0, address(this.address), 128, 0
            else:
                if not ext_call.return_data[0] - 1:
                    require ext_call.return_data[50 len 14]
                    if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if 10000 * ext_call.return_data[50 len 14] < 10000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'SafeMath#add: OVERFLOW'
                    require 10000 * ext_call.return_data[50 len 14]
                    mem[(2 * ceil32(return_data.size)) + 96] = 68
                    mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                    mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                    mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                    call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                         gas gas_remaining wei
                        args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not ext_call.return_data[0]:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            require ext_call.return_data[0] >= 32
                            require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                            if not 0, mem[132 len 28]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not return_data.size:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            require return_data.size >= 32
                            require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                            if not mem[(2 * ceil32(return_data.size)) + 228]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                else:
                    if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 / ext_call.return_data[0] - 1 != -arg4 + 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if not (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000:
                        if not ext_call.return_data[50 len 14]:
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                        else:
                            if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[50 len 14]) - 10000 < 10000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[50 len 14]) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                    else:
                        if (-10000 * ext_call.return_data[18 len 14]) + (10000 * ext_call.return_data[0] * ext_call.return_data[18 len 14]) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * ext_call.return_data[18 len 14]) - (ext_call.return_data[0] * arg4 * ext_call.return_data[18 len 14]) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 != ext_call.return_data[18 len 14]:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not ext_call.return_data[50 len 14]:
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000 < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) - 10000, 0, address(this.address), 128, 0
                        else:
                            if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[50 len 14]) - 10000 < 10000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * ext_call.return_data[50 len 14]) - 10000
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, ext_call.return_data[0] - 1, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (-10000 * Mask(112, 0, ext_call.return_data[0])) + (10000 * ext_call.return_data[0] * Mask(112, 0, ext_call.return_data[0])) - (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * arg4 * Mask(112, 0, ext_call.return_data[0])) - (ext_call.return_data[0] * arg4 * Mask(112, 0, ext_call.return_data[0])) / (10000 * ext_call.return_data[0]) + (test266151307() * arg4) + (-1 * ext_call.return_data[0] * arg4) + (10000 * Mask(112, 0, ext_call.return_data[32])) - 10000, 0, address(this.address), 128, 0, None
    else:
        if address(arg1) < address(arg2):
            if address(arg1) == address(arg1):
                if not arg5:
                    require ext_call.return_data[18 len 14]
                    if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if 10000 * ext_call.return_data[18 len 14] < 10000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'SafeMath#add: OVERFLOW'
                    require 10000 * ext_call.return_data[18 len 14]
                    mem[(2 * ceil32(return_data.size)) + 96] = 68
                    mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                    mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                    mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                    call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                         gas gas_remaining wei
                        args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not ext_call.return_data[0]:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            require ext_call.return_data[0] >= 32
                            require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                            if not 0, mem[132 len 28]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                    else:
                        mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not return_data.size:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            require return_data.size >= 32
                            require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                            if not mem[(2 * ceil32(return_data.size)) + 228]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                else:
                    if (10000 * arg5) - (arg4 * arg5) / arg5 != -arg4 + 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if not (10000 * arg5) - (arg4 * arg5):
                        if not ext_call.return_data[18 len 14]:
                            if (10000 * arg5) - (arg4 * arg5) < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5)
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                        else:
                            if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[18 len 14]) < 10000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[18 len 14])
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * arg5 * ext_call.return_data[50 len 14]) - (arg4 * arg5 * ext_call.return_data[50 len 14]) / (10000 * arg5) - (arg4 * arg5) != ext_call.return_data[50 len 14]:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not ext_call.return_data[18 len 14]:
                            if (10000 * arg5) - (arg4 * arg5) < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5)
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                        else:
                            if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[18 len 14]) < 10000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[18 len 14])
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
            else:
                if not arg5:
                    require ext_call.return_data[50 len 14]
                    if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if 10000 * ext_call.return_data[50 len 14] < 10000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'SafeMath#add: OVERFLOW'
                    require 10000 * ext_call.return_data[50 len 14]
                    mem[(2 * ceil32(return_data.size)) + 96] = 68
                    mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                    mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                    mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                    call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                         gas gas_remaining wei
                        args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not ext_call.return_data[0]:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            require ext_call.return_data[0] >= 32
                            require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                            if not 0, mem[132 len 28]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not return_data.size:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            require return_data.size >= 32
                            require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                            if not mem[(2 * ceil32(return_data.size)) + 228]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                else:
                    if (10000 * arg5) - (arg4 * arg5) / arg5 != -arg4 + 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if not (10000 * arg5) - (arg4 * arg5):
                        if not ext_call.return_data[50 len 14]:
                            if (10000 * arg5) - (arg4 * arg5) < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5)
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                        else:
                            if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[50 len 14]) < 10000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[50 len 14])
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * arg5 * ext_call.return_data[18 len 14]) - (arg4 * arg5 * ext_call.return_data[18 len 14]) / (10000 * arg5) - (arg4 * arg5) != ext_call.return_data[18 len 14]:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not ext_call.return_data[50 len 14]:
                            if (10000 * arg5) - (arg4 * arg5) < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5)
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if return_data.size:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if address(arg1) < address(arg2):
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                                else:
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                        else:
                            if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[50 len 14]) < 10000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[50 len 14])
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
        else:
            if address(arg1) == address(arg2):
                if not arg5:
                    require ext_call.return_data[18 len 14]
                    if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if 10000 * ext_call.return_data[18 len 14] < 10000 * ext_call.return_data[18 len 14]:
                        revert with 0, 'SafeMath#add: OVERFLOW'
                    require 10000 * ext_call.return_data[18 len 14]
                    mem[(2 * ceil32(return_data.size)) + 96] = 68
                    mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                    mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                    mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                    call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                         gas gas_remaining wei
                        args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not ext_call.return_data[0]:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                        else:
                            require ext_call.return_data[0] >= 32
                            require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                            if not 0, mem[132 len 28]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                    else:
                        mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not return_data.size:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                        else:
                            require return_data.size >= 32
                            require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                            if not mem[(2 * ceil32(return_data.size)) + 228]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[0]), 0, address(this.address), 128, 0, None
                else:
                    if (10000 * arg5) - (arg4 * arg5) / arg5 != -arg4 + 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if not (10000 * arg5) - (arg4 * arg5):
                        if not ext_call.return_data[18 len 14]:
                            if (10000 * arg5) - (arg4 * arg5) < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5)
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                        else:
                            if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[18 len 14]) < 10000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[18 len 14])
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * arg5 * ext_call.return_data[50 len 14]) - (arg4 * arg5 * ext_call.return_data[50 len 14]) / (10000 * arg5) - (arg4 * arg5) != ext_call.return_data[50 len 14]:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not ext_call.return_data[18 len 14]:
                            if (10000 * arg5) - (arg4 * arg5) < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5)
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                        else:
                            if 10000 * ext_call.return_data[18 len 14] / ext_call.return_data[18 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[18 len 14]) < 10000 * ext_call.return_data[18 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[18 len 14])
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[32])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[32])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[0])), 0, address(this.address), 128, 0, None
            else:
                if not arg5:
                    require ext_call.return_data[50 len 14]
                    if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if 10000 * ext_call.return_data[50 len 14] < 10000 * ext_call.return_data[50 len 14]:
                        revert with 0, 'SafeMath#add: OVERFLOW'
                    require 10000 * ext_call.return_data[50 len 14]
                    mem[(2 * ceil32(return_data.size)) + 96] = 68
                    mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                    mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                    mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                    call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                         gas gas_remaining wei
                        args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if ext_call.return_data[0]:
                            require ext_call.return_data[0] >= 32
                            require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                            if not 0, mem[132 len 28]:
                                revert with 0, 'ST'
                        require ext_code.size(address(arg3))
                        if address(arg1) < address(arg2):
                            if address(arg1) == address(arg1):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                        else:
                            if address(arg1) == address(arg2):
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                            else:
                                call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                    else:
                        mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            revert with 0, 'ST'
                        if not return_data.size:
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                        else:
                            require return_data.size >= 32
                            require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                            if not mem[(2 * ceil32(return_data.size)) + 228]:
                                revert with 0, 'ST'
                            require ext_code.size(address(arg3))
                            if address(arg1) < address(arg2):
                                if address(arg1) == address(arg1):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0, None
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0, None
                            else:
                                if address(arg1) == address(arg2):
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), address(this.address), 128, 0
                                else:
                                    call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0 / 10000 * Mask(112, 0, ext_call.return_data[32]), 0, address(this.address), 128, 0
                else:
                    if (10000 * arg5) - (arg4 * arg5) / arg5 != -arg4 + 10000:
                        revert with 0, 'SafeMath#mul: OVERFLOW'
                    if not (10000 * arg5) - (arg4 * arg5):
                        if not ext_call.return_data[50 len 14]:
                            if (10000 * arg5) - (arg4 * arg5) < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5)
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                        else:
                            if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[50 len 14]) < 10000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[50 len 14])
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0 / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                    else:
                        if (10000 * arg5 * ext_call.return_data[18 len 14]) - (arg4 * arg5 * ext_call.return_data[18 len 14]) / (10000 * arg5) - (arg4 * arg5) != ext_call.return_data[18 len 14]:
                            revert with 0, 'SafeMath#mul: OVERFLOW'
                        if not ext_call.return_data[50 len 14]:
                            if (10000 * arg5) - (arg4 * arg5) < 0:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5)
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not ext_call.return_data[0]:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                else:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5), 0, address(this.address), 128, 0, None
                        else:
                            if 10000 * ext_call.return_data[50 len 14] / ext_call.return_data[50 len 14] != 10000:
                                revert with 0, 'SafeMath#mul: OVERFLOW'
                            if (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[50 len 14]) < 10000 * ext_call.return_data[50 len 14]:
                                revert with 0, 'SafeMath#add: OVERFLOW'
                            require (10000 * arg5) - (arg4 * arg5) + (10000 * ext_call.return_data[50 len 14])
                            mem[(2 * ceil32(return_data.size)) + 96] = 68
                            mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg3) << 64
                            mem[(2 * ceil32(return_data.size)) + 128 len 4] = transfer(address arg1, uint256 arg2)
                            mem[(2 * ceil32(return_data.size)) + 196 len 96] = transfer(address arg1, uint256 arg2), address(arg3) << 64, 0, arg5, mem[(2 * ceil32(return_data.size)) + 196 len 28]
                            call address(arg1).mem[(2 * ceil32(return_data.size)) + 196 len 4] with:
                                 gas gas_remaining wei
                                args mem[(2 * ceil32(return_data.size)) + 200 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if ext_call.return_data[0]:
                                    require ext_call.return_data[0] >= 32
                                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                                    if not 0, mem[132 len 28]:
                                        revert with 0, 'ST'
                                require ext_code.size(address(arg3))
                                if address(arg1) < address(arg2):
                                    if address(arg1) == address(arg1):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                                else:
                                    if address(arg1) == address(arg2):
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                    else:
                                        call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                            else:
                                mem[(2 * ceil32(return_data.size)) + 228 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    revert with 0, 'ST'
                                if not return_data.size:
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0, None
                                else:
                                    require return_data.size >= 32
                                    require mem[(2 * ceil32(return_data.size)) + 228] == bool(mem[(2 * ceil32(return_data.size)) + 228])
                                    if not mem[(2 * ceil32(return_data.size)) + 228]:
                                        revert with 0, 'ST'
                                    require ext_code.size(address(arg3))
                                    if address(arg1) < address(arg2):
                                        if address(arg1) == address(arg1):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
                                    else:
                                        if address(arg1) == address(arg2):
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args 0, (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), address(this.address), 128, 0, None
                                        else:
                                            call address(arg3).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args (10000 * arg5 * Mask(112, 0, ext_call.return_data[0])) - (arg4 * arg5 * Mask(112, 0, ext_call.return_data[0])) / (10000 * arg5) - (arg4 * arg5) + (10000 * Mask(112, 0, ext_call.return_data[32])), 0, address(this.address), 128, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}



}

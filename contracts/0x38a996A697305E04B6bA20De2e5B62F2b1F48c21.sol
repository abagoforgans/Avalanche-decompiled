contract main {




// =====================  Runtime code  =====================


#
#  - sub_1d9575a5(?)
#
mapping of uint8 stor0;
address adminAddress;

function admin() {
    return adminAddress
}

function _fallback() payable {
  stop
}

function changeAdmin(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require msg.sender == adminAddress
    if not arg1:
        revert with 0, 'new admin is the zero address'
    if ext_code.size(arg1):
        revert with 0, 'new admin is a contract'
    stor0[stor1] = 0
    adminAddress = arg1
    stor0[arg1] = 1
    return 1
}

function withdrawToken(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require msg.sender == adminAddress
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if arg2 > ext_call.return_data[0]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    71,
                    0x6e576974686472617720616d6f756e74206d75737420626520736d616c6c6572206f7220657175616c20746f2074686520617661696c61626c6520746f6b656e20616d6f756e74,
                    mem[235 len 25]
    call arg1 with:
       funct uint32(msg.sender)
         gas gas_remaining wei
        args Mask(224, 32, arg2) << 224, mem[260 len 4]
    require ext_call.success
    return 1
}

function sub_c0ce282a(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require (32 * ('cd', 4).length) + 128 >= 96 and (32 * ('cd', 4).length) + 128 <= test266151307()
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    s = cd[4] + 36
    t = 128
    u = 32 * ('cd', 4).length
    idx = 0
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        u = cd[s]
        idx = idx + 1
        continue 
    require msg.sender == adminAddress
    idx = 0
    while idx < ('cd', 4).length:
        require idx < ('cd', 4).length
        if ext_code.size(mem[(32 * idx) + 128]):
            revert with 0, 'callable cannot be a contract'
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 0
        stor0[mem[(32 * idx) + 140 len 20]] = 1
        idx = idx + 1
        continue 
    return 1
}

function withdrawEth(uint256 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    require msg.sender == adminAddress
    if not arg2:
        revert with 0, 'recipient cannot be 0 address'
    if not stor0[address(arg2)]:
        if arg2 != msg.sender:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        49,
                        0x77726563697069656e74206d75737420626520612063616c6c61626c652061646472657373206f72207468652061646d69,
                        mem[213 len 15]
    if arg1 > eth.balance(this.address):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    69,
                    0x54576974686472617720616d6f756e74206d75737420626520736d616c6c6572206f7220657175616c20746f2074686520617661696c61626c652065746820616d6f756e74,
                    mem[233 len 27]
    call arg2 with:
       value arg1 wei
         gas 2300 * is_zero(value) wei
    return bool(ext_call.success)
}

function sub_22466fee(?) {
    require calldata.size - 4 >= 96
    require cd[36] == bool(cd[36])
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    require ('cd', 68).length <= test266151307()
    require cd[68] + (160 * ('cd', 68).length) + 36 <= calldata.size
    require ('cd', 68).length <= test266151307()
    mem[96] = ('cd', 68).length
    mem[64] = (32 * ('cd', 68).length) + 128
    if not ('cd', 68).length:
        idx = 0
        s = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        t = 10000
        u = cd[4]
        while idx < ('cd', 68).length:
            require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
            require idx < ('cd', 68).length
            if uint16(cd[((160 * idx) + cd[68] + 100)]):
                require calldata.size + (-160 * idx) + -cd[68] - 36 >= 160
                _2964 = mem[64]
                require mem[64] + 160 <= test266151307() and mem[64] + 160 >= mem[64]
                mem[64] = mem[64] + 160
                require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
                mem[_2964] = cd[((160 * idx) + cd[68] + 36)]
                require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
                mem[_2964 + 32] = cd[((160 * idx) + cd[68] + 68)]
                require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
                mem[_2964 + 64] = cd[((160 * idx) + cd[68] + 100)]
                require cd[((160 * idx) + cd[68] + 132)] == uint16(cd[((160 * idx) + cd[68] + 132)])
                mem[_2964 + 96] = cd[((160 * idx) + cd[68] + 132)]
                require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
                mem[_2964 + 128] = cd[((160 * idx) + cd[68] + 164)]
                if 0 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                    mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                    mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                    mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 132)])
                    mem[mem[64] + 132] = uint16(cd[((160 * idx) + cd[68] + 164)])
                    require ext_code.size(0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99)
                    delegate 0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99.0x659ad184 with:
                         gas gas_remaining wei
                        args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), cd[((160 * idx) + cd[68] + 132)] << 240, uint16(cd[((160 * idx) + cd[68] + 164)])
                    mem[mem[64] len 64] = delegate.return_data[0 len 64]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3025 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _3043 = mem[_3025]
                    require mem[_3025 + 32] == bool(mem[_3025 + 32])
                    require idx < mem[96]
                    _3132 = mem[(32 * idx) + 128]
                    require idx < mem[96]
                    mem[mem[(32 * idx) + 128] + 32] = bool(mem[_3025 + 32])
                    mem[_3132] = _3043
                else:
                    if uint16(cd[((160 * idx) + cd[68] + 100)]) != 3:
                        if uint16(cd[((160 * idx) + cd[68] + 100)]) != 6:
                            if uint16(cd[((160 * idx) + cd[68] + 100)]) != 32:
                                revert with 0, 'exchangeType not exist'
                            mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                            mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                            mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 164)])
                            require ext_code.size(0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5)
                            delegate 0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5.0xb3072703 with:
                                 gas gas_remaining wei
                                args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), uint16(cd[((160 * idx) + cd[68] + 164)])
                            mem[mem[64] len 64] = delegate.return_data[0 len 64]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3052 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _3076 = mem[_3052]
                            require mem[_3052 + 32] == bool(mem[_3052 + 32])
                            require idx < mem[96]
                            _3174 = mem[(32 * idx) + 128]
                            require idx < mem[96]
                            mem[mem[(32 * idx) + 128] + 32] = bool(mem[_3052 + 32])
                            mem[_3174] = _3076
                        else:
                            _3022 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require 0 < mem[_3022]
                            mem[_3022 + 32] = address(s)
                            require 1 < mem[_3022]
                            mem[_3022 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).factory() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if mem[_3022] < 2:
                                revert with 0, 'UniswapV2Library: INVALID_PATH'
                            if 10000 == uint16(t):
                                _3112 = mem[_3022]
                                require mem[_3022] <= test266151307()
                                mem[_3022 + 96] = mem[_3022]
                                mem[64] = _3022 + (32 * mem[_3022]) + 128
                                if not _3112:
                                    require 0 < mem[_3022 + 96]
                                    mem[_3022 + 128] = u
                                    _7332 = mem[_3022]
                                    s = 0
                                    while s < _7332 - 1:
                                        require s < mem[_3022]
                                        _7361 = mem[(32 * s) + _3022 + 32]
                                        require s + 1 < mem[_3022]
                                        _7385 = mem[(32 * s + 1) + _3022 + 32]
                                        if mem[(32 * s) + _3022 + 44 len 20] == mem[(32 * s + 1) + _3022 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3022 + 44 len 20] < mem[(32 * s + 1) + _3022 + 44 len 20]:
                                            if not mem[(32 * s) + _3022 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3022 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7385)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3022 + 96]
                                            if mem[(32 * s) + _3022 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7361) == address(_7361):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3022 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3022 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7385)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3022 + 96]
                                            if mem[(32 * s) + _3022 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7385) == address(_7361):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3022 + 96]
                                    _7384 = mem[_3022 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7445 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7445] = _7384
                                    else:
                                        _7511 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7511] = _7384 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_3022 + 128 len 32 * _3112] = call.data[calldata.size len 32 * _3112]
                                    require 0 < mem[_3022 + 96]
                                    mem[_3022 + 128] = u
                                    _7333 = mem[_3022]
                                    s = 0
                                    while s < _7333 - 1:
                                        require s < mem[_3022]
                                        _7364 = mem[(32 * s) + _3022 + 32]
                                        require s + 1 < mem[_3022]
                                        _7387 = mem[(32 * s + 1) + _3022 + 32]
                                        if mem[(32 * s) + _3022 + 44 len 20] == mem[(32 * s + 1) + _3022 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3022 + 44 len 20] < mem[(32 * s + 1) + _3022 + 44 len 20]:
                                            if not mem[(32 * s) + _3022 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3022 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7387)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3022 + 96]
                                            if mem[(32 * s) + _3022 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7364) == address(_7364):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3022 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3022 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7387)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3022 + 96]
                                            if mem[(32 * s) + _3022 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7387) == address(_7364):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3022 + 96]
                                    _7386 = mem[_3022 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7452 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7452] = _7386
                                    else:
                                        _7515 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7515] = _7386 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                            else:
                                _3128 = mem[_3022]
                                require mem[_3022] <= test266151307()
                                mem[_3022 + 96] = mem[_3022]
                                mem[64] = _3022 + (32 * mem[_3022]) + 128
                                if not _3128:
                                    require 0 < mem[_3022 + 96]
                                    mem[_3022 + 128] = uint16(t) * u / 10000
                                    _7334 = mem[_3022]
                                    s = 0
                                    while s < _7334 - 1:
                                        require s < mem[_3022]
                                        _7367 = mem[(32 * s) + _3022 + 32]
                                        require s + 1 < mem[_3022]
                                        _7389 = mem[(32 * s + 1) + _3022 + 32]
                                        if mem[(32 * s) + _3022 + 44 len 20] == mem[(32 * s + 1) + _3022 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3022 + 44 len 20] < mem[(32 * s + 1) + _3022 + 44 len 20]:
                                            if not mem[(32 * s) + _3022 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3022 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7389)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3022 + 96]
                                            if mem[(32 * s) + _3022 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7367) == address(_7367):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3022 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3022 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7389)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3022 + 96]
                                            if mem[(32 * s) + _3022 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7389) == address(_7367):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3022 + 96]
                                    _7388 = mem[_3022 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7459 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7459] = _7388
                                    else:
                                        _7519 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7519] = _7388 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_3022 + 128 len 32 * _3128] = call.data[calldata.size len 32 * _3128]
                                    require 0 < mem[_3022 + 96]
                                    mem[_3022 + 128] = uint16(t) * u / 10000
                                    _7335 = mem[_3022]
                                    s = 0
                                    while s < _7335 - 1:
                                        require s < mem[_3022]
                                        _7370 = mem[(32 * s) + _3022 + 32]
                                        require s + 1 < mem[_3022]
                                        _7391 = mem[(32 * s + 1) + _3022 + 32]
                                        if mem[(32 * s) + _3022 + 44 len 20] == mem[(32 * s + 1) + _3022 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3022 + 44 len 20] < mem[(32 * s + 1) + _3022 + 44 len 20]:
                                            if not mem[(32 * s) + _3022 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3022 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7391)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3022 + 96]
                                            if mem[(32 * s) + _3022 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7370) == address(_7370):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3022 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3022 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7391)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3022 + 96]
                                            if mem[(32 * s) + _3022 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7391) == address(_7370):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 995 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (995 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3022 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3022 + 96]
                                                        mem[(32 * s + 1) + _3022 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3022 + 128] / mem[(32 * s) + _3022 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3022 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 0 / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3022 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3022 + 128]
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / 997 * mem[(32 * s) + _3022 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3022 + 96]
                                                                mem[(32 * s + 1) + _3022 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3022 + 128] / (997 * mem[(32 * s) + _3022 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3022 + 96]
                                    _7390 = mem[_3022 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7466 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7466] = _7390
                                    else:
                                        _7523 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7523] = _7390 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                    else:
                        _3018 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        require 0 < mem[_3018]
                        mem[_3018 + 32] = address(s)
                        require 1 < mem[_3018]
                        mem[_3018 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                        mem[_3018 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        if 10000 == uint16(t):
                            mem[_3018 + 100] = u
                            mem[_3018 + 132] = 64
                            mem[_3018 + 164] = mem[_3018]
                            s = 0
                            while s < 32 * mem[_3018]:
                                mem[s + _3018 + 196] = mem[s + _3018 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args u, 64, mem[_3018 + 164 len (32 * mem[_3018]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3018 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _3018 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _7404 = mem[_3018 + 96 len 4], Mask(224, 32, u) >> 32
                            require mem[_3018 + 96 len 4], Mask(224, 32, u) >> 32 <= 4294967296
                            require mem[_3018 + 96 len 4], Mask(224, 32, u) >> 32 + 32 <= return_data.size
                            require mem[_3018 + mem[_3018 + 96 len 4], Mask(224, 32, u) >> 32 + 96] <= 4294967296 and mem[_3018 + 96 len 4], Mask(224, 32, u) >> 32 + (32 * mem[_3018 + mem[_3018 + 96 len 4], Mask(224, 32, u) >> 32 + 96]) + 32 <= return_data.size
                            mem[_3018 + ceil32(return_data.size) + 96] = mem[_3018 + mem[_3018 + 96 len 4], Mask(224, 32, u) >> 32 + 96]
                            _7433 = mem[_3018 + _7404 + 96]
                            s = 0
                            while s < 32 * _7433:
                                mem[s + _3018 + ceil32(return_data.size) + 128] = mem[s + _3018 + _7404 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _7433) + _3018 + ceil32(return_data.size) + 128
                            require 1 < mem[_3018 + ceil32(return_data.size) + 96]
                            _11555 = mem[_3018 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _11566 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11566] = _11555
                            else:
                                _11580 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11580] = _11555 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                        else:
                            mem[_3018 + 100] = uint16(t) * u / 10000
                            mem[_3018 + 132] = 64
                            mem[_3018 + 164] = mem[_3018]
                            s = 0
                            while s < 32 * mem[_3018]:
                                mem[s + _3018 + 196] = mem[s + _3018 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args uint16(t) * u / 10000, 64, mem[_3018 + 164 len (32 * mem[_3018]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3018 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _3018 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _7406 = mem[_3018 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32
                            require mem[_3018 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 <= 4294967296
                            require mem[_3018 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 32 <= return_data.size
                            require mem[_3018 + mem[_3018 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96] <= 4294967296 and mem[_3018 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + (32 * mem[_3018 + mem[_3018 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]) + 32 <= return_data.size
                            mem[_3018 + ceil32(return_data.size) + 96] = mem[_3018 + mem[_3018 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]
                            _7434 = mem[_3018 + _7406 + 96]
                            s = 0
                            while s < 32 * _7434:
                                mem[s + _3018 + ceil32(return_data.size) + 128] = mem[s + _3018 + _7406 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _7434) + _3018 + ceil32(return_data.size) + 128
                            require 1 < mem[_3018 + ceil32(return_data.size) + 96]
                            _11556 = mem[_3018 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _11569 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11569] = _11556
                            else:
                                _11584 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11584] = _11556 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
            else:
                require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
                require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                call address(cd[((160 * idx) + cd[68] + 36)]).sync() with:
                     gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require idx < ('cd', 68).length
                require calldata.size + (-160 * idx) + -cd[68] - 36 >= 160
                _2970 = mem[64]
                require mem[64] + 160 <= test266151307() and mem[64] + 160 >= mem[64]
                mem[64] = mem[64] + 160
                require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
                mem[_2970] = cd[((160 * idx) + cd[68] + 36)]
                require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
                mem[_2970 + 32] = cd[((160 * idx) + cd[68] + 68)]
                require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
                mem[_2970 + 64] = cd[((160 * idx) + cd[68] + 100)]
                require cd[((160 * idx) + cd[68] + 132)] == uint16(cd[((160 * idx) + cd[68] + 132)])
                mem[_2970 + 96] = cd[((160 * idx) + cd[68] + 132)]
                require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
                mem[_2970 + 128] = cd[((160 * idx) + cd[68] + 164)]
                if 0 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                    mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                    mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                    mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 132)])
                    mem[mem[64] + 132] = uint16(cd[((160 * idx) + cd[68] + 164)])
                    require ext_code.size(0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99)
                    delegate 0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99.0x659ad184 with:
                         gas gas_remaining wei
                        args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), cd[((160 * idx) + cd[68] + 132)] << 240, uint16(cd[((160 * idx) + cd[68] + 164)])
                    mem[mem[64] len 64] = delegate.return_data[0 len 64]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3152 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _3183 = mem[_3152]
                    require mem[_3152 + 32] == bool(mem[_3152 + 32])
                    require idx < mem[96]
                    _3326 = mem[(32 * idx) + 128]
                    require idx < mem[96]
                    mem[mem[(32 * idx) + 128] + 32] = bool(mem[_3152 + 32])
                    mem[_3326] = _3183
                else:
                    if uint16(cd[((160 * idx) + cd[68] + 100)]) != 3:
                        if uint16(cd[((160 * idx) + cd[68] + 100)]) != 6:
                            if uint16(cd[((160 * idx) + cd[68] + 100)]) != 32:
                                revert with 0, 'exchangeType not exist'
                            mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                            mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                            mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 164)])
                            require ext_code.size(0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5)
                            delegate 0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5.0xb3072703 with:
                                 gas gas_remaining wei
                                args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), uint16(cd[((160 * idx) + cd[68] + 164)])
                            mem[mem[64] len 64] = delegate.return_data[0 len 64]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3200 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _3248 = mem[_3200]
                            require mem[_3200 + 32] == bool(mem[_3200 + 32])
                            require idx < mem[96]
                            _3412 = mem[(32 * idx) + 128]
                            require idx < mem[96]
                            mem[mem[(32 * idx) + 128] + 32] = bool(mem[_3200 + 32])
                            mem[_3412] = _3248
                        else:
                            _3149 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require 0 < mem[_3149]
                            mem[_3149 + 32] = address(s)
                            require 1 < mem[_3149]
                            mem[_3149 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).factory() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if mem[_3149] < 2:
                                revert with 0, 'UniswapV2Library: INVALID_PATH'
                            if 10000 == uint16(t):
                                _3298 = mem[_3149]
                                require mem[_3149] <= test266151307()
                                mem[_3149 + 96] = mem[_3149]
                                mem[64] = _3149 + (32 * mem[_3149]) + 128
                                if not _3298:
                                    require 0 < mem[_3149 + 96]
                                    mem[_3149 + 128] = u
                                    _7336 = mem[_3149]
                                    s = 0
                                    while s < _7336 - 1:
                                        require s < mem[_3149]
                                        _7373 = mem[(32 * s) + _3149 + 32]
                                        require s + 1 < mem[_3149]
                                        _7395 = mem[(32 * s + 1) + _3149 + 32]
                                        if mem[(32 * s) + _3149 + 44 len 20] == mem[(32 * s + 1) + _3149 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3149 + 44 len 20] < mem[(32 * s + 1) + _3149 + 44 len 20]:
                                            if not mem[(32 * s) + _3149 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3149 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7395)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3149 + 96]
                                            if mem[(32 * s) + _3149 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7373) == address(_7373):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3149 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3149 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7395)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3149 + 96]
                                            if mem[(32 * s) + _3149 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7395) == address(_7373):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3149 + 96]
                                    _7394 = mem[_3149 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7477 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7477] = _7394
                                    else:
                                        _7529 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7529] = _7394 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_3149 + 128 len 32 * _3298] = call.data[calldata.size len 32 * _3298]
                                    require 0 < mem[_3149 + 96]
                                    mem[_3149 + 128] = u
                                    _7337 = mem[_3149]
                                    s = 0
                                    while s < _7337 - 1:
                                        require s < mem[_3149]
                                        _7376 = mem[(32 * s) + _3149 + 32]
                                        require s + 1 < mem[_3149]
                                        _7397 = mem[(32 * s + 1) + _3149 + 32]
                                        if mem[(32 * s) + _3149 + 44 len 20] == mem[(32 * s + 1) + _3149 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3149 + 44 len 20] < mem[(32 * s + 1) + _3149 + 44 len 20]:
                                            if not mem[(32 * s) + _3149 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3149 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7397)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3149 + 96]
                                            if mem[(32 * s) + _3149 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7376) == address(_7376):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3149 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3149 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7397)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3149 + 96]
                                            if mem[(32 * s) + _3149 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7397) == address(_7376):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3149 + 96]
                                    _7396 = mem[_3149 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7484 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7484] = _7396
                                    else:
                                        _7533 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7533] = _7396 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                            else:
                                _3322 = mem[_3149]
                                require mem[_3149] <= test266151307()
                                mem[_3149 + 96] = mem[_3149]
                                mem[64] = _3149 + (32 * mem[_3149]) + 128
                                if not _3322:
                                    require 0 < mem[_3149 + 96]
                                    mem[_3149 + 128] = uint16(t) * u / 10000
                                    _7338 = mem[_3149]
                                    s = 0
                                    while s < _7338 - 1:
                                        require s < mem[_3149]
                                        _7379 = mem[(32 * s) + _3149 + 32]
                                        require s + 1 < mem[_3149]
                                        _7399 = mem[(32 * s + 1) + _3149 + 32]
                                        if mem[(32 * s) + _3149 + 44 len 20] == mem[(32 * s + 1) + _3149 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3149 + 44 len 20] < mem[(32 * s + 1) + _3149 + 44 len 20]:
                                            if not mem[(32 * s) + _3149 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3149 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7399)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3149 + 96]
                                            if mem[(32 * s) + _3149 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7379) == address(_7379):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3149 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3149 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7399)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3149 + 96]
                                            if mem[(32 * s) + _3149 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7399) == address(_7379):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3149 + 96]
                                    _7398 = mem[_3149 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7491 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7491] = _7398
                                    else:
                                        _7537 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7537] = _7398 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_3149 + 128 len 32 * _3322] = call.data[calldata.size len 32 * _3322]
                                    require 0 < mem[_3149 + 96]
                                    mem[_3149 + 128] = uint16(t) * u / 10000
                                    _7339 = mem[_3149]
                                    s = 0
                                    while s < _7339 - 1:
                                        require s < mem[_3149]
                                        _7382 = mem[(32 * s) + _3149 + 32]
                                        require s + 1 < mem[_3149]
                                        _7401 = mem[(32 * s + 1) + _3149 + 32]
                                        if mem[(32 * s) + _3149 + 44 len 20] == mem[(32 * s + 1) + _3149 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _3149 + 44 len 20] < mem[(32 * s + 1) + _3149 + 44 len 20]:
                                            if not mem[(32 * s) + _3149 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3149 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7401)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3149 + 96]
                                            if mem[(32 * s) + _3149 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7382) == address(_7382):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _3149 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _3149 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_7401)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_3149 + 96]
                                            if mem[(32 * s) + _3149 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_7401) == address(_7382):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 995 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (995 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _3149 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_3149 + 96]
                                                        mem[(32 * s + 1) + _3149 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _3149 + 128] / mem[(32 * s) + _3149 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _3149 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 0 / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _3149 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _3149 + 128]
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / 997 * mem[(32 * s) + _3149 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_3149 + 96]
                                                                mem[(32 * s + 1) + _3149 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _3149 + 128] / (997 * mem[(32 * s) + _3149 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_3149 + 96]
                                    _7400 = mem[_3149 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _7498 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7498] = _7400
                                    else:
                                        _7541 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_7541] = _7400 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                    else:
                        _3139 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        require 0 < mem[_3139]
                        mem[_3139 + 32] = address(s)
                        require 1 < mem[_3139]
                        mem[_3139 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                        mem[_3139 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        if 10000 == uint16(t):
                            mem[_3139 + 100] = u
                            mem[_3139 + 132] = 64
                            mem[_3139 + 164] = mem[_3139]
                            s = 0
                            while s < 32 * mem[_3139]:
                                mem[s + _3139 + 196] = mem[s + _3139 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args u, 64, mem[_3139 + 164 len (32 * mem[_3139]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3139 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _3139 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _7408 = mem[_3139 + 96 len 4], Mask(224, 32, u) >> 32
                            require mem[_3139 + 96 len 4], Mask(224, 32, u) >> 32 <= 4294967296
                            require mem[_3139 + 96 len 4], Mask(224, 32, u) >> 32 + 32 <= return_data.size
                            require mem[_3139 + mem[_3139 + 96 len 4], Mask(224, 32, u) >> 32 + 96] <= 4294967296 and mem[_3139 + 96 len 4], Mask(224, 32, u) >> 32 + (32 * mem[_3139 + mem[_3139 + 96 len 4], Mask(224, 32, u) >> 32 + 96]) + 32 <= return_data.size
                            mem[_3139 + ceil32(return_data.size) + 96] = mem[_3139 + mem[_3139 + 96 len 4], Mask(224, 32, u) >> 32 + 96]
                            _7435 = mem[_3139 + _7408 + 96]
                            s = 0
                            while s < 32 * _7435:
                                mem[s + _3139 + ceil32(return_data.size) + 128] = mem[s + _3139 + _7408 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _7435) + _3139 + ceil32(return_data.size) + 128
                            require 1 < mem[_3139 + ceil32(return_data.size) + 96]
                            _11557 = mem[_3139 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _11572 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11572] = _11557
                            else:
                                _11588 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11588] = _11557 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                        else:
                            mem[_3139 + 100] = uint16(t) * u / 10000
                            mem[_3139 + 132] = 64
                            mem[_3139 + 164] = mem[_3139]
                            s = 0
                            while s < 32 * mem[_3139]:
                                mem[s + _3139 + 196] = mem[s + _3139 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args uint16(t) * u / 10000, 64, mem[_3139 + 164 len (32 * mem[_3139]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3139 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _3139 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _7410 = mem[_3139 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32
                            require mem[_3139 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 <= 4294967296
                            require mem[_3139 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 32 <= return_data.size
                            require mem[_3139 + mem[_3139 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96] <= 4294967296 and mem[_3139 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + (32 * mem[_3139 + mem[_3139 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]) + 32 <= return_data.size
                            mem[_3139 + ceil32(return_data.size) + 96] = mem[_3139 + mem[_3139 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]
                            _7436 = mem[_3139 + _7410 + 96]
                            s = 0
                            while s < 32 * _7436:
                                mem[s + _3139 + ceil32(return_data.size) + 128] = mem[s + _3139 + _7410 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _7436) + _3139 + ceil32(return_data.size) + 128
                            require 1 < mem[_3139 + ceil32(return_data.size) + 96]
                            _11558 = mem[_3139 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _11575 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11575] = _11558
                            else:
                                _11592 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_11592] = _11558 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
            require idx < mem[96]
            require idx < ('cd', 68).length
            require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
            require idx < ('cd', 68).length
            require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
            idx = idx + 1
            s = cd[((160 * idx) + cd[68] + 68)]
            t = cd[((160 * idx) + cd[68] + 164)]
            u = mem[mem[(32 * idx) + 128]]
            continue 
        idx = 0
        s = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        t = cd[4]
        while idx < ('cd', 68).length:
            require idx < mem[96]
            _7359 = mem[mem[(32 * idx) + 128]]
            require idx < ('cd', 68).length
            require calldata.size + (-160 * idx) + -cd[68] - 36 >= 160
            _7412 = mem[64]
            require mem[64] + 160 <= test266151307() and mem[64] + 160 >= mem[64]
            mem[64] = mem[64] + 160
            require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
            mem[_7412] = cd[((160 * idx) + cd[68] + 36)]
            require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
            mem[_7412 + 32] = cd[((160 * idx) + cd[68] + 68)]
            require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
            mem[_7412 + 64] = cd[((160 * idx) + cd[68] + 100)]
            require cd[((160 * idx) + cd[68] + 132)] == uint16(cd[((160 * idx) + cd[68] + 132)])
            mem[_7412 + 96] = cd[((160 * idx) + cd[68] + 132)]
            require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
            mem[_7412 + 128] = cd[((160 * idx) + cd[68] + 164)]
            if not uint16(cd[((160 * idx) + cd[68] + 100)]):
                mem[mem[64]] = 0xa58d57400000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                mem[mem[64] + 36] = t
                mem[mem[64] + 68] = _7359
                mem[mem[64] + 100] = address(s)
                mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 68)])
                mem[mem[64] + 164] = address(cd[((160 * idx) + cd[68] + 36)])
                mem[mem[64] + 196] = bool(cd[36])
                mem[mem[64] + 228] = uint16(cd[((160 * idx) + cd[68] + 132)])
                require ext_code.size(0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99)
                delegate 0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99.0xa58d574 with:
                     gas gas_remaining wei
                    args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, _7359, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36]), uint16(cd[((160 * idx) + cd[68] + 132)])
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
            else:
                if 3 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                    mem[mem[64]] = 0x9f22937f00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                    mem[mem[64] + 36] = t
                    mem[mem[64] + 68] = address(s)
                    mem[mem[64] + 100] = address(cd[((160 * idx) + cd[68] + 68)])
                    mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 36)])
                    mem[mem[64] + 164] = bool(cd[36])
                    require ext_code.size(0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e)
                    delegate 0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e.0x9f22937f with:
                         gas gas_remaining wei
                        args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36])
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                else:
                    if 6 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                        mem[mem[64]] = 0x9f22937f00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                        mem[mem[64] + 36] = t
                        mem[mem[64] + 68] = address(s)
                        mem[mem[64] + 100] = address(cd[((160 * idx) + cd[68] + 68)])
                        mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 36)])
                        mem[mem[64] + 164] = bool(cd[36])
                        require ext_code.size(0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e)
                        delegate 0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e.0x9f22937f with:
                             gas gas_remaining wei
                            args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36])
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        if 32 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                            mem[mem[64]] = 0x35d92d6900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                            mem[mem[64] + 36] = t
                            mem[mem[64] + 68] = _7359
                            mem[mem[64] + 100] = address(s)
                            mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 68)])
                            mem[mem[64] + 164] = address(cd[((160 * idx) + cd[68] + 36)])
                            mem[mem[64] + 196] = bool(cd[36])
                            require ext_code.size(0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5)
                            delegate 0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5.0x35d92d69 with:
                                 gas gas_remaining wei
                                args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, _7359, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36])
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
            require idx < mem[96]
            require idx < ('cd', 68).length
            require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
            idx = idx + 1
            s = cd[((160 * idx) + cd[68] + 68)]
            t = mem[mem[(32 * idx) + 128]]
            continue 
    else:
        mem[64] = (32 * ('cd', 68).length) + 192
        mem[(32 * ('cd', 68).length) + 128] = 0
        mem[(32 * ('cd', 68).length) + 160] = 0
        mem[var23001] = (32 * ('cd', 68).length) + 128
        s = var23001
        idx = var23002
        while idx - 1:
            mem[64] = mem[64] + 64
            mem[(32 * ('cd', 68).length) + 128] = 0
            mem[(32 * ('cd', 68).length) + 160] = 0
            mem[s + 32] = (32 * ('cd', 68).length) + 128
            s = s + 32
            idx = idx - 1
            continue 
        idx = 0
        s = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        t = 10000
        u = cd[4]
        while idx < ('cd', 68).length:
            require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
            require idx < ('cd', 68).length
            if uint16(cd[((160 * idx) + cd[68] + 100)]):
                require calldata.size + (-160 * idx) + -cd[68] - 36 >= 160
                _11619 = mem[64]
                require mem[64] + 160 <= test266151307() and mem[64] + 160 >= mem[64]
                mem[64] = mem[64] + 160
                require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
                mem[_11619] = cd[((160 * idx) + cd[68] + 36)]
                require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
                mem[_11619 + 32] = cd[((160 * idx) + cd[68] + 68)]
                require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
                mem[_11619 + 64] = cd[((160 * idx) + cd[68] + 100)]
                require cd[((160 * idx) + cd[68] + 132)] == uint16(cd[((160 * idx) + cd[68] + 132)])
                mem[_11619 + 96] = cd[((160 * idx) + cd[68] + 132)]
                require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
                mem[_11619 + 128] = cd[((160 * idx) + cd[68] + 164)]
                if 0 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                    mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                    mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                    mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 132)])
                    mem[mem[64] + 132] = uint16(cd[((160 * idx) + cd[68] + 164)])
                    require ext_code.size(0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99)
                    delegate 0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99.0x659ad184 with:
                         gas gas_remaining wei
                        args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), cd[((160 * idx) + cd[68] + 132)] << 240, uint16(cd[((160 * idx) + cd[68] + 164)])
                    mem[mem[64] len 64] = delegate.return_data[0 len 64]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    _11676 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _11687 = mem[_11676]
                    require mem[_11676 + 32] == bool(mem[_11676 + 32])
                    require idx < mem[96]
                    _11745 = mem[(32 * idx) + 128]
                    require idx < mem[96]
                    mem[mem[(32 * idx) + 128] + 32] = bool(mem[_11676 + 32])
                    mem[_11745] = _11687
                else:
                    if uint16(cd[((160 * idx) + cd[68] + 100)]) != 3:
                        if uint16(cd[((160 * idx) + cd[68] + 100)]) != 6:
                            if uint16(cd[((160 * idx) + cd[68] + 100)]) != 32:
                                revert with 0, 'exchangeType not exist'
                            mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                            mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                            mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 164)])
                            require ext_code.size(0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5)
                            delegate 0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5.0xb3072703 with:
                                 gas gas_remaining wei
                                args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), uint16(cd[((160 * idx) + cd[68] + 164)])
                            mem[mem[64] len 64] = delegate.return_data[0 len 64]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            _11692 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _11704 = mem[_11692]
                            require mem[_11692 + 32] == bool(mem[_11692 + 32])
                            require idx < mem[96]
                            _11773 = mem[(32 * idx) + 128]
                            require idx < mem[96]
                            mem[mem[(32 * idx) + 128] + 32] = bool(mem[_11692 + 32])
                            mem[_11773] = _11704
                        else:
                            _11673 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require 0 < mem[_11673]
                            mem[_11673 + 32] = address(s)
                            require 1 < mem[_11673]
                            mem[_11673 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).factory() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if mem[_11673] < 2:
                                revert with 0, 'UniswapV2Library: INVALID_PATH'
                            if 10000 == uint16(t):
                                _11728 = mem[_11673]
                                require mem[_11673] <= test266151307()
                                mem[_11673 + 96] = mem[_11673]
                                mem[64] = _11673 + (32 * mem[_11673]) + 128
                                if not _11728:
                                    require 0 < mem[_11673 + 96]
                                    mem[_11673 + 128] = u
                                    _14509 = mem[_11673]
                                    s = 0
                                    while s < _14509 - 1:
                                        require s < mem[_11673]
                                        _14537 = mem[(32 * s) + _11673 + 32]
                                        require s + 1 < mem[_11673]
                                        _14561 = mem[(32 * s + 1) + _11673 + 32]
                                        if mem[(32 * s) + _11673 + 44 len 20] == mem[(32 * s + 1) + _11673 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _11673 + 44 len 20] < mem[(32 * s + 1) + _11673 + 44 len 20]:
                                            if not mem[(32 * s) + _11673 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11673 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14561)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11673 + 96]
                                            if mem[(32 * s) + _11673 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14537) == address(_14537):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _11673 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11673 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14561)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11673 + 96]
                                            if mem[(32 * s) + _11673 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14561) == address(_14537):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_11673 + 96]
                                    _14560 = mem[_11673 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14621 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14621] = _14560
                                    else:
                                        _14687 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14687] = _14560 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_11673 + 128 len 32 * _11728] = call.data[calldata.size len 32 * _11728]
                                    require 0 < mem[_11673 + 96]
                                    mem[_11673 + 128] = u
                                    _14510 = mem[_11673]
                                    s = 0
                                    while s < _14510 - 1:
                                        require s < mem[_11673]
                                        _14540 = mem[(32 * s) + _11673 + 32]
                                        require s + 1 < mem[_11673]
                                        _14563 = mem[(32 * s + 1) + _11673 + 32]
                                        if mem[(32 * s) + _11673 + 44 len 20] == mem[(32 * s + 1) + _11673 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _11673 + 44 len 20] < mem[(32 * s + 1) + _11673 + 44 len 20]:
                                            if not mem[(32 * s) + _11673 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11673 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14563)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11673 + 96]
                                            if mem[(32 * s) + _11673 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14540) == address(_14540):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _11673 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11673 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14563)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11673 + 96]
                                            if mem[(32 * s) + _11673 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14563) == address(_14540):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_11673 + 96]
                                    _14562 = mem[_11673 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14628 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14628] = _14562
                                    else:
                                        _14691 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14691] = _14562 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                            else:
                                _11741 = mem[_11673]
                                require mem[_11673] <= test266151307()
                                mem[_11673 + 96] = mem[_11673]
                                mem[64] = _11673 + (32 * mem[_11673]) + 128
                                if not _11741:
                                    require 0 < mem[_11673 + 96]
                                    mem[_11673 + 128] = uint16(t) * u / 10000
                                    _14511 = mem[_11673]
                                    s = 0
                                    while s < _14511 - 1:
                                        require s < mem[_11673]
                                        _14543 = mem[(32 * s) + _11673 + 32]
                                        require s + 1 < mem[_11673]
                                        _14565 = mem[(32 * s + 1) + _11673 + 32]
                                        if mem[(32 * s) + _11673 + 44 len 20] == mem[(32 * s + 1) + _11673 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _11673 + 44 len 20] < mem[(32 * s + 1) + _11673 + 44 len 20]:
                                            if not mem[(32 * s) + _11673 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11673 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14565)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11673 + 96]
                                            if mem[(32 * s) + _11673 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14543) == address(_14543):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _11673 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11673 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14565)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11673 + 96]
                                            if mem[(32 * s) + _11673 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14565) == address(_14543):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_11673 + 96]
                                    _14564 = mem[_11673 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14635 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14635] = _14564
                                    else:
                                        _14695 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14695] = _14564 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_11673 + 128 len 32 * _11741] = call.data[calldata.size len 32 * _11741]
                                    require 0 < mem[_11673 + 96]
                                    mem[_11673 + 128] = uint16(t) * u / 10000
                                    _14512 = mem[_11673]
                                    s = 0
                                    while s < _14512 - 1:
                                        require s < mem[_11673]
                                        _14546 = mem[(32 * s) + _11673 + 32]
                                        require s + 1 < mem[_11673]
                                        _14567 = mem[(32 * s + 1) + _11673 + 32]
                                        if mem[(32 * s) + _11673 + 44 len 20] == mem[(32 * s + 1) + _11673 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _11673 + 44 len 20] < mem[(32 * s + 1) + _11673 + 44 len 20]:
                                            if not mem[(32 * s) + _11673 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11673 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14567)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11673 + 96]
                                            if mem[(32 * s) + _11673 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14546) == address(_14546):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _11673 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11673 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14567)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11673 + 96]
                                            if mem[(32 * s) + _11673 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14567) == address(_14546):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 995 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (995 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11673 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11673 + 96]
                                                        mem[(32 * s + 1) + _11673 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11673 + 128] / mem[(32 * s) + _11673 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11673 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 0 / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11673 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11673 + 128]
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / 997 * mem[(32 * s) + _11673 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11673 + 96]
                                                                mem[(32 * s + 1) + _11673 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11673 + 128] / (997 * mem[(32 * s) + _11673 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_11673 + 96]
                                    _14566 = mem[_11673 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14642 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14642] = _14566
                                    else:
                                        _14699 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14699] = _14566 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                    else:
                        _11669 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        require 0 < mem[_11669]
                        mem[_11669 + 32] = address(s)
                        require 1 < mem[_11669]
                        mem[_11669 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                        mem[_11669 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        if 10000 == uint16(t):
                            mem[_11669 + 100] = u
                            mem[_11669 + 132] = 64
                            mem[_11669 + 164] = mem[_11669]
                            s = 0
                            while s < 32 * mem[_11669]:
                                mem[s + _11669 + 196] = mem[s + _11669 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args u, 64, mem[_11669 + 164 len (32 * mem[_11669]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_11669 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _11669 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _14580 = mem[_11669 + 96 len 4], Mask(224, 32, u) >> 32
                            require mem[_11669 + 96 len 4], Mask(224, 32, u) >> 32 <= 4294967296
                            require mem[_11669 + 96 len 4], Mask(224, 32, u) >> 32 + 32 <= return_data.size
                            require mem[_11669 + mem[_11669 + 96 len 4], Mask(224, 32, u) >> 32 + 96] <= 4294967296 and mem[_11669 + 96 len 4], Mask(224, 32, u) >> 32 + (32 * mem[_11669 + mem[_11669 + 96 len 4], Mask(224, 32, u) >> 32 + 96]) + 32 <= return_data.size
                            mem[_11669 + ceil32(return_data.size) + 96] = mem[_11669 + mem[_11669 + 96 len 4], Mask(224, 32, u) >> 32 + 96]
                            _14609 = mem[_11669 + _14580 + 96]
                            s = 0
                            while s < 32 * _14609:
                                mem[s + _11669 + ceil32(return_data.size) + 128] = mem[s + _11669 + _14580 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _14609) + _11669 + ceil32(return_data.size) + 128
                            require 1 < mem[_11669 + ceil32(return_data.size) + 96]
                            _17253 = mem[_11669 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _17261 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17261] = _17253
                            else:
                                _17275 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17275] = _17253 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                        else:
                            mem[_11669 + 100] = uint16(t) * u / 10000
                            mem[_11669 + 132] = 64
                            mem[_11669 + 164] = mem[_11669]
                            s = 0
                            while s < 32 * mem[_11669]:
                                mem[s + _11669 + 196] = mem[s + _11669 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args uint16(t) * u / 10000, 64, mem[_11669 + 164 len (32 * mem[_11669]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_11669 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _11669 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _14582 = mem[_11669 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32
                            require mem[_11669 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 <= 4294967296
                            require mem[_11669 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 32 <= return_data.size
                            require mem[_11669 + mem[_11669 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96] <= 4294967296 and mem[_11669 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + (32 * mem[_11669 + mem[_11669 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]) + 32 <= return_data.size
                            mem[_11669 + ceil32(return_data.size) + 96] = mem[_11669 + mem[_11669 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]
                            _14610 = mem[_11669 + _14582 + 96]
                            s = 0
                            while s < 32 * _14610:
                                mem[s + _11669 + ceil32(return_data.size) + 128] = mem[s + _11669 + _14582 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _14610) + _11669 + ceil32(return_data.size) + 128
                            require 1 < mem[_11669 + ceil32(return_data.size) + 96]
                            _17254 = mem[_11669 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _17264 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17264] = _17254
                            else:
                                _17279 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17279] = _17254 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
            else:
                require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
                require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                call address(cd[((160 * idx) + cd[68] + 36)]).sync() with:
                     gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require idx < ('cd', 68).length
                require calldata.size + (-160 * idx) + -cd[68] - 36 >= 160
                _11622 = mem[64]
                require mem[64] + 160 <= test266151307() and mem[64] + 160 >= mem[64]
                mem[64] = mem[64] + 160
                require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
                mem[_11622] = cd[((160 * idx) + cd[68] + 36)]
                require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
                mem[_11622 + 32] = cd[((160 * idx) + cd[68] + 68)]
                require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
                mem[_11622 + 64] = cd[((160 * idx) + cd[68] + 100)]
                require cd[((160 * idx) + cd[68] + 132)] == uint16(cd[((160 * idx) + cd[68] + 132)])
                mem[_11622 + 96] = cd[((160 * idx) + cd[68] + 132)]
                require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
                mem[_11622 + 128] = cd[((160 * idx) + cd[68] + 164)]
                if 0 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                    mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                    mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                    mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 132)])
                    mem[mem[64] + 132] = uint16(cd[((160 * idx) + cd[68] + 164)])
                    require ext_code.size(0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99)
                    delegate 0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99.0x659ad184 with:
                         gas gas_remaining wei
                        args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), cd[((160 * idx) + cd[68] + 132)] << 240, uint16(cd[((160 * idx) + cd[68] + 164)])
                    mem[mem[64] len 64] = delegate.return_data[0 len 64]
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                    _11763 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 64
                    _11782 = mem[_11763]
                    require mem[_11763 + 32] == bool(mem[_11763 + 32])
                    require idx < mem[96]
                    _11865 = mem[(32 * idx) + 128]
                    require idx < mem[96]
                    mem[mem[(32 * idx) + 128] + 32] = bool(mem[_11763 + 32])
                    mem[_11865] = _11782
                else:
                    if uint16(cd[((160 * idx) + cd[68] + 100)]) != 3:
                        if uint16(cd[((160 * idx) + cd[68] + 100)]) != 6:
                            if uint16(cd[((160 * idx) + cd[68] + 100)]) != 32:
                                revert with 0, 'exchangeType not exist'
                            mem[mem[64] + 36] = address(cd[((160 * idx) + cd[68] + 68)])
                            mem[mem[64] + 68] = address(cd[((160 * idx) + cd[68] + 36)])
                            mem[mem[64] + 100] = uint16(cd[((160 * idx) + cd[68] + 164)])
                            require ext_code.size(0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5)
                            delegate 0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5.0xb3072703 with:
                                 gas gas_remaining wei
                                args u, address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), uint16(cd[((160 * idx) + cd[68] + 164)])
                            mem[mem[64] len 64] = delegate.return_data[0 len 64]
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
                            _11792 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 64
                            _11820 = mem[_11792]
                            require mem[_11792 + 32] == bool(mem[_11792 + 32])
                            require idx < mem[96]
                            _11931 = mem[(32 * idx) + 128]
                            require idx < mem[96]
                            mem[mem[(32 * idx) + 128] + 32] = bool(mem[_11792 + 32])
                            mem[_11931] = _11820
                        else:
                            _11760 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require 0 < mem[_11760]
                            mem[_11760 + 32] = address(s)
                            require 1 < mem[_11760]
                            mem[_11760 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).factory() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if mem[_11760] < 2:
                                revert with 0, 'UniswapV2Library: INVALID_PATH'
                            if 10000 == uint16(t):
                                _11845 = mem[_11760]
                                require mem[_11760] <= test266151307()
                                mem[_11760 + 96] = mem[_11760]
                                mem[64] = _11760 + (32 * mem[_11760]) + 128
                                if not _11845:
                                    require 0 < mem[_11760 + 96]
                                    mem[_11760 + 128] = u
                                    _14513 = mem[_11760]
                                    s = 0
                                    while s < _14513 - 1:
                                        require s < mem[_11760]
                                        _14549 = mem[(32 * s) + _11760 + 32]
                                        require s + 1 < mem[_11760]
                                        _14571 = mem[(32 * s + 1) + _11760 + 32]
                                        if mem[(32 * s) + _11760 + 44 len 20] == mem[(32 * s + 1) + _11760 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _11760 + 44 len 20] < mem[(32 * s + 1) + _11760 + 44 len 20]:
                                            if not mem[(32 * s) + _11760 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11760 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14571)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11760 + 96]
                                            if mem[(32 * s) + _11760 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14549) == address(_14549):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _11760 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11760 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14571)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11760 + 96]
                                            if mem[(32 * s) + _11760 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14571) == address(_14549):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_11760 + 96]
                                    _14570 = mem[_11760 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14653 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14653] = _14570
                                    else:
                                        _14705 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14705] = _14570 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_11760 + 128 len 32 * _11845] = call.data[calldata.size len 32 * _11845]
                                    require 0 < mem[_11760 + 96]
                                    mem[_11760 + 128] = u
                                    _14514 = mem[_11760]
                                    s = 0
                                    while s < _14514 - 1:
                                        require s < mem[_11760]
                                        _14552 = mem[(32 * s) + _11760 + 32]
                                        require s + 1 < mem[_11760]
                                        _14573 = mem[(32 * s + 1) + _11760 + 32]
                                        if mem[(32 * s) + _11760 + 44 len 20] == mem[(32 * s + 1) + _11760 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _11760 + 44 len 20] < mem[(32 * s + 1) + _11760 + 44 len 20]:
                                            if not mem[(32 * s) + _11760 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11760 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14573)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11760 + 96]
                                            if mem[(32 * s) + _11760 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14552) == address(_14552):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _11760 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11760 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14573)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11760 + 96]
                                            if mem[(32 * s) + _11760 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14573) == address(_14552):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_11760 + 96]
                                    _14572 = mem[_11760 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14660 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14660] = _14572
                                    else:
                                        _14709 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14709] = _14572 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                            else:
                                _11861 = mem[_11760]
                                require mem[_11760] <= test266151307()
                                mem[_11760 + 96] = mem[_11760]
                                mem[64] = _11760 + (32 * mem[_11760]) + 128
                                if not _11861:
                                    require 0 < mem[_11760 + 96]
                                    mem[_11760 + 128] = uint16(t) * u / 10000
                                    _14515 = mem[_11760]
                                    s = 0
                                    while s < _14515 - 1:
                                        require s < mem[_11760]
                                        _14555 = mem[(32 * s) + _11760 + 32]
                                        require s + 1 < mem[_11760]
                                        _14575 = mem[(32 * s + 1) + _11760 + 32]
                                        if mem[(32 * s) + _11760 + 44 len 20] == mem[(32 * s + 1) + _11760 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _11760 + 44 len 20] < mem[(32 * s + 1) + _11760 + 44 len 20]:
                                            if not mem[(32 * s) + _11760 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11760 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14575)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11760 + 96]
                                            if mem[(32 * s) + _11760 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14555) == address(_14555):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _11760 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11760 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14575)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11760 + 96]
                                            if mem[(32 * s) + _11760 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14575) == address(_14555):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_11760 + 96]
                                    _14574 = mem[_11760 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14667 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14667] = _14574
                                    else:
                                        _14713 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14713] = _14574 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                                else:
                                    mem[_11760 + 128 len 32 * _11861] = call.data[calldata.size len 32 * _11861]
                                    require 0 < mem[_11760 + 96]
                                    mem[_11760 + 128] = uint16(t) * u / 10000
                                    _14516 = mem[_11760]
                                    s = 0
                                    while s < _14516 - 1:
                                        require s < mem[_11760]
                                        _14558 = mem[(32 * s) + _11760 + 32]
                                        require s + 1 < mem[_11760]
                                        _14577 = mem[(32 * s + 1) + _11760 + 32]
                                        if mem[(32 * s) + _11760 + 44 len 20] == mem[(32 * s + 1) + _11760 + 44 len 20]:
                                            revert with 0, 32, 37, 0xfe556e697377617056324c6962726172793a204944454e544943414c5f4144445245535345, mem[mem[64] + 105 len 27]
                                        if mem[(32 * s) + _11760 + 44 len 20] < mem[(32 * s + 1) + _11760 + 44 len 20]:
                                            if not mem[(32 * s) + _11760 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11760 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14577)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11760 + 96]
                                            if mem[(32 * s) + _11760 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14558) == address(_14558):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        else:
                                            if not mem[(32 * s + 1) + _11760 + 44 len 20]:
                                                revert with 0, 'UniswapV2Library: ZERO_ADDRESS'
                                            mem[mem[64] + 4] = mem[(32 * s) + _11760 + 44 len 20]
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getPair(address arg1, address arg2) with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4], address(_14577)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).getReserves() with:
                                                    gas gas_remaining wei
                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            require ext_code.size(address(ext_call.return_data[0]))
                                            staticcall address(ext_call.return_data[0]).0x3f8bfb0 with:
                                                    gas gas_remaining wei
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require s < mem[_11760 + 96]
                                            if mem[(32 * s) + _11760 + 128] <= 0:
                                                revert with 0, 
                                                            32,
                                                            43,
                                                            0x2e556e697377617056324c6962726172793a20494e53554646494349454e545f494e5055545f414d4f554e,
                                                            mem[mem[64] + 111 len 21]
                                            if address(_14577) == address(_14558):
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[0])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[0]) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[0])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[0])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[32]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[0]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0])) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[32]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[0]))
                                            else:
                                                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x53556e697377617056324c6962726172793a20494e53554646494349454e545f4c49515549444954,
                                                                mem[mem[64] + 108 len 24]
                                                if ext_call.return_data[0]:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 995 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 995:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 995 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 995 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 995 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 995 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 995 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (995 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                else:
                                                    if not mem[(32 * s) + _11760 + 128]:
                                                        require Mask(112, 0, ext_call.return_data[32])
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if 1000 * Mask(112, 0, ext_call.return_data[32]) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        require 1000 * Mask(112, 0, ext_call.return_data[32])
                                                        require s + 1 < mem[_11760 + 96]
                                                        mem[(32 * s + 1) + _11760 + 128] = 0 / 1000 * Mask(112, 0, ext_call.return_data[32])
                                                    else:
                                                        if 997 * mem[(32 * s) + _11760 + 128] / mem[(32 * s) + _11760 + 128] != 997:
                                                            revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                        if not 997 * mem[(32 * s) + _11760 + 128]:
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 0 / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                        else:
                                                            if 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128] != Mask(112, 0, ext_call.return_data[0]):
                                                                revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                            if not Mask(112, 0, ext_call.return_data[32]):
                                                                if 997 * mem[(32 * s) + _11760 + 128] < 0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require 997 * mem[(32 * s) + _11760 + 128]
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / 997 * mem[(32 * s) + _11760 + 128]
                                                            else:
                                                                if 1000 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 1000:
                                                                    revert with 0, 32, 33, 0x59536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                                if (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32])) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                require (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                                                require s + 1 < mem[_11760 + 96]
                                                                mem[(32 * s + 1) + _11760 + 128] = 997 * Mask(112, 0, ext_call.return_data[0]) * mem[(32 * s) + _11760 + 128] / (997 * mem[(32 * s) + _11760 + 128]) + (1000 * Mask(112, 0, ext_call.return_data[32]))
                                        s = s + 1
                                        continue 
                                    require 1 < mem[_11760 + 96]
                                    _14576 = mem[_11760 + 160]
                                    require idx < mem[96]
                                    if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                        _14674 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14674] = _14576
                                    else:
                                        _14717 = mem[(32 * idx) + 128]
                                        require idx < mem[96]
                                        mem[mem[(32 * idx) + 128] + 32] = 0
                                        mem[_14717] = _14576 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                    else:
                        _11752 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        require 0 < mem[_11752]
                        mem[_11752 + 32] = address(s)
                        require 1 < mem[_11752]
                        mem[_11752 + 64] = address(cd[((160 * idx) + cd[68] + 68)])
                        mem[_11752 + 96] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        if 10000 == uint16(t):
                            mem[_11752 + 100] = u
                            mem[_11752 + 132] = 64
                            mem[_11752 + 164] = mem[_11752]
                            s = 0
                            while s < 32 * mem[_11752]:
                                mem[s + _11752 + 196] = mem[s + _11752 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args u, 64, mem[_11752 + 164 len (32 * mem[_11752]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_11752 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _11752 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _14584 = mem[_11752 + 96 len 4], Mask(224, 32, u) >> 32
                            require mem[_11752 + 96 len 4], Mask(224, 32, u) >> 32 <= 4294967296
                            require mem[_11752 + 96 len 4], Mask(224, 32, u) >> 32 + 32 <= return_data.size
                            require mem[_11752 + mem[_11752 + 96 len 4], Mask(224, 32, u) >> 32 + 96] <= 4294967296 and mem[_11752 + 96 len 4], Mask(224, 32, u) >> 32 + (32 * mem[_11752 + mem[_11752 + 96 len 4], Mask(224, 32, u) >> 32 + 96]) + 32 <= return_data.size
                            mem[_11752 + ceil32(return_data.size) + 96] = mem[_11752 + mem[_11752 + 96 len 4], Mask(224, 32, u) >> 32 + 96]
                            _14611 = mem[_11752 + _14584 + 96]
                            s = 0
                            while s < 32 * _14611:
                                mem[s + _11752 + ceil32(return_data.size) + 128] = mem[s + _11752 + _14584 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _14611) + _11752 + ceil32(return_data.size) + 128
                            require 1 < mem[_11752 + ceil32(return_data.size) + 96]
                            _17255 = mem[_11752 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _17267 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17267] = _17255
                            else:
                                _17283 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17283] = _17255 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
                        else:
                            mem[_11752 + 100] = uint16(t) * u / 10000
                            mem[_11752 + 132] = 64
                            mem[_11752 + 164] = mem[_11752]
                            s = 0
                            while s < 32 * mem[_11752]:
                                mem[s + _11752 + 196] = mem[s + _11752 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(address(cd[((160 * idx) + cd[68] + 36)]))
                            staticcall address(cd[((160 * idx) + cd[68] + 36)]).getAmountsOut(uint256 arg1, address[] arg2) with:
                                    gas gas_remaining wei
                                   args uint16(t) * u / 10000, 64, mem[_11752 + 164 len (32 * mem[_11752]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_11752 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _11752 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _14586 = mem[_11752 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32
                            require mem[_11752 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 <= 4294967296
                            require mem[_11752 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 32 <= return_data.size
                            require mem[_11752 + mem[_11752 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96] <= 4294967296 and mem[_11752 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + (32 * mem[_11752 + mem[_11752 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]) + 32 <= return_data.size
                            mem[_11752 + ceil32(return_data.size) + 96] = mem[_11752 + mem[_11752 + 96 len 4], Mask(224, 32, uint16(t) * u / 10000) >> 32 + 96]
                            _14612 = mem[_11752 + _14586 + 96]
                            s = 0
                            while s < 32 * _14612:
                                mem[s + _11752 + ceil32(return_data.size) + 128] = mem[s + _11752 + _14586 + 128]
                                s = s + 32
                                continue 
                            mem[64] = (32 * _14612) + _11752 + ceil32(return_data.size) + 128
                            require 1 < mem[_11752 + ceil32(return_data.size) + 96]
                            _17256 = mem[_11752 + ceil32(return_data.size) + 160]
                            require idx < mem[96]
                            if 10000 == uint16(cd[((160 * idx) + cd[68] + 164)]):
                                _17270 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17270] = _17256
                            else:
                                _17287 = mem[(32 * idx) + 128]
                                require idx < mem[96]
                                mem[mem[(32 * idx) + 128] + 32] = 0
                                mem[_17287] = _17256 * uint16(cd[((160 * idx) + cd[68] + 164)]) / 10000
            require idx < mem[96]
            require idx < ('cd', 68).length
            require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
            require idx < ('cd', 68).length
            require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
            idx = idx + 1
            s = cd[((160 * idx) + cd[68] + 68)]
            t = cd[((160 * idx) + cd[68] + 164)]
            u = mem[mem[(32 * idx) + 128]]
            continue 
        idx = 0
        s = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
        t = cd[4]
        while idx < ('cd', 68).length:
            require idx < mem[96]
            _14535 = mem[mem[(32 * idx) + 128]]
            require idx < ('cd', 68).length
            require calldata.size + (-160 * idx) + -cd[68] - 36 >= 160
            _14588 = mem[64]
            require mem[64] + 160 <= test266151307() and mem[64] + 160 >= mem[64]
            mem[64] = mem[64] + 160
            require cd[((160 * idx) + cd[68] + 36)] == address(cd[((160 * idx) + cd[68] + 36)])
            mem[_14588] = cd[((160 * idx) + cd[68] + 36)]
            require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
            mem[_14588 + 32] = cd[((160 * idx) + cd[68] + 68)]
            require cd[((160 * idx) + cd[68] + 100)] == uint16(cd[((160 * idx) + cd[68] + 100)])
            mem[_14588 + 64] = cd[((160 * idx) + cd[68] + 100)]
            require cd[((160 * idx) + cd[68] + 132)] == uint16(cd[((160 * idx) + cd[68] + 132)])
            mem[_14588 + 96] = cd[((160 * idx) + cd[68] + 132)]
            require cd[((160 * idx) + cd[68] + 164)] == uint16(cd[((160 * idx) + cd[68] + 164)])
            mem[_14588 + 128] = cd[((160 * idx) + cd[68] + 164)]
            if not uint16(cd[((160 * idx) + cd[68] + 100)]):
                mem[mem[64]] = 0xa58d57400000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                mem[mem[64] + 36] = t
                mem[mem[64] + 68] = _14535
                mem[mem[64] + 100] = address(s)
                mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 68)])
                mem[mem[64] + 164] = address(cd[((160 * idx) + cd[68] + 36)])
                mem[mem[64] + 196] = bool(cd[36])
                mem[mem[64] + 228] = uint16(cd[((160 * idx) + cd[68] + 132)])
                require ext_code.size(0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99)
                delegate 0xc4a6bdc15d9cd7091cf3ccd5646cb3b6ef3d7b99.0xa58d574 with:
                     gas gas_remaining wei
                    args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, _14535, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36]), uint16(cd[((160 * idx) + cd[68] + 132)])
                if not delegate.return_code:
                    revert with ext_call.return_data[0 len return_data.size]
            else:
                if 3 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                    mem[mem[64]] = 0x9f22937f00000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                    mem[mem[64] + 36] = t
                    mem[mem[64] + 68] = address(s)
                    mem[mem[64] + 100] = address(cd[((160 * idx) + cd[68] + 68)])
                    mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 36)])
                    mem[mem[64] + 164] = bool(cd[36])
                    require ext_code.size(0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e)
                    delegate 0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e.0x9f22937f with:
                         gas gas_remaining wei
                        args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36])
                    if not delegate.return_code:
                        revert with ext_call.return_data[0 len return_data.size]
                else:
                    if 6 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                        mem[mem[64]] = 0x9f22937f00000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                        mem[mem[64] + 36] = t
                        mem[mem[64] + 68] = address(s)
                        mem[mem[64] + 100] = address(cd[((160 * idx) + cd[68] + 68)])
                        mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 36)])
                        mem[mem[64] + 164] = bool(cd[36])
                        require ext_code.size(0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e)
                        delegate 0x95c8cb9546072b67dd60a6fd3c72690cf09fcf8e.0x9f22937f with:
                             gas gas_remaining wei
                            args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36])
                        if not delegate.return_code:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        if 32 == uint16(cd[((160 * idx) + cd[68] + 100)]):
                            mem[mem[64]] = 0x35d92d6900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7
                            mem[mem[64] + 36] = t
                            mem[mem[64] + 68] = _14535
                            mem[mem[64] + 100] = address(s)
                            mem[mem[64] + 132] = address(cd[((160 * idx) + cd[68] + 68)])
                            mem[mem[64] + 164] = address(cd[((160 * idx) + cd[68] + 36)])
                            mem[mem[64] + 196] = bool(cd[36])
                            require ext_code.size(0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5)
                            delegate 0x1e794f8fc36e75d42bdfcae01a626e2aab7c2cd5.0x35d92d69 with:
                                 gas gas_remaining wei
                                args 0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7, t, _14535, address(s), address(cd[((160 * idx) + cd[68] + 68)]), address(cd[((160 * idx) + cd[68] + 36)]), bool(cd[36])
                            if not delegate.return_code:
                                revert with ext_call.return_data[0 len return_data.size]
            require idx < mem[96]
            require idx < ('cd', 68).length
            require cd[((160 * idx) + cd[68] + 68)] == address(cd[((160 * idx) + cd[68] + 68)])
            idx = idx + 1
            s = cd[((160 * idx) + cd[68] + 68)]
            t = mem[mem[(32 * idx) + 128]]
            continue 
}



}

contract main {




// =====================  Runtime code  =====================


address stor0;
address stor1;
mapping of struct stor3;
mapping of address stor99;

function _fallback() payable {
    revert
}

function sub_b01f5a7c(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if stor0 != msg.sender:
        if stor1 != msg.sender:
            revert with 0, 'ERR: no sentry sender'
    stor0 = address(arg1)
}

function getAddress(string arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 2
    mem[ceil32(ceil32(arg1.length)) + 97] = stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])]
    return memory
      from ceil32(ceil32(arg1.length)) + 97
       len 32
}

function sub_c3fcf9d3(?) payable {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 2
    mem[ceil32(ceil32(arg1.length)) + 97] = not not stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])]
    return memory
      from ceil32(ceil32(arg1.length)) + 97
       len 32
}

function pay(string arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    if stor0 != msg.sender:
        if stor1 != msg.sender:
            revert with 0, 'ERR: no sentry sender'
    mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 2
    if uint8(stor3[stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])]].field_512):
        mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
        mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 2
        if uint256(stor3[stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])]].field_256) > -2:
            revert with 0, 17
        uint256(stor3[stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])]].field_256)++
}

function register(string arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    mem[ceil32(ceil32(arg1.length)) + 97 len ceil32(arg1.length)] = arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]
    mem[arg1.length + ceil32(ceil32(arg1.length)) + 97] = 2
    if stor[sha3(mem[ceil32(ceil32(arg1.length)) + 97 len arg1.length + 32])]:
        revert with 0, 'ERR: name not available.'
    if arg1.length <= 3:
        revert with 0, 'REGISTER: NAME SIZE INVALID'
    if arg1.length >= 32:
        revert with 0, 'REGISTER: NAME SIZE INVALID'
    if bool(stor3[msg.sender].field_0):
        if bool(stor3[msg.sender].field_0) == uint255(uint256(stor3[msg.sender].field_0)) * 0.5 < 32:
            revert with 0, 34
        if arg1.length:
            uint256(stor3[msg.sender][].field_0) = Array(len=arg1.length, data=arg1[all])
        else:
            uint256(stor3[msg.sender].field_0) = 0
            idx = 0
            while (uint255(uint256(stor3[msg.sender].field_0)) * 0.5) + 31 / 32 > idx:
                uint256(stor3[msg.sender][idx].field_0) = 0
                idx = idx + 1
                continue 
    else:
        if bool(stor3[msg.sender].field_0) == stor3[msg.sender].field_1 % 128 < 32:
            revert with 0, 34
        if arg1.length:
            uint256(stor3[msg.sender][].field_0) = Array(len=arg1.length, data=arg1[all])
        else:
            uint256(stor3[msg.sender].field_0) = 0
            idx = 0
            while stor3[msg.sender].field_1 % 128 + 31 / 32 > idx:
                uint256(stor3[msg.sender][idx].field_0) = 0
                idx = idx + 1
                continue 
    uint256(stor3[msg.sender].field_256) = 0
    uint8(stor3[msg.sender].field_512) = 1
    stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 2)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 96) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256] = msg.sender
}

function getUser(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if bool(stor3[address(arg1)].field_0):
        if bool(stor3[address(arg1)].field_0) == uint255(uint256(stor3[address(arg1)].field_0)) * 0.5 < 32:
            revert with 0, 34
        if bool(stor3[address(arg1)].field_0):
            if bool(stor3[address(arg1)].field_0) == uint255(uint256(stor3[address(arg1)].field_0)) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, uint256(stor3[address(arg1)].field_0)):
                if 31 >= uint255(uint256(stor3[address(arg1)].field_0)) * 0.5:
                    mem[320] = 256 * Mask(248, 0, stor3[address(arg1)].field_8)
                else:
                    mem[320] = uint256(stor3[address(arg1)].field_0)
                    idx = 320
                    s = 0
                    while (uint255(uint256(stor3[address(arg1)].field_0)) * 0.5) + 288 > idx:
                        mem[idx + 32] = uint256(stor3[address(arg1)][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor3[address(arg1)].field_0) == stor3[address(arg1)].field_1 % 128 < 32:
                revert with 0, 34
            if stor3[address(arg1)].field_1 % 128:
                if 31 >= stor3[address(arg1)].field_1 % 128:
                    mem[320] = 256 * Mask(248, 0, stor3[address(arg1)].field_8)
                else:
                    mem[320] = uint256(stor3[address(arg1)].field_0)
                    idx = 320
                    s = 0
                    while stor3[address(arg1)].field_1 % 128 + 288 > idx:
                        mem[idx + 32] = uint256(stor3[address(arg1)][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        return 32, 96, 
               uint256(stor3[address(arg1)].field_256),
               bool(uint8(stor3[address(arg1)].field_512)),
               2 * Mask(256, -1, uint256(stor3[address(arg1)].field_0)),
               mem[320 len ceil32(uint255(uint256(stor3[address(arg1)].field_0)) * 0.5)]
    if bool(stor3[address(arg1)].field_0) == stor3[address(arg1)].field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor3[address(arg1)].field_0):
        if bool(stor3[address(arg1)].field_0) == uint255(uint256(stor3[address(arg1)].field_0)) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, uint256(stor3[address(arg1)].field_0)):
            if 31 >= uint255(uint256(stor3[address(arg1)].field_0)) * 0.5:
                mem[320] = 256 * Mask(248, 0, stor3[address(arg1)].field_8)
            else:
                mem[320] = uint256(stor3[address(arg1)].field_0)
                idx = 320
                s = 0
                while (uint255(uint256(stor3[address(arg1)].field_0)) * 0.5) + 288 > idx:
                    mem[idx + 32] = uint256(stor3[address(arg1)][s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
    else:
        if bool(stor3[address(arg1)].field_0) == stor3[address(arg1)].field_1 % 128 < 32:
            revert with 0, 34
        if stor3[address(arg1)].field_1 % 128:
            if 31 >= stor3[address(arg1)].field_1 % 128:
                mem[320] = 256 * Mask(248, 0, stor3[address(arg1)].field_8)
            else:
                mem[320] = uint256(stor3[address(arg1)].field_0)
                idx = 320
                s = 0
                while stor3[address(arg1)].field_1 % 128 + 288 > idx:
                    mem[idx + 32] = uint256(stor3[address(arg1)][s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
    return 32, 96, 
           uint256(stor3[address(arg1)].field_256),
           bool(uint8(stor3[address(arg1)].field_512)),
           stor3[address(arg1)].field_0 % 128,
           mem[320 len ceil32(stor3[address(arg1)].field_1 % 128)]
}



}
